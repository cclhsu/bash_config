#!/usr/bin/env bash
#******************************************************************************
# Copyright 2020 Clark Hsu
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

#******************************************************************************
# How To
# mkdir -p ${HOME}/.my_libs/bash/
# cp myprojects_template ${HOME}/.my_libs/bash/cp myprojects

#******************************************************************************
# Source

# LIB_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"

#******************************************************************************

#******************************************************************************
# Functions

# function function_01() {
#     if [ "$#" != "1" ]; then
#         log_e "Usage: ${FUNCNAME[0]} <ARGS>"
#         log_e "${FUNCNAME[0]} $# ${*}"
#     else
#         log_m "${FUNCNAME[0]} $# ${*}"
#         # cd "${TOP_DIR:?}" || exit 1
#     fi
# }

#******************************************************************************
# Sourcing

function source_rc() {
    if [ "$#" != "2" ]; then
        log_e "Usage: ${FUNCNAME[0]} <DISTRO> <PLATFORM>"
        log_e "${FUNCNAME[0]} $# ${*}"
    else
        # log_m "${FUNCNAME[0]} $# ${*}"
        # cd "${TOP_DIR:?}" || exit 1

        case ${1} in
            # alpine) ;;
            # centos | fedora | rhel | oracle-linux | alma-linux | rocky-linux) ;;
            # cirros) ;;
            # debian | raspios | ubuntu) ;;
            # macos | macosx) ;;
            # opensuse-leap | opensuse-tumbleweed | sles) ;;
            windows) ;;

            *)
                # echo -e "\n>>> Source ${1} RC...\n"
                # check_file_exist "${TOP_DIR:?}/os-openrc-${1}.sh"
                # if [[ $? -ne 0 ]]; then
                #     echo -e "\nPlease download/setup os-openrc-${1}.sh"
                #     exit 1
                # fi
                # # shellcheck source=/dev/null
                # source "${TOP_DIR:?}/os-openrc-${1}.sh"
                [[ $PS1 && -f "${TOP_DIR:?}/os-openrc-${1}.sh" ]] && source "${TOP_DIR:?}/os-openrc-${1}.sh" || true
                ;;
        esac

        case ${2} in
            aws | azure | gcp | openstack | vmware | vsphere)
                echo -e "\n>>> Source ${2} RC...\n"
                check_file_exist "${TOP_DIR:?}/container-openrc-${2}.sh"
                if [[ $? -ne 0 ]]; then
                    echo -e "\nPlease download/setup container-openrc-${2}.sh"
                    exit 1
                fi
                # shellcheck source=/dev/null
                source "${TOP_DIR:?}/container-openrc-${2}.sh"
                ;;
            libvirt) ;;
            bare-matel | host) ;;
            *)
                [[ $PS1 && -f "${TOP_DIR:?}/os-openrc-${2}.sh" ]] && source "${TOP_DIR:?}/os-openrc-${2}.sh" || true
                ;;
        esac
    fi
}

#******************************************************************************
# Detection Environment

# https://danilodellaquila.com/en/blog/linux-package-management-cheatsheet
# https://distrowatch.com/dwres.php?resource=package-management
# https://lzone.de/cheat-sheet/Package%20Management
# https://www.tecmint.com/list-all-running-services-under-systemd-in-linux/
function detect_package_system() {
    if [ "$#" != "0" ] && [ "$#" != "2" ] && [ "$#" != "3" ]; then
        log_e "Usage: ${FUNCNAME[0]} [<PACKAGE_MANAGER> <PACKAGE_SYSTEM> [<DISTRO>]]"
        log_e "${FUNCNAME[0]} $# ${*}"
    else
        log_m "${FUNCNAME[0]} $# ${*}"
        # cd "${TOP_DIR:?}" || exit 1

        # DISTROS="alma-linux alpine arch-linux centos chromeos cirros debian fedora gentoo hyperiotos macosx opensuse-leap opensuse-tumbleweed oracle-linux photonos rancher-harvester rancker-k3os rancher-os raspios rhel rocky-linux sles ubuntu microsoft pxe"
        DISTROS="alma-linux alpine centos cirros debian fedora macosx opensuse-leap opensuse-tumbleweed oracle-linux rancher-harvester rancker-k3os rancher-os rocky-linux sles ubuntu microsoft pxe"
        OSS="darwin linux freebsd microsoft"
        ARCHS="x86_64 amd64"
        INSTALL_METHODS="bin tar bz2 xz zstd rar zip script rpm go npm pip docker podman"
        PROJECT_TYPES="ansible_app bash_app bash_deployment_app bash_install_app bash_remote_deployment_app docker_app helm_app helm3_app minifest_app deployment_app terraform_app"

        INFRASTRUCTURE_DEPLOYMENT_PROJECTS="terraform_env terraform_mos"
        LOCATIONS="local remote"
        PLATFORMS="aws azure bare-metal gcp libvirt openstack vmware vsphere"
        PLATFORM_DISTROS="${DISTROS} mos"
        RUNTIMES="daemon container kubernetes"
        ROLES="server client master worker helloworld all"
        SSH_USERS="${DISTROS} mos root ec2-user"

        # if [ "${PLATFORM}" == "" ]; then
        #     # select_x_from_array "${PLATFORMS}" "PLATFORM" PLATFORM # "libvirt"
        #     read_and_confirm "PLATFORM MSG" PLATFORM "libvirt"
        # fi
        if [ "$#" == "2" ]; then
            PACKAGE_MANAGER=${1} # apk,apt-get,brew,dnf,emerge,pacman,yum,zypper,xbps-install,tar,zip
            PACKAGE_SYSTEM=${2}  # apk,dpkg,pkgbuild,rpm,tar,zip,go,npm,pip,docker
            if [ "${DISTRO}" == "" ]; then
                select_x_from_array "${DISTROS}" "DISTRO" DISTRO # centos
            fi
        elif [ "$#" == "3" ]; then
            PACKAGE_MANAGER=${1} # apk,apt-get,brew,dnf,emerge,pacman,yum,zypper,xbps-install,tar,zip
            PACKAGE_SYSTEM=${2}  # apk,dpkg,pkgbuild,rpm,tar,zip,go,npm,pip,docker
            DISTRO=${2}          # alpine | cirros | centos | fedora | rhel | debian | raspios | ubuntu | rancher-os | rancker-k3os | opensuse-leap | opensuse-tumbleweed | oracle-linux | sles | macosx | microsoft
        else
            PACKAGE_MANAGER=$(basename $(command -v {apt-get,brew,dnf,emerge,pacman,yum,zypper,xbps-install} 2>/dev/null) 2>/dev/null || basename $(command -v apk 2>/dev/null) 2>/dev/null)
            PACKAGE_SYSTEM=$(basename $(command -v {dpkg,pkgbuild,rpm} 2>/dev/null) 2>/dev/null || basename $(command -v apk 2>/dev/null) 2>/dev/null)
            DISTRO=$(cat /etc/*-release 2>/dev/null | uniq -u | grep ^ID= | cut -d = -f 2 | sed s/\"//g | sed s/linux/-linux/g && sw_vers -productName 2>/dev/null | sed 's/ //g' | tr A-Z a-z) # alpine | centos | debian | fedora | macosx | microsoft | opensuse-leap | opensuse-tumbleweed | oracle-linux | sles | ubuntu
        fi
        OS=$(uname -s | tr A-Z a-z) # darwin | linux | freebsd | microsoft
        case ${OS} in
            CYGWIN* | *_NT-*)
                OS=windows
                HOST_EXE=.exe
                if [ "x${OSTYPE}" = xcygwin ]; then
                    OS=cygwin
                fi
                ;;
            *)
                HOST_EXE=""
                ;;
        esac
        ARCH=$(uname -m | sed -e 's/x86_64/amd64/' -e 's/aarch64/arm64/') # x86_64 | amd64

        echo -e "\n>>> ${PACKAGE_MANAGER} ${PACKAGE_SYSTEM} ${DISTRO} ${OS} ${ARCH}...."
    fi
}

function detect_host_hardware() {
    if [ "$#" != "0" ] && [ "$#" != "2" ] && [ "$#" != "3" ]; then
        log_e "Usage: ${FUNCNAME[0]} [<PACKAGE_MANAGER> <PACKAGE_SYSTEM> [<DISTRO>]]"
        log_e "${FUNCNAME[0]} $# ${*}"
    else
        log_m "${FUNCNAME[0]} $# ${*}"
        # cd "${TOP_DIR:?}" || exit 1

        HOST_CPU=$(uname -p)
        case ${OS} in
            linux)
                HOST_NUM_CPUS=$(cat /proc/cpuinfo | grep processor | wc -l)
                ;;
            darwin | freebsd)
                HOST_NUM_CPUS=$(sysctl -n hw.ncpu)
                ;;
            windows | cygwin)
                HOST_NUM_CPUS=${NUMBER_OF_PROCESSORS}
                ;;
            *) # let's play safe here
                HOST_NUM_CPUS=1 ;;
        esac

        case ${OS} in
            linux)
                HOST_RAM=$(free -m | grep "Mem:" | awk '{print ${2}}')
                ;;
            darwin | freebsd)
                HOST_RAM=$(sysctl -a | grep hw.memsize | awk '{print ${3}}')
                ;;
            *) # let's play safe here
                HOST_RAM="" ;;
        esac

        HOST_HHD=$(df -h | sed -n 2p | awk '{print ${2}}')
    fi
}

# function set_project() {
#     if [ "$#" != "1" ]; then
#         log_e "Usage: ${FUNCNAME[0]} <ARGS>"
#         log_e "${FUNCNAME[0]} $# ${*}"
#     else
#         log_m "${FUNCNAME[0]} $# ${*}"
#         # cd "${TOP_DIR:?}" || exit 1

#         local PLATFORMS="aws azure bare-metal gcp libvirt openstack vmware vsphere"
#         # local DISTROS="alma-linux alpine arch-linux centos chromeos cirros debian fedora gentoo hyperiotos macosx opensuse-leap opensuse-tumbleweed oracle-linux photonos rancher-harvester rancker-k3os rancher-os raspios rhel rocky-linux sles ubuntu microsoft pxe"
#         local DISTROS="alma-linux alpine centos cirros debian fedora macosx opensuse-leap opensuse-tumbleweed oracle-linux rancher-harvester rancker-k3os rancher-os rocky-linux sles ubuntu microsoft pxe"
#         local OSS="darwin linux freebsd microsoft"
#         local ARCHS="x86_64 amd64"

#         if [ "${SRC_DIR}" == "" ]; then
#             # select_x_from_array "a b c" "SRC_DIR" SRC_DIR # "a"
#             # read_and_confirm "SRC_DIR MSG" SRC_DIR # "SRC_DIR set value"

#             # SRC_DIR=${HOME}/Documents/myProject/${REPO}/${PROJECT}
#             SRC_DIR=${HOME}/Documents/myProject/Template/helloworld_app
#             # SRC_DIR=${HOME}/Documents/myProject/Template/helloworld_template
#         fi

#         if [ "${PROJECT_BIN}" == "" ]; then
#             # select_x_from_array "a b c" "PROJECT_BIN" PROJECT_BIN # "a"
#             PROJECT_BIN= #
#         fi

#         if [ "${INSTALL_METHOD}" == "" ]; then
#             # select_x_from_array "bin tar bz2 xz zstd rar zip script rpm go npm pip docker podman" "INSTALL_METHOD" INSTALL_METHOD # "a"
#             INSTALL_METHOD=tar #
#         fi

#         SYSTEMD_SERVICE_NAME=${PROJECT_BIN} #
#         GITHUB_USER= #
#         if [ "${GITHUB_USER}" == "" ]; then
#             # select_x_from_array "cclhsu" "GITHUB_USER" GITHUB_USER # "cclhsu"
#             read_and_confirm "GITHUB_USER MSG" GITHUB_USER #"cclhsu"
#         fi

#         GITHUB_USER_NAME= #
#         if [ "${GITHUB_USER_NAME}" == "" ]; then
#             # select_x_from_array "cclhsu" "GITHUB_USER_NAME" GITHUB_USER_NAME # "Clark Hsu"
#             read_and_confirm "GITHUB_USER_NAME MSG" GITHUB_USER_NAME #"Clark Hsu"
#         fi

#         if [ "${GITHUB_PROJECT}" == "" ]; then
#             read_and_confirm "GITHUB_PROJECT MSG" GITHUB_PROJECT "${PROJECT_BIN}"
#         fi

#         # https://github.com/${GITHUB_USER}/${GITHUB_PROJECT}/releases
#         if [ "${PACKAGE_VERSION}" == "" ]; then
#             # read_and_confirm "PACKAGE_VERSION MSG" PACKAGE_VERSION "v0.0.1"
#             PACKAGE_VERSION=$(curl -s "https://api.github.com/repos/${GITHUB_USER}/${GITHUB_PROJECT}/releases/latest" | jq --raw-output .tag_name)
#         fi

#         if [ "${PLATFORM}" == "" ]; then
#             # select_x_from_array "${PLATFORMS}" "PLATFORM" PLATFORM # "libvirt"
#             read_and_confirm "PLATFORM MSG" PLATFORM "libvirt"
#         fi

#         if [ "${PLATFORM_DISTRO}" == "" ]; then
#             select_x_from_array "${PLATFORM_DISTROS}" "PLATFORM_DISTRO" PLATFORM_DISTRO # centos
#         fi

#         if [ "${DISTRO}" == "" ]; then
#             select_x_from_array "${DISTROS}" "DISTRO" DISTRO # centos
#         fi

#         if [ "${OS}" == "" ]; then
#             select_x_from_array "${OSS}" "OS" OS # "linux"
#             read_and_confirm "OS MSG" OS "linux"
#         fi

#         if [ "${ARCH}" == "" ]; then
#             select_x_from_array "${ARCHS}" "ARCH" ARCH # "amd64"
#             read_and_confirm "ARCH MSG" ARCH "amd64"
#         fi

#         echo ">>> Platform/Distribution: ${PLATFORM}/${PLATFORM_DISTRO}"
#         echo ">>> Package: ${DISTRO}/${GITHUB_USER}/${GITHUB_PROJECT}/${PACKAGE_VERSION}/${PROJECT_BIN}-${OS}-${ARCH}"
#     fi
# }

# function set_deployment() {
#     if [ "$#" != "1" ]; then
#         log_e "Usage: ${FUNCNAME[0]} <ARGS>"
#         log_e "${FUNCNAME[0]} $# ${*}"
#     else
#         log_m "${FUNCNAME[0]} $# ${*}"
#         # cd "${TOP_DIR:?}" || exit 1

#         local LOCATIONS="local remote"
#         local PLATFORMS="aws azure bare-metal gcp libvirt openstack vmware vsphere"
#         local PLATFORM_DISTROS="${DISTROS}"
#         local RUNTIMES="daemon container kubernetes"
#         local ROLES="server client master worker helloworld all"
#         local SSH_USERS="${DISTROS} mos root ec2-user"

#         if [ "${LOCATION}" == "" ]; then
#             # select_x_from_array "${LOCATIONS}" "LOCATION" LOCATION # "remote"
#             read_and_confirm "LOCATION MSG" LOCATION "remote"
#         fi
#         if [ "${PLATFORM}" == "" ]; then
#             # select_x_from_array "${PLATFORMS}" "PLATFORM" PLATFORM # "libvirt"
#             read_and_confirm "PLATFORM MSG" PLATFORM "libvirt"
#         fi
#         if [ "${PLATFORM_DISTRO}" == "" ]; then
#             # select_x_from_array "${DISTROS}" "PLATFORM_DISTRO" PLATFORM_DISTRO # "centos"
#             read_and_confirm "PLATFORM_DISTRO" PLATFORM_DISTRO "centos"
#         fi
#         if [ "${RUNTIME}" == "" ]; then
#             # select_x_from_array "${RUNTIMES}" "RUNTIME" RUNTIME # "daemon"
#             read_and_confirm "RUNTIME MSG" RUNTIME "daemon"
#         fi
#         if [ "${ROLE}" == "" ]; then
#             # select_x_from_array "${ROLES}" "ROLE" ROLE # "helloworld"
#             read_and_confirm "ROLE MSG" ROLE "helloworld"
#         fi
#         if [ "${SSH_USER}" == "" ]; then
#             # select_x_from_array " "${SSH_USERS}" SSH_USER # "sles"
#             read_and_confirm "SSH_USER MSG" SSH_USER "centos"
#         fi
#         if [ "${SSH_PASSWORD}" == "" ]; then
#             read_and_confirm "SSH_PASSWORD MSG" SSH_PASSWORD "linux"
#         fi
#         echo ">>> Platform/Distribution: ${PLATFORM}/${PLATFORM_DISTRO}"
#         echo ">>> Package: ${DISTRO}/${GITHUB_USER}/${GITHUB_PROJECT}/${PACKAGE_VERSION}/${PROJECT_BIN}-${OS}-${ARCH}"
#     fi
# }

#******************************************************************************
# Set Alias

function set_alias_by_distribution() {
    if [ "$#" != "0" ] && [ "$#" != "1" ]; then
        log_e "Usage: ${FUNCNAME[0]} [<DISTRO>] [<CASK>]"
        log_e "${FUNCNAME[0]} $# ${*}"
    else
        log_m "${FUNCNAME[0]} $# ${*}"
        # cd "${TOP_DIR:?}" || exit 1

        if [ "$#" == "1" ]; then
            local _DISTRO=${1} # alpine | centos | debian | fedora | macosx | microsoft | opensuse-leap | opensuse-tumbleweed | oracle-linux | sles | ubuntu
        else
            local _DISTRO=${DISTRO}
        fi

        case ${_DISTRO} in
            alpine)
                USER_BIN="/usr/bin"
                USER_LOCAL_BIN="/usr/local/bin"
                ETC="/etc"

                # ADD_KEY="/etc/apk/keys/"
                LIST_REPO="cat /etc/apk/repositories"
                # ADD_REPO="/etc/apk/repositories"    # /etc/apk/repositories
                # REMOVE_REPO="/etc/apk/repositories" # /etc/apk/repositories
                REPO_UPDATE="apk update"
                INSTALL_PACKAGE="apk add --update --no-cache"
                REINSTALL_PACKAGE=""
                UNINSTALL_PACKAGE="apk del --purge"
                DOWNLOAD_PACKAGE=""
                UPGRADE_PACKAGE="apk upgrade"
                DIST_UPGRADE="apk upgrade --available"
                SEARCH_PACKAGE="apk search"
                WHAT_PROVIDES=""
                LIST_INSTALL_PACKAGES="apk list"
                SHOW_PACKAGE_INFORMATION="apk info"
                CLEAN_KERNEL=""
                CLEAN_CACHE="apk cache clean; sudo rm -rf /var/cache/apk/*; ls /var/cache/apk/"

                ENABLE_SERVICE=""
                START_SERVICE=""
                STATUS_SERVICE=""
                LOG_SERVICE=""
                STOP_SERVICE=""
                DISABLE_SERVICE=""
                LIST_SERVICE=""

                OPEN="open" # xdg-open | open
                ;;
            centos | fedora | rhel | oracle-linux | alma-linux | rocky-linux)
                USER_BIN="/usr/bin"
                USER_LOCAL_BIN="/usr/local/bin"
                ETC="/etc"

                PACKAGE_MANAGER_TYPE=yum # yum | dnf
                if [ ${PACKAGE_MANAGER_TYPE} == yum ]; then
                    # https://access.redhat.com/sites/default/files/attachments/rh_yum_cheatsheet_1214_jcs_print-1.pdf
                    ADD_KEY="sudo rpm --import" # /etc/pki/rpm-gpg/
                    LIST_REPO="sudo yum repolist"
                    # ADD_REPO="yum-config-manager --add-repo" # /etc/yum.repos.d/
                    # REMOVE_REPO="/etc/yum.repos.d/"          # /etc/yum.repos.d/
                    REPO_UPDATE="sudo yum check-update"
                    INSTALL_PACKAGE="sudo yum install -y"
                    REINSTALL_PACKAGE=""
                    UNINSTALL_PACKAGE="sudo yum remove -y --remove-leaves"
                    DOWNLOAD_PACKAGE="sudo yum install -y --downloadonly" #--downloaddir="${DOWNLOAD_DIR}" "${PACKAGE}"
                    UPGRADE_PACKAGE="sudo yum update -y"
                    DIST_UPGRADE="sudo yum upgrade -y"
                    SEARCH_PACKAGE="sudo yum search" # sudo yum list
                    WHAT_PROVIDES="sudo yum whatprovides"
                    LIST_INSTALL_PACKAGES="sudo rpm -qa"
                    LIST_PACKAGES_CONTENT="sudo rpm -ql"
                    SHOW_PACKAGE_INFORMATION="sudo yum info"
                    CLEAN_KERNEL="package-cleanup --oldkernels --count=2;sed -i 's/^installonly_limit=.*/installonly_limit=2/g' /etc/yum.conf; rpm -q kernel;"
                    CLEAN_CACHE="sudo yum clean all; sudo rm -rf /var/cache/yum/*; ls /var/cache/yum/;"
                else
                    # https://dnf.readthedocs.io/en/latest/command_ref.html
                    # https://cheatography.com/misterrabinhalder/cheat-sheets/dnf/
                    # https://www.linuxtechi.com/dnf-command-examples-rpm-management-fedora-linux/
                    ADD_KEY="sudo rpm --import" # /etc/pki/rpm-gpg/
                    LIST_REPO="sudo dnf repolist --all"
                    # ADD_REPO="dnf config-manager --add-repo" # /etc/yum.repos.d/
                    # REMOVE_REPO="/etc/yum.repos.d/"          # /etc/yum.repos.d/
                    REPO_UPDATE="sudo dnf check-update"
                    INSTALL_PACKAGE="sudo dnf install -y"
                    REINSTALL_PACKAGE="sudo dnf reinstall -y"
                    UNINSTALL_PACKAGE="sudo dnf remove -y"
                    DOWNLOAD_PACKAGE="sudo dnf download" -y
                    UPGRADE_PACKAGE="sudo dnf upgrade -y"
                    DIST_UPGRADE="sudo dnf distro-sync"
                    SEARCH_PACKAGE="sudo dnf search"
                    WHAT_PROVIDES="sudo dnf provides"
                    LIST_INSTALL_PACKAGES="sudo dnf list --installed"
                    LIST_PACKAGES_CONTENT="sudo dnf info"
                    SHOW_PACKAGE_INFORMATION="sudo dnf info"
                    CLEAN_KERNEL="package-cleanup --oldkernels --count=2;sed -i 's/^installonly_limit=.*/installonly_limit=2/g' /etc/yum.conf; rpm -q kernel;"
                    CLEAN_CACHE="sudo dnf clean all; sudo rm -rf /var/cache/yum/*; ls /var/cache/yum/;"
                fi

                ENABLE_SERVICE="sudo systemctl enable"
                START_SERVICE="sudo systemctl start"
                STATUS_SERVICE="sudo systemctl status"
                LOG_SERVICE="sudo journalctl -xet"
                STOP_SERVICE="sudo systemctl stop"
                DISABLE_SERVICE="sudo systemctl disable"
                LIST_SERVICE="sudo systemctl list-units --type=service --state=running"

                OPEN="open" # xdg-open | open
                ;;
            debian | raspios | ubuntu)
                USER_BIN="/usr/bin"
                USER_LOCAL_BIN="/usr/local/bin"
                ETC="/etc"

                # https://www.debian.org/doc/manuals/refcard/refcard#
                # https://www.cyberciti.biz/tips/linux-debian-package-management-cheat-sheet.html
                # https://www.cyberciti.biz/howto/question/linux/dpkg-cheat-sheet.php
                ADD_KEY="sudo apt-key add"
                LIST_REPO="grep -r --include '*.list' '^deb ' /etc/apt/sources.list /etc/apt/sources.list.d/"
                # ADD_REPO="/etc/apt/sources.list.d/"    # /etc/apt/sources.list.d/
                # REMOVE_REPO="/etc/apt/sources.list.d/" # /etc/apt/sources.list.d/
                REPO_UPDATE="sudo apt-get update"
                INSTALL_PACKAGE="sudo apt-get install -y --force-yes"
                REINSTALL_PACKAGE="sudo apt-get update -y --fix-missing; sudo apt-get -f install -y --force-yes --fix-missing"
                UNINSTALL_PACKAGE="sudo apt-get remove --purge -y"
                DOWNLOAD_PACKAGE="sudo apt-get install --download-only --reinstall -y"
                UPGRADE_PACKAGE="sudo apt-get upgrade -y --force-yes"
                DIST_UPGRADE="sudo apt-get dist-upgrade -y --force-yes"
                SEARCH_PACKAGE="sudo apt-cache search"
                WHAT_PROVIDES="sudo dpkg -S"
                LIST_INSTALL_PACKAGES="sudo dpkg -l"
                LIST_PACKAGES_CONTENT="sudo dpkg -L"
                SHOW_PACKAGE_INFORMATION="sudo apt-cache show"
                CLEAN_KERNEL="sudo dpkg -l 'linux-*' | sed '/^ii/!d;/'"$(uname -r | sed "s/\(.*\)-\([^0-9]\+\)/\1/")"'/d;s/^[^ ]- [^ ]* \([^ ]*\).*/\1/;/[0-9]/!d' | xargs sudo apt-get -y purge; sudo dpkg -l | grep linux-image; sudo dpkg -l | grep linux-header"
                CLEAN_CACHE="sudo apt-get autoclean -y; sudo apt-get autoremove -y; sudo apt-get clean; sudo rm -rf /var/cache/apt/*; ls /var/cache/apt/;"

                ENABLE_SERVICE="sudo systemctl enable"
                START_SERVICE="sudo systemctl start"
                STATUS_SERVICE="sudo systemctl status"
                LOG_SERVICE="sudo journalctl -xet"
                STOP_SERVICE="sudo systemctl stop"
                DISABLE_SERVICE="sudo systemctl disable"
                LIST_SERVICE="sudo systemctl list-units --type=service --state=running"

                OPEN="open" # xdg-open | open
                ;;
            opensuse-leap | opensuse-tumbleweed | sles)
                USER_BIN="/usr/bin"
                USER_LOCAL_BIN="/usr/local/bin"
                ETC="/etc"

                # https://en.opensuse.org/images/1/17/Zypper-cheat-sheet-1.pdf
                ADD_KEY="rpm --import"               # /usr/lib/rpm/gnupg/keys/
                ADD_REPO="sudo zypper addrepo"       # --refresh" # /etc/zypp/repos.d/
                REMOVE_REPO="sudo zypper removerepo" # /etc/zypp/repos.d/
                REPO_UPDATE="sudo zypper refresh"
                INSTALL_PACKAGE="sudo zypper --gpg-auto-import-keys --ignore-unknown --non-interactive install"
                REINSTALL_PACKAGE=""
                UNINSTALL_PACKAGE="sudo zypper --non-interactive remove"
                DOWNLOAD_PACKAGE="sudo zypper --non-interactive install --auto-agree-with-licenses --no-gpg-checks --quiet -f --download-only"
                UPGRADE_PACKAGE="sudo zypper update --no-confirm"
                DIST_UPGRADE="sudo zypper dist-upgrade --no-confirm --auto-agree-with-licenses --replacefiles --force-resolution" # --quiet --gpg-auto-import-keys
                SEARCH_PACKAGE="sudo zypper search --details"
                WHAT_PROVIDES="sudo rpm -qf" # zypper search --provides --match-exact | sudo rpm -qf $(which ${*})
                LIST_INSTALL_PACKAGES="sudo zypper search --installed-only --details"
                LIST_PACKAGES_CONTENT="sudo rpm -ql"
                SHOW_PACKAGE_INFORMATION="sudo zypper info"
                CLEAN_KERNEL=""
                CLEAN_CACHE="sudo zypper clean --all; sudo rm -rf /var/cache/zypp/*; ls /var/cache/zypp/;"

                ENABLE_SERVICE="sudo systemctl enable"
                START_SERVICE="sudo systemctl start"
                STATUS_SERVICE="sudo systemctl status"
                LOG_SERVICE="sudo journalctl -xet"
                STOP_SERVICE="sudo systemctl stop"
                DISABLE_SERVICE="sudo systemctl disable"
                LIST_SERVICE="sudo systemctl list-units --type=service --state=running"

                OPEN="open" # xdg-open | open
                ;;
            macos | macosx)
                USER_BIN="/usr/local/bin"
                USER_LOCAL_BIN="/usr/local/bin"
                ETC="/usr/local/etc"

                # https://docs.brew.sh/Manpage
                # https://devhints.io/homebrew
                ADD_KEY=""
                ADD_REPO=""
                REMOVE_REPO=""
                REPO_UPDATE="cd /usr/local/Homebrew/Library/Taps/homebrew/homebrew-core; git stash; git clean -fdx; brew update; brew list;"
                if [ "${CASK}" != "" ] && [ ${CASK} == true ]; then
                    INSTALL_PACKAGE="brew install --cask" # --force # --with-default-names
                    REINSTALL_PACKAGE=""
                    UNINSTALL_PACKAGE="brew uninstall --cask" # --ignore-dependencies --force
                    DOWNLOAD_PACKAGE="brew --cache"
                    UPGRADE_PACKAGE="brew outdated; brew upgrade; brew outdated --cask; brew upgrade --cask; brew doctor --verbose;"
                    DIST_UPGRADE="sudo softwareupdate --list; sudo softwareupdate --all --install --force; sudo xcode-select -p; sxcode-select -v; gcc --version;"
                    SEARCH_PACKAGE="brew search --cask" #
                    WHAT_PROVIDES=""
                    LIST_INSTALL_PACKAGES="brew list --cask" #
                    SHOW_PACKAGE_INFORMATION="brew info"
                    CLEAN_KERNEL=""
                    CLEAN_CACHE="brew cleanup -s; rm -rf $(brew --cache)/*; ls $(brew --cache);"
                    # CONFIG="brew --config"
                    # ENV="brew --env"
                else
                    INSTALL_PACKAGE="brew install" # --cask --force # --with-default-names
                    REINSTALL_PACKAGE=""
                    UNINSTALL_PACKAGE="brew uninstall" # --cask --ignore-dependencies --force
                    DOWNLOAD_PACKAGE="brew --cache"
                    UPGRADE_PACKAGE="brew outdated; brew upgrade; brew outdated --cask; brew upgrade --cask; brew doctor --verbose;"
                    DIST_UPGRADE="sudo softwareupdate --list; sudo softwareupdate --all --install --force; sudo xcode-select -p; xcode-select -v; gcc --version;"
                    SEARCH_PACKAGE="brew search" # --cask
                    WHAT_PROVIDES=""
                    LIST_INSTALL_PACKAGES="brew list" # --cask
                    SHOW_PACKAGE_INFORMATION="brew info"
                    CLEAN_KERNEL=""
                    CLEAN_CACHE="brew cleanup -s; rm -rf $(brew --cache)/*; ls $(brew --cache);"
                    # CONFIG="brew --config"
                    # ENV="brew --env"
                fi

                ENABLE_SERVICE=""
                START_SERVICE="brew services start"
                STATUS_SERVICE="brew services list"
                LOG_SERVICE=""
                STOP_SERVICE="brew services stop"
                DISABLE_SERVICE=""
                LIST_SERVICE="brew services list"

                OPEN="xdg-open" # xdg-open | open
                ;;
            microsoft) ;;

            *) ;;

        esac
    fi
}

function add_key_repo() {
    if [ "$#" != "2" ] && [ "$#" != "3" ]; then
        log_e "Usage: ${FUNCNAME[0]} <PACKAGES_REPO_URL> <PACKAGES_REPO_NAME> [<PACKAGES_KEY_URL>]"
        log_e "${FUNCNAME[0]} $# ${*}"
    else
        log_m "${FUNCNAME[0]} $# ${*}"
        # cd "${TOP_DIR:?}" || exit 1

        case ${DISTRO} in
            alpine) ;;
            alma-linux | arch-linux | chromeos | coreos | gentoo | hyperiotos | oracle-linux | photonos | rocky-linux) ;;
            centos | fedora | rhel | oracle-linux | alma-linux | rocky-linux)
                if [ "${3}" != "" ]; then
                    sudo rpm --import ${3}
                fi
                if [ "${1}" != "" ] && [ "${2}" != "" ]; then
                    sudo curl -L "${1}" -o "/etc/yum.repos.d/${2}.repo"
                    # yum-config-manager --add-repo ${1}
                fi
                ${INSTALL_PACKAGE} epel-release
                ;;
            rancher-harvester | rancher-k3os | rancher-os) ;;
            cirros) ;;
            macos | macosx) ;;
            debian | raspios | ubuntu)
                if [ "${3}" != "" ]; then
                    curl -L "${3}" | sudo apt-key add -
                fi
                if [ "${1}" != "" ] && [ "${2}" != "" ]; then
                    sudo curl -L "${1}" -o "/etc/apt/sources.list.d/${2}.list"
                fi
                ;;
            opensuse-leap | opensuse-tumbleweed | sles)
                if [ "${3}" != "" ]; then
                    sudo rpm --import ${3}
                fi
                if [ "${1}" != "" ] && [ "${2}" != "" ]; then
                    sudo curl -L "${1}" -o "/etc/zypp/repos.d/${2}.repo"
                    # sudo zypper addrepo --refresh ${1}
                fi
                ;;
            microsoft) ;;
            *) ;;
        esac
        ${REPO_UPDATE}
    fi
}

function delete_key_repo() {
    if [ "$#" != "2" ] && [ "$#" != "3" ]; then
        log_e "Usage: ${FUNCNAME[0]} <PACKAGES_REPO_URL> <PACKAGES_REPO_NAME> [<PACKAGES_KEY_URL>]"
        log_e "${FUNCNAME[0]} $# ${*}"
    else
        log_m "${FUNCNAME[0]} $# ${*}"
        # cd "${TOP_DIR:?}" || exit 1

        case ${DISTRO} in
            alpine) ;;
            alma-linux | arch-linux | chromeos | coreos | gentoo | hyperiotos | oracle-linux | photonos | rocky-linux) ;;
            centos | fedora | rhel | oracle-linux | alma-linux | rocky-linux)
                sudo rm -f "/etc/yum.repos.d/${2}.repo"
                # PACKAGE_PROVIDER= # Microsoft
                # KEY=$(rpm -qa gpg-pubkey /* --qf "%{version}-%{release} %{summary}\n" | grep ${PACKAGE_PROVIDER} | awk '{print $1}')
                # sudo rpm -e --allmatches gpg-pubkey-${KEY}
                ;;
            rancher-harvester | rancher-k3os | rancher-os) ;;
            cirros) ;;
            macos | macosx) ;;
            debian | raspios | ubuntu)
                sudo rm -f "/etc/apt/sources.list.d/${2}.list"
                ;;
            opensuse-leap | opensuse-tumbleweed | sles)
                sudo rm -f "/etc/zypp/repos.d/${2}.repo"
                # PACKAGE_PROVIDER= # Microsoft
                # KEY=$(rpm -qa gpg-pubkey /* --qf "%{version}-%{release} %{summary}\n" | grep ${PACKAGE_PROVIDER} | awk '{print $1}')
                # sudo rpm -e --allmatches gpg-pubkey-${KEY}
                ;;
            microsoft) ;;
            *) ;;
        esac
        ${REPO_UPDATE}
    fi
}

#******************************************************************************
#******************************************************************************
# alpine

#******************************************************************************
# centos | fedora | rhel

#******************************************************************************
# debian | raspios | ubuntu

#******************************************************************************
# opensuse-leap | opensuse-tumbleweed | oracle-linux | sles

#******************************************************************************
# macosx

#******************************************************************************
#******************************************************************************
# create_project_skeleton

function create_project_skeleton() {
    if [ "$#" != "0" ] && [ "$#" != "3" ]; then
        log_e "Usage: ${FUNCNAME[0]} <DISTRO> <PLATFORM> <PROJECT_TYPE> [<CREATE_OPENRC> <NEW_ROLE>]"
        log_e "${FUNCNAME[0]} $# ${*}"
    else
        log_m "${FUNCNAME[0]} $# ${*}"
        mkdir -p "${TOP_DIR:?}"
        cd "${TOP_DIR:?}" || exit 1

        if [ "$#" == "3" ]; then
            local DISTRO=${1}
            local PLATFORM=${2}
            local PROJECT_TYPE=${3}
            echo '#!/usr/bin/env bash' >"${TOP_DIR:?}/os-openrc-${DISTRO}.sh"
            echo '#!/usr/bin/env bash' >"${TOP_DIR:?}/container-openrc-${PLATFORM}.sh"
            echo '#!/usr/bin/env bash' >"${TOP_DIR:?}/container-openrc-${PROJECT_TYPE}.sh"
        else
            if [ "${CREATE_OPENRC}" != "" ] && [ ${CREATE_OPENRC} == true ]; then
                for DISTRO in ${DISTROS[*]}; do
                    echo '#!/usr/bin/env bash' >"${TOP_DIR:?}/os-openrc-${DISTRO}.sh"
                done

                for PLATFORM in ${PLATFORMS[*]}; do
                    echo '#!/usr/bin/env bash' >"${TOP_DIR:?}/container-openrc-${PLATFORM}.sh"
                done
            fi
        fi

        case ${PROJECT_TYPE} in
            ansible_app) create_ansible_app_project_skeleton ;;
            bash_app) create_bash_app_project_skeleton "${NEW_ROLE}" ;;
            bash_deployment_app) create_bash_deployment_app_project_skeleton ;;
            bash_install_app) create_bash_install_app_project_skeleton ;;
            bash_remote_deployment_app) create_bash_remote_deployment_app_project_skeleton ;;
            docker_app) create_docker_app_project_skeleton ;;
            podman_app) create_podman_app_project_skeleton ;;
            helm3_app) create_helm3_app_project_skeleton ;;
            deployment_app) create_deployment_app_project_skeleton ;;
            terraform_app) create_terraform_app_project_skeleton ;;
            golang_app) create_golang_app_project_skeleton ;;
            typescript_app) create_typescript_app_project_skeleton ;;
            python3_app) create_python3_app_project_skeleton ;;
            rust_app) create_rust_app_project_skeleton ;;
            *) ;;
        esac
    fi
}

function create_ansible_bootstrap() {
    if [ "$#" != "0" ] && [ "$#" != "1" ]; then
        log_e "Usage: ${FUNCNAME[0]} <NEW_ROLE>"
        log_e "${FUNCNAME[0]} $# ${*}"
    else
        log_m "${FUNCNAME[0]} $# ${*}"
        cd "${TOP_DIR:?}" || exit 1

        if [ "$#" == "1" ]; then
            local NEW_ROLE=${1}
        elif [ "${NEW_ROLE}" == "" ]; then
            local NEW_ROLE=others
        fi

        cat <<\*EOF* >"scripts/bootstrap_ansible.sh"
#!/usr/bin/env bash
# set -x
TOP_DIR=$(cd "$(dirname "${0}")" && pwd)

if [ -x "$(command -v apt-get)" ]; then
    echo -e "\n>>> Prepare APT dependencies...\n"
    apt-get update
    apt-get install -y ca-certificates curl gcc iproute2 python3 python3-dev sudo
elif [ -x "$(command -v yum)" ]; then
    echo -e "\n>>> Prepare YUM dependencies...\n"
    yum makecache
    yum install -y ca-certificates curl gcc iproute python3 python3-devel sudo
elif [ -x "$(command -v zypper)" ]; then
    echo -e "\n>>> Prepare Zypper dependencies...\n"
    zypper --non-interactive --gpg-auto-import-keys refresh
    zypper --non-interactive install -y ca-certificates curl gcc iproute2 python3 python3-devel sudo
else
    echo -e "\n>>> Prepare Zypper dependencies...\n"
fi
echo -e "\n>>> Install PIP...\n"
curl -skL https://bootstrap.pypa.io/get-pip.py | python3

echo -e "\n>>Install PIP dependencies...\n"
# pip3 install --upgrade --ignore-installed --requirement requirements.txt
pip3 install --upgrade --ignore-installed \
                ansible>=2.9.5 \
                ansible-lint \
                ansible-runner \
                ansible-runner-http \
                argcomplete \
                docker \
                flake8 \
                molecule>=3.0.2 \
                netaddr \
                openshift \
                yamllint
*EOF*
        chmod +x scripts/bootstrap_ansible.sh
    fi
}

function create_andible_inventories_for_platforms() {
    if [ "$#" != "0" ] && [ "$#" != "1" ]; then
        log_e "Usage: ${FUNCNAME[0]} <NEW_ROLE>"
        log_e "${FUNCNAME[0]} $# ${*}"
    else
        log_m "${FUNCNAME[0]} $# ${*}"
        cd "${TOP_DIR:?}" || exit 1

        if [ "$#" == "1" ]; then
            local NEW_ROLE=${1}
        elif [ "${NEW_ROLE}" == "" ]; then
            local NEW_ROLE=others
        fi

        # production staging mos ${PLATFORMS[*]}
        # production staging mos libvirt
        for INVENTORY in production staging mos libvirt; do
            cat <<*EOF* >"inventories/${INVENTORY}/hosts"
[all]


# [all:vars]
# ansible_python_interpreter=/usr/bin/python3

[remotes_mos]
10.17.1.0
10.17.2.0
10.17.3.0
10.17.4.0
10.17.5.0
10.17.6.0
10.17.7.0
10.17.8.0
10.17.9.0
10.17.10.0
10.17.11.0
10.17.12.0

[remotes_mos:vars]
# ansible_connection=ssh
ansible_user=mos
ansible_linux=linux
ansible_ssh_private_key_file=~/.ssh/id_rsa
# ansible_python_interpreter=/usr/bin/python3
# ansible_become=yes

[remotes_env]
10.17.1.0
10.17.2.0
10.17.3.0

[remotes_env:vars]
# ansible_connection=ssh
# ansible_user=centos
ansible_ssh_private_key_file=~/.ssh/id_rsa
# ansible_python_interpreter=/usr/bin/python3
# ansible_become=yes

[local]
0.0.0.0

[loadbalancer]
10.17.1.0

[alpines]
10.17.2.0

[centos]
10.17.3.0

[debian]
10.17.4.0

[fedora]
10.17.5.0

[rancher-harvester]
10.17.6.0

[rancher-k3os]
10.17.7.0

[rancher-os]
10.17.8.0

[opensuse-leap]
10.17.9.0

[opensuse-tumbleweed]
10.17.10.0

[sles]
10.17.11.0

[ubuntu]
10.17.12.0

[centos-masters]
centos-master ansible_host=10.17.2.0

[centos-masters:vars]
# ansible_connection=ssh
ansible_user=centos
# ansible_linux=linux
ansible_ssh_private_key_file=~/.ssh/id_rsa
# ansible_python_interpreter=/usr/bin/python3
# ansible_become=yes

[centos-workers]
centos-worker1 ansible_host=10.17.3.0
centos-worker2 ansible_host=10.17.3.1

[centos-workers:vars]
# ansible_connection=ssh
ansible_user=centos
# ansible_linux=linux
ansible_ssh_private_key_file=~/.ssh/id_rsa
# ansible_python_interpreter=/usr/bin/python3
# ansible_become=yes

[ubuntu-masters]
ubuntu-master ansible_host=10.17.2.0

[ubuntu-masters:vars]
# ansible_connection=ssh
ansible_user=centos
# ansible_linux=linux
ansible_ssh_private_key_file=~/.ssh/id_rsa
# ansible_python_interpreter=/usr/bin/python3
# ansible_become=yes

[ubuntu-workers]
ubuntu-worker1 ansible_host=10.17.3.0
ubuntu-worker2 ansible_host=10.17.3.1

[ubuntu-workers:vars]
# ansible_connection=ssh
ansible_user=centos
# ansible_linux=linux
ansible_ssh_private_key_file=~/.ssh/id_rsa
# ansible_python_interpreter=/usr/bin/python3
# ansible_become=yes

*EOF*
        done
    fi
}

function get_ansible_config() {
    if [ "$#" != "0" ] && [ "$#" != "1" ]; then
        log_e "Usage: ${FUNCNAME[0]} <NEW_ROLE>"
        log_e "${FUNCNAME[0]} $# ${*}"
    else
        log_m "${FUNCNAME[0]} $# ${*}"
        cd "${TOP_DIR:?}" || exit 1

        if [ "$#" == "1" ]; then
            local NEW_ROLE=${1}
        elif [ "${NEW_ROLE}" == "" ]; then
            local NEW_ROLE=others
        fi

        curl -L https://raw.githubusercontent.com/ansible/ansible/devel/examples/ansible.cfg -o ansible.cfg
        sed -i "s/#host_key_checking = True/host_key_checking = False/g" ansible.cfg
        sed -i 's/#ssh_args = -C -o ControlMaster=auto -o ControlPersist=60s/ssh_args = -o ControlMaster=auto -o ControlPersist=60s/g' ansible.cfg
        sed -i "s/#timeout = 10/#timeout = 15/g" ansible.cfg
    fi
}

function create_ansible_playbooks_for_hello_world() {
    if [ "$#" != "0" ] && [ "$#" != "1" ]; then
        log_e "Usage: ${FUNCNAME[0]} <NEW_ROLE>"
        log_e "${FUNCNAME[0]} $# ${*}"
    else
        log_m "${FUNCNAME[0]} $# ${*}"
        cd "${TOP_DIR:?}" || exit 1

        if [ "$#" == "1" ]; then
            local NEW_ROLE=${1}
        elif [ "${NEW_ROLE}" == "" ]; then
            local NEW_ROLE=others
        fi

        cat <<\*EOF* >"playbooks/hello_world.yml"
---
- name: Hello World!
  hosts: "{{ hosts | default('remotes') }}"
  vars:
    who: "world"
  tasks:
  - name: Hello World!
    shell: echo "Hello, {{ who }}!"
  - name: output a message
    debug: msg="Hello, {{ who }}!"
*EOF*
    fi
}

function create_ansible_playbooks_for_hello_role() {
    if [ "$#" != "0" ] && [ "$#" != "1" ]; then
        log_e "Usage: ${FUNCNAME[0]} <NEW_ROLE>"
        log_e "${FUNCNAME[0]} $# ${*}"
    else
        log_m "${FUNCNAME[0]} $# ${*}"
        cd "${TOP_DIR:?}" || exit 1

        if [ "$#" == "1" ]; then
            local NEW_ROLE=${1}
        elif [ "${NEW_ROLE}" == "" ]; then
            local NEW_ROLE=others
        fi

        cat <<\*EOF* >"playbooks/hello_role.yml"
---
- hosts: "{{ hosts | default('remotes') }}"
  remote_user: mos
  become: true
  roles:
    - role: roles/helloworld
*EOF*
    fi
}

function create_ansible_playbooks_for_package_installed() {
    if [ "$#" != "0" ] && [ "$#" != "1" ]; then
        log_e "Usage: ${FUNCNAME[0]} <NEW_ROLE>"
        log_e "${FUNCNAME[0]} $# ${*}"
    else
        log_m "${FUNCNAME[0]} $# ${*}"
        cd "${TOP_DIR:?}" || exit 1

        if [ "$#" == "1" ]; then
            local NEW_ROLE=${1}
        elif [ "${NEW_ROLE}" == "" ]; then
            local NEW_ROLE=others
        fi

        cat <<\*EOF* >"playbooks/is_package_installed.yml"
---
- name: Check to see if a package is installed
  hosts: "{{ hosts | default('localhost') }}"
  #hosts: remotes
  tasks:

  - name: Gather the packager facts
    package_facts:

  - name: Package status
    debug:
      msg: "{{ item }} {{ 'installed' if item in ansible_facts.packages else 'not installed' }}"
    loop: "{{ pkgs | default([]) }}"
*EOF*
    fi
}

function create_ansible_playbooks_for_print_all_facts() {
    if [ "$#" != "0" ] && [ "$#" != "1" ]; then
        log_e "Usage: ${FUNCNAME[0]} <NEW_ROLE>"
        log_e "${FUNCNAME[0]} $# ${*}"
    else
        log_m "${FUNCNAME[0]} $# ${*}"
        cd "${TOP_DIR:?}" || exit 1

        if [ "$#" == "1" ]; then
            local NEW_ROLE=${1}
        elif [ "${NEW_ROLE}" == "" ]; then
            local NEW_ROLE=others
        fi

        cat <<\*EOF* >"playbooks/print_all_facts.yml"
---
- name: Check to see if a package is installed
  hosts: "{{ hosts | default('localhost') }}"
  #hosts: remotes
  tasks:

    - name: Print all available facts
    ansible.builtin.debug:
        var: ansible_facts
*EOF*
    fi
}

function create_ansible_playbooks_for_new_role() {
    if [ "$#" != "0" ] && [ "$#" != "1" ]; then
        log_e "Usage: ${FUNCNAME[0]} <NEW_ROLE>"
        log_e "${FUNCNAME[0]} $# ${*}"
    else
        log_m "${FUNCNAME[0]} $# ${*}"
        cd "${TOP_DIR:?}" || exit 1

        if [ "$#" == "1" ]; then
            local NEW_ROLE=${1}
        elif [ "${NEW_ROLE}" == "" ]; then
            local NEW_ROLE=others
        fi

        local ROLE_ACTIONS="install uninstall" # install uninstall start stop status reset
        for ROLE_ACTION in ${ROLE_ACTIONS[*]}; do
            cat <<*EOF* >"playbooks/${NEW_ROLE}_${ROLE_ACTION}.yml"
---
- hosts: "{{ hosts | default('remotes') }}"
  remote_user: mos
  become: true
  roles:
    - role: roles/bootstrap
    # - role: roles/common
    # - role: roles/${NEW_ROLE}
*EOF*
        done
    fi
}

function create_ansible_playbooks_for_install_package() {
    if [ "$#" != "0" ] && [ "$#" != "1" ]; then
        log_e "Usage: ${FUNCNAME[0]} <NEW_ROLE>"
        log_e "${FUNCNAME[0]} $# ${*}"
    else
        log_m "${FUNCNAME[0]} $# ${*}"
        cd "${TOP_DIR:?}" || exit 1

        if [ "$#" == "1" ]; then
            local NEW_ROLE=${1}
        elif [ "${NEW_ROLE}" == "" ]; then
            local NEW_ROLE=others
        fi

        cat <<\*EOF* >"playbooks/install_package.yml"
---
- name: install package
    hosts: "{{ hosts | default('localhost') }}"
    zypper:
    name: "{{ pkg | default(foo) }}"
    state: present
*EOF*
    fi
}

function create_ansible_playbooks_for_remove_package() {
    if [ "$#" != "0" ] && [ "$#" != "1" ]; then
        log_e "Usage: ${FUNCNAME[0]} <NEW_ROLE>"
        log_e "${FUNCNAME[0]} $# ${*}"
    else
        log_m "${FUNCNAME[0]} $# ${*}"
        cd "${TOP_DIR:?}" || exit 1

        if [ "$#" == "1" ]; then
            local NEW_ROLE=${1}
        elif [ "${NEW_ROLE}" == "" ]; then
            local NEW_ROLE=others
        fi

        cat <<\*EOF* >"playbooks/remove_package.yml"
---
- name: remove package
    hosts: "{{ hosts | default('localhost') }}"
    zypper:
    name: "{{ pkg | default(foo) }}"
    state: absent
*EOF*
    fi
}

function create_ansible_roles() {
    if [ "$#" != "0" ] && [ "$#" != "1" ]; then
        log_e "Usage: ${FUNCNAME[0]} <NEW_ROLE>"
        log_e "${FUNCNAME[0]} $# ${*}"
    else
        log_m "${FUNCNAME[0]} $# ${*}"
        cd "${TOP_DIR:?}/roles" || exit 1

        if [ "$#" == "1" ]; then
            local NEW_ROLE=${1}
        elif [ "${NEW_ROLE}" == "" ]; then
            local NEW_ROLE=others
        fi
        echo "NEW_ROLE: ${NEW_ROLE}"

        local NEW_ROLES="bootstrap common helloworld ${NEW_ROLE}"
        echo "NEW_ROLES: ${NEW_ROLES}"
        for ROLE in ${NEW_ROLES[*]}; do
            if [ ! -e "${TOP_DIR:?}/roles/${ROLE}" ]; then
                ansible-galaxy role init ${ROLE} # --role-skeleton ${PROJECT_PATH}/ansible_template_jinja_role
                # molecule init role --role-name ${ROLE}
            fi
        done
    fi
}

function create_ansible_role_tasks_for_main() {
    if [ "$#" != "0" ] && [ "$#" != "1" ]; then
        log_e "Usage: ${FUNCNAME[0]} <NEW_ROLE>"
        log_e "${FUNCNAME[0]} $# ${*}"
    else
        log_m "${FUNCNAME[0]} $# ${*}"
        cd "${TOP_DIR:?}/roles" || exit 1

        if [ "$#" == "1" ]; then
            local NEW_ROLE=${1}
        elif [ "${NEW_ROLE}" == "" ]; then
            local NEW_ROLE=others
        fi

        for ROLE in bootstrap common helloworld ${NEW_ROLE}; do
            cat <<*EOF* >"${ROLE}/tasks/main.yml"
---
- name: include default variables
  include_vars: "../vars/main.yml"
  tags: ${ROLE}

- name: include release specific variables
  include_vars: "{{ lookup('first_found', _params) }}"
  vars:
    _params:
      files:
        - "{{ ansible_distribution | lower | replace(' ','') }}-{{ ansible_distribution_version | lower }}.yml"
        - "{{ ansible_distribution | lower | replace(' ','') }}-{{ ansible_distribution_major_version | lower }}.yml"
        - "{{ ansible_os_family | lower | replace(' ','') }}-{{ ansible_distribution_major_version | lower }}.yml"
        - "{{ ansible_distribution | lower | replace(' ','') }}.yml"
        - "{{ ansible_os_family | lower | replace(' ','') }}.yml"
      paths:
        - "../vars"
  ignore_errors: true
  tags: ${ROLE}

- name: include release specific tasks
  include_tasks: "{{ lookup('first_found', _params) }}"
  vars:
    _params:
      files:
        - "{{ ansible_distribution | lower | replace(' ','') }}-{{ ansible_distribution_version | lower }}.yml"
        - "{{ ansible_distribution | lower | replace(' ','') }}-{{ ansible_distribution_major_version | lower }}.yml"
        - "{{ ansible_os_family | lower | replace(' ','') }}-{{ ansible_distribution_major_version | lower }}.yml"
        - "{{ ansible_distribution | lower | replace(' ','') }}.yml"
        - "{{ ansible_os_family | lower | replace(' ','') }}.yml"
      paths:
        - "."
  ignore_errors: true
  tags: ${ROLE}
*EOF*
        done
    fi
}

function create_ansible_role_tasks_for_alpine() {
    if [ "$#" != "0" ] && [ "$#" != "1" ]; then
        log_e "Usage: ${FUNCNAME[0]} <NEW_ROLE>"
        log_e "${FUNCNAME[0]} $# ${*}"
    else
        log_m "${FUNCNAME[0]} $# ${*}"
        cd "${TOP_DIR:?}/roles" || exit 1

        if [ "$#" == "1" ]; then
            local NEW_ROLE=${1}
        elif [ "${NEW_ROLE}" == "" ]; then
            local NEW_ROLE=others
        fi

        for ROLE in bootstrap common helloworld ${NEW_ROLE}; do
            cat <<*EOF* >"${ROLE}/tasks/alpine.yml"
---
- name: apk update
  apk:
    update_package: yes
    upgrade_all: yes
  changed_when: false
  ignore_errors: true
  tags: ${ROLE}

- name: apk install
  apk:
    name: "{{ item.name }}"
    state: "{{ item.state }}"
  loop: "{{ _package }}"
  register: result
  until: result is succeeded
  tags: ${ROLE}

# - name: Download script
#   get_url:
#     url: "{{ item.url }}"
#     # checksum: "{{ item.checksum }}"
#     dest: "{{ item.dest }}"
#     owner: root
#     group: root
#     mode: 0755
#   loop: "{{ _install_script }}"
#   register: result
#   until: result is succeeded
#   tags: ${ROLE}

# - name: Execute script
#   shell: "{{ item.dest }}"
#   become: true
#   loop: "{{ _install_script }}"
#   register: result
#   until: result is succeeded
#   tags: ${ROLE}

# - name: Remove script
#   file:
#     path: "{{ item.dest }}"
#     state: absent
#   loop: "{{ _install_script }}"
#   register: result
#   until: result is succeeded
#   tags: ${ROLE}

# - name: Reboot a slow machine that might have lots of updates to apply
#   reboot:
#     reboot_timeout: 3600
#   tags: ${ROLE}
*EOF*
        done
    fi
}

function create_ansible_role_tasks_for_darwin() {
    if [ "$#" != "0" ] && [ "$#" != "1" ]; then
        log_e "Usage: ${FUNCNAME[0]} <NEW_ROLE>"
        log_e "${FUNCNAME[0]} $# ${*}"
    else
        log_m "${FUNCNAME[0]} $# ${*}"
        cd "${TOP_DIR:?}/roles" || exit 1

        if [ "$#" == "1" ]; then
            local NEW_ROLE=${1}
        elif [ "${NEW_ROLE}" == "" ]; then
            local NEW_ROLE=others
        fi

        for ROLE in bootstrap common helloworld ${NEW_ROLE}; do
            cat <<*EOF* >"${ROLE}/tasks/darwin.yml"
---
- name: brew update
  homebrew:
    update_package: yes
    upgrade_all: yes
  changed_when: false
  ignore_errors: true
  tags: ${ROLE}

- name: brew install
  homebrew:
    name: "{{ item.name }}"
    state: "{{ item.state }}"
  loop: "{{ _package }}"
  register: result
  until: result is succeeded
  tags: ${ROLE}

# - name: Download script
#   get_url:
#     url: "{{ item.url }}"
#     # checksum: "{{ item.checksum }}"
#     dest: "{{ item.dest }}"
#     owner: root
#     group: root
#     mode: 0755
#   loop: "{{ _install_script }}"
#   register: result
#   until: result is succeeded
#   tags: ${ROLE}

# - name: Execute script
#   shell: "{{ item.dest }}"
#   become: true
#   loop: "{{ _install_script }}"
#   register: result
#   until: result is succeeded
#   tags: ${ROLE}

# - name: Remove script
#   file:
#     path: "{{ item.dest }}"
#     state: absent
#   loop: "{{ _install_script }}"
#   register: result
#   until: result is succeeded
#   tags: ${ROLE}

# - name: Reboot a slow machine that might have lots of updates to apply
#   reboot:
#     reboot_timeout: 3600
#   tags: ${ROLE}
*EOF*
        done
    fi
}

function create_ansible_role_tasks_for_debian() {
    if [ "$#" != "0" ] && [ "$#" != "1" ]; then
        log_e "Usage: ${FUNCNAME[0]} <NEW_ROLE>"
        log_e "${FUNCNAME[0]} $# ${*}"
    else
        log_m "${FUNCNAME[0]} $# ${*}"
        cd "${TOP_DIR:?}/roles" || exit 1

        if [ "$#" == "1" ]; then
            local NEW_ROLE=${1}
        elif [ "${NEW_ROLE}" == "" ]; then
            local NEW_ROLE=others
        fi

        for ROLE in bootstrap common helloworld ${NEW_ROLE}; do
            cat <<*EOF* >"${ROLE}/tasks/debian.yml"
---
# - name: Add required modules
#   modprobe:
#     name: "{{ item.name }}"
#     state: present
#   loop:
#     "{{ _module }}"
#   tags: ${ROLE}

# - name: Setup required sysctl params
#   sysctl:
#     name: "{{ item.key }}"
#     value: "{{ item.value }}"
#     sysctl_set: yes
#     state: present
#     reload: yes
#   loop:
#     "{{ _sysctl }}"
#   tags: ${ROLE}

- name: Install packages that allow apt to be used over HTTPS
  apt:
    name: "{{ packages }}"
    state: present
    update_cache: yes
  vars:
    packages:
    - apt-transport-https
    - ca-certificates
    - curl
    - gnupg2
    - software-properties-common
  tags: ${ROLE}

# - name: copy templates
#   template:
#     dest: "{{ item.dest }}"
#     src: "{{ item.src | default('./templates' + item.dest + '.j2') }}"
#     owner: "{{ item.owner | default('root') }}"
#     group: "{{ item.group | default('root') }}"
#     mode: "{{ item.mode | default('0644') }}"
#   loop:
#     - { dest: "/etc/apt/sources.list" }
#   tags: ${ROLE}

# - name: Add signing keys
#   apt_key:
#     url: "{{ item.gpg }}"
#     state: present
#   loop: "{{ _key }}"
#   register: result
#   until: result is succeeded
#   tags: ${ROLE}

# - name: Add repositoies
#   apt_repository:
#     repo: "{{ item.repo }}"
#     state: present
#   loop: "{{ _repo }}"
#   register: result
#   until: result is succeeded
#   tags: ${ROLE}

- name: Update all packages
  apt:
    name: '*'
    state: latest
    update_cache: yes
  changed_when: false
  ignore_errors: true
  tags: ${ROLE}

- name: Install packages
  apt:
    name: "{{ item.name }}"
    state: "{{ item.state }}"
  loop: "{{ _package }}"
  register: result
  until: result is succeeded
  tags: ${ROLE}

# - name: just force systemd to reread configs
#   systemd:
#     daemon_reload: yes
#   tags: ${ROLE}

# - name: Start and enable services
#   systemd:
#     name: "{{ item.name }}"
#     state: started
#     enabled: yes
#     daemon_reload: yes
#   loop: "{{ _service }}"
#   register: result
#   until: result is succeeded
#   tags: ${ROLE}

# - name: Add /usr/local/bin to sudo secure_path
#   lineinfile:
#     line: 'Defaults    secure_path = /sbin:/bin:/usr/sbin:/usr/bin:/usr/local/bin'
#     regexp: "Defaults(\\s)*secure_path(\\s)*="
#     state: present
#     insertafter: EOF
#     path: /etc/sudoers
#     validate: 'visudo -cf %s'
#   tags: ${ROLE}

# - name: Download script
#   get_url:
#     url: "{{ item.url }}"
#     # checksum: "{{ item.checksum }}"
#     dest: "{{ item.dest }}"
#     owner: root
#     group: root
#     mode: 0755
#   loop: "{{ _install_script }}"
#   register: result
#   until: result is succeeded
#   tags: ${ROLE}

# - name: Execute script
#   shell: "{{ item.dest }}"
#   become: true
#   loop: "{{ _install_script }}"
#   register: result
#   until: result is succeeded
#   tags: ${ROLE}

# - name: Remove script
#   file:
#     path: "{{ item.dest }}"
#     state: absent
#   loop: "{{ _install_script }}"
#   register: result
#   until: result is succeeded
#   tags: ${ROLE}

# - name: Reboot a slow machine that might have lots of updates to apply
#   reboot:
#     reboot_timeout: 3600
#   tags: ${ROLE}
*EOF*
        done
    fi
}

function create_ansible_role_tasks_for_redhat() {
    if [ "$#" != "0" ] && [ "$#" != "1" ]; then
        log_e "Usage: ${FUNCNAME[0]} <NEW_ROLE>"
        log_e "${FUNCNAME[0]} $# ${*}"
    else
        log_m "${FUNCNAME[0]} $# ${*}"
        cd "${TOP_DIR:?}/roles" || exit 1

        if [ "$#" == "1" ]; then
            local NEW_ROLE=${1}
        elif [ "${NEW_ROLE}" == "" ]; then
            local NEW_ROLE=others
        fi

        for ROLE in bootstrap common helloworld ${NEW_ROLE}; do
            cat <<*EOF* >"${ROLE}/tasks/redhat.yml"
---
# - name: Add required modules
#   modprobe:
#     name: "{{ item.name }}"
#     state: present
#   loop:
#     "{{ _module }}"
#   tags: ${ROLE}

# - name: Setup required sysctl params
#   sysctl:
#     name: "{{ item.key }}"
#     value: "{{ item.value }}"
#     sysctl_set: yes
#     state: present
#     reload: yes
#   loop:
#     "{{ _sysctl }}"
#   tags: ${ROLE}

- name: yum install yum-utils
  yum:
    name: "yum-utils"
    state: "present"
  changed_when: false
  ignore_errors: true
  tags: ${ROLE}

# - name: yum-config-manager --enable
#   command: yum-config-manager --{{ item.state }} {{ item.name }}
#   loop: "{{ _repo_state_manager }}"
#   changed_when: false
#   ignore_errors: true
#   tags: ${ROLE}

# - name: yum install yum-plugin-fastestmirror
#   yum:
#     name: "yum-plugin-fastestmirror"
#     state: "present"
#   changed_when: false
#   ignore_errors: true
#   tags: ${ROLE}

# - name: Disable yum-plugin-fastestmirror
#   lineinfile:
#     path: "/etc/yum/pluginconf.d/fastestmirror.conf"
#     regexp: "^enabled="
#     line: "enabled=0"
#     state: "present"
#   changed_when: false
#   ignore_errors: true
#   tags: ${ROLE}

# - name: Add signing keys
#   rpm_key:
#     key: "{{ item.gpg }}"
#     state: present
#   loop: "{{ _key }}"
#   register: result
#   until: result is succeeded
#   tags: ${ROLE}

# - name: Add repositories
#   yum_repository:
#     name: "{{ item.name }}"
#     description: "{{ item.name }}"
#     baseurl: "{{ item.repo }}"
#     # gpgkey: http://server.com/keys/somerepo.pub
#     gpgcheck: no
#     repo_gpgcheck: no
#     # params: "{{ my_role_somerepo_params }}"
#     state: present
#     enabled: yes
#   loop: "{{ _repo }}"
#   changed_when: false
#   ignore_errors: true
#   tags: ${ROLE}

- name: Update all packages
  yum:
    name: '*'
    state: latest
    update_cache: yes
  changed_when: false
  ignore_errors: true
  tags: ${ROLE}

- name: Install packages
  yum:
    name: "{{ item.name }}"
    state: "{{ item.state }}"
    update_cache: yes
    disable_gpg_check: yes
  loop: "{{ _package }}"
  register: result
  until: result is succeeded
  tags: ${ROLE}

# - name: just force systemd to reread configs
#   systemd:
#     daemon_reload: yes
#   tags: ${ROLE}

# - name: Start and enable services
#   systemd:
#     name: "{{ item.name }}"
#     state: started
#     enabled: yes
#     daemon_reload: yes
#   loop: "{{ _service }}"
#   register: result
#   until: result is succeeded
#   tags: ${ROLE}

# - name: Add /usr/local/bin to sudo secure_path
#   lineinfile:
#     line: 'Defaults    secure_path = /sbin:/bin:/usr/sbin:/usr/bin:/usr/local/bin'
#     regexp: "Defaults(\\s)*secure_path(\\s)*="
#     state: present
#     insertafter: EOF
#     path: /etc/sudoers
#     validate: 'visudo -cf %s'
#   tags: ${ROLE}

# - name: Download script
#   get_url:
#     url: "{{ item.url }}"
#     # checksum: "{{ item.checksum }}"
#     dest: "{{ item.dest }}"
#     owner: root
#     group: root
#     mode: 0755
#   loop: "{{ _install_script }}"
#   register: result
#   until: result is succeeded
#   tags: ${ROLE}

# - name: Execute script
#   shell: "{{ item.dest }}"
#   become: true
#   loop: "{{ _install_script }}"
#   register: result
#   until: result is succeeded
#   tags: ${ROLE}

# - name: Remove script
#   file:
#     path: "{{ item.dest }}"
#     state: absent
#   loop: "{{ _install_script }}"
#   register: result
#   until: result is succeeded
#   tags: ${ROLE}

# - name: Reboot a slow machine that might have lots of updates to apply
#   reboot:
#     reboot_timeout: 3600
#   tags: ${ROLE}
*EOF*
        done
    fi
}

function create_ansible_role_tasks_for_suse() {
    if [ "$#" != "0" ] && [ "$#" != "1" ]; then
        log_e "Usage: ${FUNCNAME[0]} <NEW_ROLE>"
        log_e "${FUNCNAME[0]} $# ${*}"
    else
        log_m "${FUNCNAME[0]} $# ${*}"
        cd "${TOP_DIR:?}/roles" || exit 1

        if [ "$#" == "1" ]; then
            local NEW_ROLE=${1}
        elif [ "${NEW_ROLE}" == "" ]; then
            local NEW_ROLE=others
        fi

        for ROLE in bootstrap common helloworld ${NEW_ROLE}; do
            cat <<*EOF* >"${ROLE}/tasks/suse.yml"
---
# - name: Add required modules
#   modprobe:
#     name: "{{ item.name }}"
#     state: present
#   loop:
#     "{{ _module }}"
#   tags: ${ROLE}

# - name: Setup required sysctl params
#   sysctl:
#     name: "{{ item.key }}"
#     value: "{{ item.value }}"
#     sysctl_set: yes
#     state: present
#     reload: yes
#   loop:
#     "{{ _sysctl }}"
#   tags: ${ROLE}

# - name: Add repositories
#   zypper_repository:
#     state: present
#     repo: "{{ item.repo }}"
#   loop: "{{ _repo }}"
#   changed_when: false
#   tags: ${ROLE}

- name: Refresh repositories
  zypper_repository:
    repo: '*'
    auto_import_keys: yes
    runrefresh: yes
  tags: ${ROLE}

- name: Update all packages
  zypper:
    name: '*'
    state: latest
    update_cache: yes
  changed_when: false
  ignore_errors: true
  tags: ${ROLE}

- name: Install packages
  zypper:
    name: "{{ item.name }}"
    state: "{{ item.state }}"
    disable_gpg_check: yes
    update_cache: yes
    # extra_args: ''
  loop: "{{ _package }}"
  register: result
  until: result is succeeded
  tags: ${ROLE}

# - name: just force systemd to reread configs
#   systemd:
#     daemon_reload: yes
#   tags: ${ROLE}

# - name: Start and enable services
#   systemd:
#     name: "{{ item.name }}"
#     state: started
#     enabled: yes
#     daemon_reload: yes
#   loop: "{{ _service }}"
#   register: result
#   until: result is succeeded
#   tags: ${ROLE}

# - name: Add /usr/local/bin to sudo secure_path
#   lineinfile:
#     line: 'Defaults    secure_path = /sbin:/bin:/usr/sbin:/usr/bin:/usr/local/bin'
#     regexp: "Defaults(\\s)*secure_path(\\s)*="
#     state: present
#     insertafter: EOF
#     path: /etc/sudoers
#     validate: 'visudo -cf %s'
#   tags: ${ROLE}

# - name: Download script
#   get_url:
#     url: "{{ item.url }}"
#     # checksum: "{{ item.checksum }}"
#     dest: "{{ item.dest }}"
#     owner: root
#     group: root
#     mode: 0755
#   loop: "{{ _install_script }}"
#   register: result
#   until: result is succeeded
#   tags: ${ROLE}

# - name: Execute script
#   shell: "{{ item.dest }}"
#   become: true
#   loop: "{{ _install_script }}"
#   register: result
#   until: result is succeeded
#   tags: ${ROLE}

# - name: Remove script
#   file:
#     path: "{{ item.dest }}"
#     state: absent
#   loop: "{{ _install_script }}"
#   register: result
#   until: result is succeeded
#   tags: ${ROLE}

# - name: Reboot a slow machine that might have lots of updates to apply
#   reboot:
#     reboot_timeout: 3600
#   tags: ${ROLE}
*EOF*
        done
    fi
}

function create_ansible_role_vars_for_alpines() {
    if [ "$#" != "0" ] && [ "$#" != "1" ]; then
        log_e "Usage: ${FUNCNAME[0]} <NEW_ROLE>"
        log_e "${FUNCNAME[0]} $# ${*}"
    else
        log_m "${FUNCNAME[0]} $# ${*}"
        cd "${TOP_DIR:?}/roles" || exit 1

        if [ "$#" == "1" ]; then
            local NEW_ROLE=${1}
        elif [ "${NEW_ROLE}" == "" ]; then
            local NEW_ROLE=others
        fi

        ALPINES="alpine-3.12.3"
        for ALPINE in ${ALPINES[*]}; do
            for ROLE in bootstrap common helloworld ${NEW_ROLE}; do
                cat <<\*EOF* >"${ROLE}/vars/${ALPINE}.yml"
---
_package:
  - { state: "latest", name: "python3" }
  - { state: "latest", name: "bash" }
  - { state: "latest", name: "bash-completion" }

# _service:
#   - { enabled: "yes", state: "present",  name: "" }

# _install_script:
#   - { url: "", checksum: "", dest: ""  }

# _pkill_script:
#   - { url: "", checksum: "", dest: ""  }

# _uninstall_script:
#   - { url: "", checksum: "", dest: ""  }
*EOF*
            done
        done
    fi
}

function create_ansible_role_vars_for_darwins() {
    if [ "$#" != "0" ] && [ "$#" != "1" ]; then
        log_e "Usage: ${FUNCNAME[0]} <NEW_ROLE>"
        log_e "${FUNCNAME[0]} $# ${*}"
    else
        log_m "${FUNCNAME[0]} $# ${*}"
        cd "${TOP_DIR:?}/roles" || exit 1

        if [ "$#" == "1" ]; then
            local NEW_ROLE=${1}
        elif [ "${NEW_ROLE}" == "" ]; then
            local NEW_ROLE=others
        fi

        DARWINS="macosx-10.15.3"
        for DARWIN in ${DARWINS[*]}; do
            for ROLE in bootstrap common helloworld ${NEW_ROLE}; do
                cat <<\*EOF* >"${ROLE}/vars/${DARWIN}.yml"
---
_package:
  - { state: "latest", name: "python3" }
  - { state: "latest", name: "bash" }
  - { state: "latest", name: "bash-completion" }

# _service:
#   - { enabled: "yes", state: "present",  name: "" }

# _install_script:
#   - { url: "", checksum: "", dest: ""  }

# _pkill_script:
#   - { url: "", checksum: "", dest: ""  }

# _uninstall_script:
#   - { url: "", checksum: "", dest: ""  }
*EOF*
            done
        done
    fi
}

function create_ansible_role_vars_for_redhats() {
    if [ "$#" != "0" ] && [ "$#" != "1" ]; then
        log_e "Usage: ${FUNCNAME[0]} <NEW_ROLE>"
        log_e "${FUNCNAME[0]} $# ${*}"
    else
        log_m "${FUNCNAME[0]} $# ${*}"
        cd "${TOP_DIR:?}/roles" || exit 1

        if [ "$#" == "1" ]; then
            local NEW_ROLE=${1}
        elif [ "${NEW_ROLE}" == "" ]; then
            local NEW_ROLE=others
        fi

        REDHATS="centos-7.8 centos-8.3"
        for REDHAT in ${REDHATS[*]}; do
            for ROLE in bootstrap common helloworld ${NEW_ROLE}; do
                cat <<\*EOF* >"${ROLE}/vars/${REDHAT}.yml"
---
# _module:
#   - { name: "overlay" }
#   - { name: "br_netfilter" }

# _sysctl:
#   - { key: "net.bridge.bridge-nf-call-ip6tables", value: 1 }
#   - { key: "net.bridge.bridge-nf-call-iptables", value: 1 }
#   - { key: "net.ipv4.ip_forward", value: 1 }
#   - { key: "net.ipv6.conf.all.forwarding", value: 1 }

_repo_state_manager:
  - { state: "enable", name: "extras" }
  - { state: "enable", name: "updates" }
  - { state: "enable", name: "cr" }

# _key:
#   - { gpg: "" }

# _repo:
#   - { name: "", repo: "" }

_package:
  - { state: "latest", name: "epel-release" }
  - { state: "latest", name: "python3" }
  - { state: "latest", name: "bash" }
  - { state: "latest", name: "bash-completion" }

# _service:
#   - { enabled: "yes", state: "present",  name: "" }

# _install_script:
#   - { url: "", checksum: "", dest: ""  }

# _pkill_script:
#   - { url: "", checksum: "", dest: ""  }

# _uninstall_script:
#   - { url: "", checksum: "", dest: ""  }
*EOF*
            done
        done
    fi
}

function create_ansible_role_vars_for_debians() {
    if [ "$#" != "0" ] && [ "$#" != "1" ]; then
        log_e "Usage: ${FUNCNAME[0]} <NEW_ROLE>"
        log_e "${FUNCNAME[0]} $# ${*}"
    else
        log_m "${FUNCNAME[0]} $# ${*}"
        cd "${TOP_DIR:?}/roles" || exit 1

        if [ "$#" == "1" ]; then
            local NEW_ROLE=${1}
        elif [ "${NEW_ROLE}" == "" ]; then
            local NEW_ROLE=others
        fi

        DEBIANS="debian-10 ubuntu-18.04 ubuntu-20.04"
        for DEBIAN in ${DEBIANS[*]}; do
            for ROLE in bootstrap common helloworld ${NEW_ROLE}; do
                cat <<\*EOF* >"${ROLE}/vars/${DEBIAN}.yml"
---
# _module:
#   - { name: "overlay" }
#   - { name: "br_netfilter" }

# _sysctl:
#   - { key: "net.bridge.bridge-nf-call-ip6tables", value: 1 }
#   - { key: "net.bridge.bridge-nf-call-iptables", value: 1 }
#   - { key: "net.ipv4.ip_forward", value: 1 }
#   - { key: "net.ipv6.conf.all.forwarding", value: 1 }

# _key:
#   - { gpg: "" }

# _repo:
#   - { name: "", repo: "" }

_package:
  - { state: "latest", name: "python3" }
  - { state: "latest", name: "bash" }
  - { state: "latest", name: "bash-completion" }

# _service:
#   - { enabled: "yes", state: "present",  name: "" }

# _install_script:
#   - { url: "", checksum: "", dest: ""  }

# _pkill_script:
#   - { url: "", checksum: "", dest: ""  }

# _uninstall_script:
#   - { url: "", checksum: "", dest: ""  }
*EOF*
            done
        done
    fi
}

function create_ansible_role_vars_for_suses() {
    if [ "$#" != "0" ] && [ "$#" != "1" ]; then
        log_e "Usage: ${FUNCNAME[0]} <NEW_ROLE>"
        log_e "${FUNCNAME[0]} $# ${*}"
    else
        log_m "${FUNCNAME[0]} $# ${*}"
        cd "${TOP_DIR:?}/roles" || exit 1

        if [ "$#" == "1" ]; then
            local NEW_ROLE=${1}
        elif [ "${NEW_ROLE}" == "" ]; then
            local NEW_ROLE=others
        fi

        SUSES="opensuseleap-15.3 sles-15.3" # opensusetumbleweed-15.3
        for SUSE in ${SUSES[*]}; do
            for ROLE in bootstrap common helloworld ${NEW_ROLE}; do
                cat <<\*EOF* >"${ROLE}/vars/${SUSE}.yml"
---
# _module:
#   - { name: "overlay" }
#   - { name: "br_netfilter" }

# _sysctl:
#   - { key: "net.bridge.bridge-nf-call-ip6tables", value: 1 }
#   - { key: "net.bridge.bridge-nf-call-iptables", value: 1 }
#   - { key: "net.ipv4.ip_forward", value: 1 }
#   - { key: "net.ipv6.conf.all.forwarding", value: 1 }

# _key:
#   - { gpg: "" }

# _repo:
#   - { name: "", repo: "" }

_package:
  - { state: "latest", name: "python3" }
  - { state: "latest", name: "bash" }
  - { state: "latest", name: "bash-completion" }

# _service:
#   - { enabled: "yes", state: "present",  name: "" }

# _install_script:
#   - { url: "", checksum: "", dest: ""  }

# _pkill_script:
#   - { url: "", checksum: "", dest: ""  }

# _uninstall_script:
#   - { url: "", checksum: "", dest: ""  }
*EOF*
            done
        done
    fi
}

function create_ansible_app_project_skeleton() {
    if [ "$#" != "0" ] && [ "$#" != "1" ]; then
        log_e "Usage: ${FUNCNAME[0]} <NEW_ROLE>"
        log_e "${FUNCNAME[0]} $# ${*}"
    else
        log_m "${FUNCNAME[0]} $# ${*}"
        cd "${TOP_DIR:?}" || exit 1

        if [ "$#" == "1" ]; then
            local NEW_ROLE=${1}
        elif [ "${NEW_ROLE}" == "" ]; then
            local NEW_ROLE=others
        fi
        echo "NEW_ROLE: ${NEW_ROLE}"

        # PLATFORM=$(echo production staging mos ${PLATFORMS} | sed 's/ /,/g')
        # production,staging,mos,aws,azure,bare-metal,gcp,libvirt,openstack,vmware,vsphere
        # production,staging,mos,libvirt
        # DSITROS=$(echo lb etcd storage master worker ${DISTROS} | sed 's/ /,/g')
        # lb,etcd,storage,master,worker,alpine,cirros,centos,fedora,rhel,debian,raspios,ubuntu,rancher-os,rancker-k3os,opensuse-leap,opensuse-tumbleweed,oracle-linux,sles,macosx,microsoft
        # master,worker,alpine,cirros,centos,fedora,debian,ubuntu,rancher-os,rancker-k3os,opensuse-leap,sles
        mkdir -p inventories/{production,staging,mos,libvirt}/{group_vars,host_vars} \
            playbooks \
            roles \
            scripts
        touch requirements.txt \
            playbooks/site.yml \
            inventories/{production,staging,mos,libvirt}/hosts \
            inventories/{production,staging,mos,libvirt}/group_vars/{production,staging,mos,libvirt}.yml \
            inventories/{production,staging,mos,libvirt}/host_vars/${STACK_NAME}-{master,worker,alpine,cirros,centos,fedora,debian,ubuntu,rancher-os,rancker-k3os,opensuse-leap,sles}-{0..1}.yml

        create_ansible_bootstrap "${NEW_ROLE}"
        create_andible_inventories_for_platforms "${NEW_ROLE}"
        get_ansible_config "${NEW_ROLE}"
        create_ansible_playbooks_for_hello_world "${NEW_ROLE}"
        create_ansible_playbooks_for_hello_role "${NEW_ROLE}"
        create_ansible_playbooks_for_package_installed "${NEW_ROLE}"
        create_ansible_playbooks_for_new_role "${NEW_ROLE}"
        # create_ansible_playbooks_for_install_package "${NEW_ROLE}"
        # create_ansible_playbooks_for_remove_package "${NEW_ROLE}"
        # create_ansible_playbooks_for_print_all_facts "${NEW_ROLE}"
        create_ansible_roles "${NEW_ROLE}"
        create_ansible_role_tasks_for_main "${NEW_ROLE}"
        create_ansible_role_tasks_for_alpine "${NEW_ROLE}"
        create_ansible_role_tasks_for_darwin "${NEW_ROLE}"
        create_ansible_role_tasks_for_debian "${NEW_ROLE}"
        create_ansible_role_tasks_for_redhat "${NEW_ROLE}"
        create_ansible_role_tasks_for_suse "${NEW_ROLE}"
        create_ansible_role_vars_for_alpines "${NEW_ROLE}"
        create_ansible_role_vars_for_darwins "${NEW_ROLE}"
        create_ansible_role_vars_for_redhats "${NEW_ROLE}"
        create_ansible_role_vars_for_debians "${NEW_ROLE}"
        create_ansible_role_vars_for_suses "${NEW_ROLE}"
    fi
}

function create_bash_deployment_app_project_skeleton() {
    if [ "$#" != "0" ]; then
        log_e "Usage: ${FUNCNAME[0]} <ROLE>"
        log_e "${FUNCNAME[0]} $# ${*}"
    else
        log_m "${FUNCNAME[0]} $# ${*}"
        # cd "${TOP_DIR:?}" || exit 1
    fi
}

function create_bash_install_app_project_skeleton() {
    if [ "$#" != "0" ]; then
        log_e "Usage: ${FUNCNAME[0]} <ROLE>"
        log_e "${FUNCNAME[0]} $# ${*}"
    else
        log_m "${FUNCNAME[0]} $# ${*}"
        # cd "${TOP_DIR:?}" || exit 1
    fi
}

function create_remote_deployment_app_project_skeleton() {
    if [ "$#" != "0" ]; then
        log_e "Usage: ${FUNCNAME[0]} <ROLE>"
        log_e "${FUNCNAME[0]} $# ${*}"
    else
        log_m "${FUNCNAME[0]} $# ${*}"
        # cd "${TOP_DIR:?}" || exit 1

        # SERVICES="server client master worker helloworld"
        # rm -rf ${TOP_DIR:?}/{providers,inventories,state}
        # mkdir -p ${TOP_DIR:?}/{providers,inventories,state}/{$(echo ${PLATFORMS} | sed 's/ /,/g')}/{$(echo ${DISTROS} | sed 's/ /,/g')}/cloud-init scripts
        # touch ${TOP_DIR:?}/providers/{$(echo ${PLATFORMS} | sed 's/ /,/g')}/{$(echo ${DISTROS} | sed 's/ /,/g')}/empty.sh
        # mkdir -p ${TOP_DIR:?}/{providers,inventories,state}/{$(echo ${PLATFORMS} | sed 's/ /,/g')}/{$(echo ${DISTROS} | sed 's/ /,/g')}
        # mkdir -p ${TOP_DIR:?}/{inventories}/{$(echo ${PLATFORMS} | sed 's/ /,/g')}/{$(echo ${DISTROS} | sed 's/ /,/g')}/{{{ SERVICE }},$(echo ${SERVICES} | sed 's/ /,/g')}/{bin,rootfs}
        # mkdir -p ${TOP_DIR:?}/{inventories}/{$(echo ${PLATFORMS} | sed 's/ /,/g')}/{$(echo ${DISTROS} | sed 's/ /,/g')}/{{{ SERVICE }},$(echo ${SERVICES} | sed 's/ /,/g')}/rootfs/{etc,usr,var}
        # mkdir -p ${TOP_DIR:?}/{inventories}/{$(echo ${PLATFORMS} | sed 's/ /,/g')}/{$(echo ${DISTROS} | sed 's/ /,/g')}/{{{ SERVICE }},$(echo ${SERVICES} | sed 's/ /,/g')}/bin/{daemon,container}
    fi
}

function create_docker_app_project_skeleton() {
    if [ "$#" != "0" ]; then
        log_e "Usage: ${FUNCNAME[0]} <ROLE>"
        log_e "${FUNCNAME[0]} $# ${*}"
    else
        log_m "${FUNCNAME[0]} $# ${*}"
        # cd "${TOP_DIR:?}" || exit 1

    fi
}

function create_podman_app_project_skeleton() {
    if [ "$#" != "0" ]; then
        log_e "Usage: ${FUNCNAME[0]} <ROLE>"
        log_e "${FUNCNAME[0]} $# ${*}"
    else
        log_m "${FUNCNAME[0]} $# ${*}"
        # cd "${TOP_DIR:?}" || exit 1

    fi
}

function create_helm3_app_project_skeleton() {
    if [ "$#" != "0" ]; then
        log_e "Usage: ${FUNCNAME[0]} <ROLE>"
        log_e "${FUNCNAME[0]} $# ${*}"
    else
        log_m "${FUNCNAME[0]} $# ${*}"
        # cd "${TOP_DIR:?}" || exit 1

        # rm -rf "${PROJECT_PATH:?}/${PROJECT_NAME}"
        mkdir -p ${PROJECT_PATH:?}/${PROJECT_NAME}/{charts,manifests}
        touch ${PROJECT_PATH:?}/${PROJECT_NAME}/{cmd.sh,REAME.md}
        cd "${CHART_PATH:?}" || exit 1
        helm create ${PROJECT_NAME}
        remove_leading_trailing_spaces_comments_and_empty_lines_from_file ${CHART_PATH:?}/${PROJECT_NAME}/Chart.yaml
        ls -alh "${CHART_PATH}"
    fi
}

function create_terraform_app_project_skeleton() {
    if [ "$#" != "0" ]; then
        log_e "Usage: ${FUNCNAME[0]} <ROLE>"
        log_e "${FUNCNAME[0]} $# ${*}"
    else
        log_m "${FUNCNAME[0]} $# ${*}"
        # cd "${TOP_DIR:?}" || exit 1

        # SERVICES="server client master worker helloworld"
        # rm -rf ${TOP_DIR:?}/{providers,inventories,state}
        # mkdir -p ${TOP_DIR:?}/{providers,inventories,state}/{$(echo ${PLATFORMS} | sed 's/ /,/g')}/{$(echo ${DISTROS} | sed 's/ /,/g')}/cloud-init scripts
        # touch ${TOP_DIR:?}/providers/{$(echo ${PLATFORMS} | sed 's/ /,/g')}/{$(echo ${DISTROS} | sed 's/ /,/g')}/empty.tf
        # mkdir -p ${TOP_DIR:?}/{providers,inventories,state}/{$(echo ${PLATFORMS} | sed 's/ /,/g')}/{$(echo ${DISTROS} | sed 's/ /,/g')}
        # mkdir -p ${TOP_DIR:?}/{inventories}/{$(echo ${PLATFORMS} | sed 's/ /,/g')}/{$(echo ${DISTROS} | sed 's/ /,/g')}/{{{ SERVICE }},$(echo ${SERVICES} | sed 's/ /,/g')}/{bin,rootfs}
        # mkdir -p ${TOP_DIR:?}/{inventories}/{$(echo ${PLATFORMS} | sed 's/ /,/g')}/{$(echo ${DISTROS} | sed 's/ /,/g')}/{{{ SERVICE }},$(echo ${SERVICES} | sed 's/ /,/g')}/rootfs/{etc,usr,var}
        # mkdir -p ${TOP_DIR:?}/{inventories}/{$(echo ${PLATFORMS} | sed 's/ /,/g')}/{$(echo ${DISTROS} | sed 's/ /,/g')}/{{{ SERVICE }},$(echo ${SERVICES} | sed 's/ /,/g')}/bin/{daemon,container}
    fi
}

function create_golang_package_app() {
    if [ "$#" != "0" ] && [ "$#" != "4" ]; then
        log_e "Usage: ${FUNCNAME[0]} <GITHUB_USER> <GITHUB_PROJECT> <PACKAGE> <APP>"
        log_e "${FUNCNAME[0]} $# ${*}"
    else
        log_m "${FUNCNAME[0]} $# ${*}"
        cd "${TOP_DIR:?}" || exit 1

        if [ "$#" == "4" ]; then
            # local SRC_ROOT=${1}
            local GITHUB_USER=${1}
            local GITHUB_PROJECT=${2}
            local PACKAGE=${3}
            local APP=${4}
            # local PROJECT_NAME=${4}
            # local PROJECT_DIR="${SRC_ROOT}/${PROJECT_NAME}" # "${SRC_ROOT}/${GIT_PROVIDER}/${PROJECT_USER}/${PROJECT_NAME}"
        fi

        # mkdir -p ${PROJECT_DIR}
        # cd "${PROJECT_DIR}" || exit 1

        cat <<\*EOF* >"${TOP_DIR:?}/cmd/${PACKAGE}/${APP}/main.go"
package main

import "fmt"

func Hello() string {
    return "Hello, World!"
}

func main() {
    fmt.Println(Hello())
}
*EOF*

        cat <<\*EOF* >"${TOP_DIR:?}/cmd/${PACKAGE}/${APP}/main_test.go"
package main

import (
    "fmt"
    "testing"
)

// func TestHello(t *testing.T) {
//  got := Hello()
//  want := "Hello, World!"

//  if got != want {
//      t.Errorf("got '%s' want '%s'", got, want)
//  }
// }

func TestHello(t *testing.T) {
    tests := []struct {
        name string
        want string
    }{
        // TODO: Add test cases.
        {
            name: "test case 1",
            want: "Hello, World!",
        },
    }
    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            if got := Hello(); got != tt.want {
                t.Errorf("Hello() = %v, want %v", got, tt.want)
            }
        })
    }
}

func Test_main(t *testing.T) {
    fmt.Println("Main Test Begin!")
    // setup
    tests := []struct {
        name string
    }{
        // TODO: Add test cases.
        {"Test Case Main"},
    }
    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            main()
        })
    }
    // teardown
    fmt.Println("Main Test End!")
}
*EOF*
    fi
}

function create_golang_package_contant() {
    if [ "$#" != "0" ] && [ "$#" != "4" ]; then
        log_e "Usage: ${FUNCNAME[0]} <GITHUB_USER> <GITHUB_PROJECT> <PACKAGE> <APP>"
        log_e "${FUNCNAME[0]} $# ${*}"
    else
        log_m "${FUNCNAME[0]} $# ${*}"
        cd "${TOP_DIR:?}" || exit 1

        if [ "$#" == "4" ]; then
            # local SRC_ROOT=${1}
            local GITHUB_USER=${1}
            local GITHUB_PROJECT=${2}
            local PACKAGE=${3}
            local APP=${4}
            # local PROJECT_NAME=${4}
            # local PROJECT_DIR="${SRC_ROOT}/${PROJECT_NAME}" # "${SRC_ROOT}/${GIT_PROVIDER}/${PROJECT_USER}/${PROJECT_NAME}"
        fi

        # mkdir -p ${PROJECT_DIR}
        # cd "${PROJECT_DIR}" || exit 1

        touch ${TOP_DIR:?}/pkg/${PACKAGE}/{constants.go,development_constants.go,staging_constants.go,release_constants.go,version.go}
        echo "package ${PACKAGE}" >${TOP_DIR:?}/pkg/${PACKAGE}/constants.go
        echo "package ${PACKAGE}" >${TOP_DIR:?}/pkg/${PACKAGE}/version.go

        cat <<*EOF* >"${TOP_DIR:?}/pkg/${PACKAGE}/development_constants.go"
// +build !staging,!release

package ${PACKAGE}

const (
    BuildType = "development"
    Tags      = ""
)
*EOF*

        cat <<*EOF* >"${TOP_DIR:?}/pkg/${PACKAGE}/staging_constants.go"
// +build staging

package ${PACKAGE}

const (
    BuildType = "staging"
    Tags      = ""
)
*EOF*

        cat <<*EOF* >"${TOP_DIR:?}/pkg/${PACKAGE}/release_constants.go"
// +build release

package ${PACKAGE}

const (
    BuildType = "release"
    Tags      = ""
)
*EOF*
    fi
}

function create_golang_app_project_skeleton() {
    if [ "$#" != "0" ] && [ "$#" != "4" ]; then
        log_e "Usage: ${FUNCNAME[0]} <GITHUB_USER> <GITHUB_PROJECT> <PACKAGE> <APP>"
        log_e "${FUNCNAME[0]} $# ${*}"
    else
        log_m "${FUNCNAME[0]} $# ${*}"
        cd "${TOP_DIR:?}" || exit 1

        if [ "$#" == "4" ]; then
            # local SRC_ROOT=${1}
            local GITHUB_USER=${1}
            local GITHUB_PROJECT=${2}
            local PACKAGE=${3}
            local APP=${4}
            # local PROJECT_NAME=${4}
            # local PROJECT_DIR="${SRC_ROOT}/${PROJECT_NAME}" # "${SRC_ROOT}/${GIT_PROVIDER}/${PROJECT_USER}/${PROJECT_NAME}"
        fi

        # mkdir -p ${PROJECT_DIR}
        # cd "${PROJECT_DIR}" || exit 1

        export GO111MODULE=on
        go mod init github.com/${GITHUB_USER}/${GITHUB_PROJECT}
        go mod vendor

        mkdir -p ${TOP_DIR:?}/{api,build,cmd,internal,pkg,test} \
            ${TOP_DIR:?}/api/{pb,proto} \
            ${TOP_DIR:?}/cmd/${PACKAGE}/${APP} \
            ${TOP_DIR:?}/internal/app/${APP}/utils \
            ${TOP_DIR:?}/internal/pkg/${PACKAGE}/{utils,version} \
            ${TOP_DIR:?}/pkg/${PACKAGE}/{actions,utils}

        touch ${TOP_DIR:?}/README.md \
            ${TOP_DIR:?}/Makefile \
            ${TOP_DIR:?}/cmd/${PACKAGE}/${APP}/{main.go,main_test.go} \
            ${TOP_DIR:?}/internal/app/${APP}/utils/utilities.go \
            ${TOP_DIR:?}/internal/pkg/${PACKAGE}/utils/utilities.go \
            ${TOP_DIR:?}/internal/pkg/${PACKAGE}/version/{version.go,version_test.go} \
            ${TOP_DIR:?}/pkg/${PACKAGE}/utils/utilities.go

        create_golang_package_app "${GITHUB_USER}" "${GITHUB_PROJECT}" "${PACKAGE}" "${APP}"
        create_golang_package_contant "${GITHUB_USER}" "${GITHUB_PROJECT}" "${PACKAGE}" "${APP}"
    fi
}

function create_typescript_app_project_skeleton() {
    if [ "$#" != "0" ]; then
        log_e "Usage: ${FUNCNAME[0]} <ROLE>"
        log_e "${FUNCNAME[0]} $# ${*}"
    else
        log_m "${FUNCNAME[0]} $# ${*}"
        # cd "${TOP_DIR:?}" || exit 1

        if [ "$#" == "4" ]; then
            # local SRC_ROOT=${1}
            local GITHUB_USER=${1}
            local GITHUB_PROJECT=${2}
            local PACKAGE=${3}
            local APP=${4}
            # local PROJECT_NAME=${4}
            # local PROJECT_DIR="${SRC_ROOT}/${PROJECT_NAME}" # "${SRC_ROOT}/${GIT_PROVIDER}/${PROJECT_USER}/${PROJECT_NAME}"
        fi

        # mkdir -p ${PROJECT_DIR}
        # cd "${PROJECT_DIR}" || exit 1

    fi
}

function create_python3_app_project_skeleton() {
    if [ "$#" != "0" ]; then
        log_e "Usage: ${FUNCNAME[0]} <ROLE>"
        log_e "${FUNCNAME[0]} $# ${*}"
    else
        log_m "${FUNCNAME[0]} $# ${*}"
        # cd "${TOP_DIR:?}" || exit 1

        if [ "$#" == "4" ]; then
            # local SRC_ROOT=${1}
            local GITHUB_USER=${1}
            local GITHUB_PROJECT=${2}
            local PACKAGE=${3}
            local APP=${4}
            # local PROJECT_NAME=${4}
            # local PROJECT_DIR="${SRC_ROOT}/${PROJECT_NAME}" # "${SRC_ROOT}/${GIT_PROVIDER}/${PROJECT_USER}/${PROJECT_NAME}"
        fi

        # mkdir -p ${PROJECT_DIR}
        # cd "${PROJECT_DIR}" || exit 1

    fi
}

function create_rust_app_project_skeleton() {
    if [ "$#" != "0" ]; then
        log_e "Usage: ${FUNCNAME[0]} <ROLE>"
        log_e "${FUNCNAME[0]} $# ${*}"
    else
        log_m "${FUNCNAME[0]} $# ${*}"
        # cd "${TOP_DIR:?}" || exit 1

        if [ "$#" == "4" ]; then
            # local SRC_ROOT=${1}
            local GITHUB_USER=${1}
            local GITHUB_PROJECT=${2}
            local PACKAGE=${3}
            local APP=${4}
            # local PROJECT_NAME=${4}
            # local PROJECT_DIR="${SRC_ROOT}/${PROJECT_NAME}" # "${SRC_ROOT}/${GIT_PROVIDER}/${PROJECT_USER}/${PROJECT_NAME}"
        fi

        # mkdir -p ${PROJECT_DIR}
        # cd "${PROJECT_DIR}" || exit 1

    fi
}

#******************************************************************************
# create_project_readme_md

function create_project_readme_md() {
    if [ "$#" != "0" ] && [ "$#" != "1" ]; then
        log_e "Usage: ${FUNCNAME[0]} <PROJECT_TYPE>"
        log_e "${FUNCNAME[0]} $# ${*}"
    else
        log_m "${FUNCNAME[0]} $# ${*}"
        cd "${TOP_DIR:?}" || exit 1

        if [ "$#" == "1" ]; then
            local DISTPROJECT_TYPERO=${1}
        fi

        case ${PROJECT_TYPE} in
            ansible_app) create_ansible_app_project_readme_md ;;
            bash_app) create_bash_app_project_readme_md ;;
            bash_deployment_app) create_bash_deployment_app_project_readme_md ;;
            bash_install_app) create_bash_install_app_project_readme_md ;;
            bash_remote_deployment_app) create_bash_remote_deployment_app_project_readme_md ;;
            docker_app) create_docker_app_project_readme_md ;;
            podman_app) create_podman_app_project_readme_md ;;
            helm3_app) create_helm3_app_project_readme_md ;;
            deployment_app) create_deployment_app_project_readme_md ;;
            terraform_app) create_terraform_app_project_readme_md ;;
            golang_app) create_golang_app_project_readme_md ;;
            typescript_app) create_typescript_app_project_readme_md ;;
            python3_app) create_python3_app_project_readme_md ;;
            rust_app) create_rust_app_project_readme_md ;;
            *) ;;
        esac
    fi
}

function create_ansible_app_project_readme_md() {
    if [ "$#" != "0" ] && [ "$#" != "4" ] && [ "$#" != "5" ]; then
        log_e "Usage: ${FUNCNAME[0]} <SRC_ROOT> <GIT_PROVIDER : bitbucket.com | github.com | gitlab.com> <PROJECT_USER> <PROJECT_NAME> [<OFFICIAL_PROJECT>]"
        log_e "${FUNCNAME[0]} $# ${*}"
    else
        log_m "${FUNCNAME[0]} $# ${*}"
        # cd "${TOP_DIR:?}" || exit 1

        if [ "$#" == "4" ]; then
            local SRC_ROOT=${1}
            local GIT_PROVIDER=${2}
            local PROJECT_USER=${3}
            local PROJECT_NAME=${4}
            local PROJECT_DIR="${SRC_ROOT}/${PROJECT_NAME}" # "${SRC_ROOT}/${GIT_PROVIDER}/${PROJECT_USER}/${PROJECT_NAME}"
        elif [ "$#" == "5" ]; then
            local SRC_ROOT=${1}
            local GIT_PROVIDER=${2}
            local PROJECT_USER=${3}
            local PROJECT_NAME=${4}
            local PROJECT_DIR="${SRC_ROOT}/${PROJECT_NAME}" # "${SRC_ROOT}/${GIT_PROVIDER}/${PROJECT_USER}/${PROJECT_NAME}"
            local OFFICIAL_PROJECT=${5}
        fi

        cd "${PROJECT_DIR}" || exit 1

        #         local FILENAME=README.md
        #         cat <<\*EOF* >"${PROJECT_DIR:?}/${FILENAME}"
        # *EOF*
    fi
}

function create_bash_app_project_readme_md() {
    if [ "$#" != "0" ] && [ "$#" != "4" ] && [ "$#" != "5" ]; then
        log_e "Usage: ${FUNCNAME[0]} <SRC_ROOT> <GIT_PROVIDER : bitbucket.com | github.com | gitlab.com> <PROJECT_USER> <PROJECT_NAME> [<OFFICIAL_PROJECT>]"
        log_e "${FUNCNAME[0]} $# ${*}"
    else
        log_m "${FUNCNAME[0]} $# ${*}"
        # cd "${TOP_DIR:?}" || exit 1

        if [ "$#" == "4" ]; then
            local SRC_ROOT=${1}
            local GIT_PROVIDER=${2}
            local PROJECT_USER=${3}
            local PROJECT_NAME=${4}
            local PROJECT_DIR="${SRC_ROOT}/${PROJECT_NAME}" # "${SRC_ROOT}/${GIT_PROVIDER}/${PROJECT_USER}/${PROJECT_NAME}"
        elif [ "$#" == "5" ]; then
            local SRC_ROOT=${1}
            local GIT_PROVIDER=${2}
            local PROJECT_USER=${3}
            local PROJECT_NAME=${4}
            local PROJECT_DIR="${SRC_ROOT}/${PROJECT_NAME}" # "${SRC_ROOT}/${GIT_PROVIDER}/${PROJECT_USER}/${PROJECT_NAME}"
            local OFFICIAL_PROJECT=${5}
        fi

        cd "${PROJECT_DIR}" || exit 1

        #         local FILENAME=README.md
        #         cat <<\*EOF* >"${PROJECT_DIR:?}/${FILENAME}"
        # *EOF*
    fi
}

function create_bash_deployment_app_project_readme_md() {
    if [ "$#" != "0" ] && [ "$#" != "4" ] && [ "$#" != "5" ]; then
        log_e "Usage: ${FUNCNAME[0]} <SRC_ROOT> <GIT_PROVIDER : bitbucket.com | github.com | gitlab.com> <PROJECT_USER> <PROJECT_NAME> [<OFFICIAL_PROJECT>]"
        log_e "${FUNCNAME[0]} $# ${*}"
    else
        log_m "${FUNCNAME[0]} $# ${*}"
        # cd "${TOP_DIR:?}" || exit 1

        if [ "$#" == "4" ]; then
            local SRC_ROOT=${1}
            local GIT_PROVIDER=${2}
            local PROJECT_USER=${3}
            local PROJECT_NAME=${4}
            local PROJECT_DIR="${SRC_ROOT}/${PROJECT_NAME}" # "${SRC_ROOT}/${GIT_PROVIDER}/${PROJECT_USER}/${PROJECT_NAME}"
        elif [ "$#" == "5" ]; then
            local SRC_ROOT=${1}
            local GIT_PROVIDER=${2}
            local PROJECT_USER=${3}
            local PROJECT_NAME=${4}
            local PROJECT_DIR="${SRC_ROOT}/${PROJECT_NAME}" # "${SRC_ROOT}/${GIT_PROVIDER}/${PROJECT_USER}/${PROJECT_NAME}"
            local OFFICIAL_PROJECT=${5}
        fi

        cd "${PROJECT_DIR}" || exit 1

        #         local FILENAME=README.md
        #         cat <<\*EOF* >"${PROJECT_DIR:?}/${FILENAME}"
        # *EOF*
    fi
}

function create_bash_install_app_project_readme_md() {
    if [ "$#" != "0" ] && [ "$#" != "4" ] && [ "$#" != "5" ]; then
        log_e "Usage: ${FUNCNAME[0]} <SRC_ROOT> <GIT_PROVIDER : bitbucket.com | github.com | gitlab.com> <PROJECT_USER> <PROJECT_NAME> [<OFFICIAL_PROJECT>]"
        log_e "${FUNCNAME[0]} $# ${*}"
    else
        log_m "${FUNCNAME[0]} $# ${*}"
        # cd "${TOP_DIR:?}" || exit 1

        if [ "$#" == "4" ]; then
            local SRC_ROOT=${1}
            local GIT_PROVIDER=${2}
            local PROJECT_USER=${3}
            local PROJECT_NAME=${4}
            local PROJECT_DIR="${SRC_ROOT}/${PROJECT_NAME}" # "${SRC_ROOT}/${GIT_PROVIDER}/${PROJECT_USER}/${PROJECT_NAME}"
        elif [ "$#" == "5" ]; then
            local SRC_ROOT=${1}
            local GIT_PROVIDER=${2}
            local PROJECT_USER=${3}
            local PROJECT_NAME=${4}
            local PROJECT_DIR="${SRC_ROOT}/${PROJECT_NAME}" # "${SRC_ROOT}/${GIT_PROVIDER}/${PROJECT_USER}/${PROJECT_NAME}"
            local OFFICIAL_PROJECT=${5}
        fi

        cd "${PROJECT_DIR}" || exit 1

        #         local FILENAME=README.md
        #         cat <<\*EOF* >"${PROJECT_DIR:?}/${FILENAME}"
        # *EOF*
    fi
}

function create_bash_remote_deployment_app_project_readme_md() {
    if [ "$#" != "0" ] && [ "$#" != "4" ] && [ "$#" != "5" ]; then
        log_e "Usage: ${FUNCNAME[0]} <SRC_ROOT> <GIT_PROVIDER : bitbucket.com | github.com | gitlab.com> <PROJECT_USER> <PROJECT_NAME> [<OFFICIAL_PROJECT>]"
        log_e "${FUNCNAME[0]} $# ${*}"
    else
        log_m "${FUNCNAME[0]} $# ${*}"
        # cd "${TOP_DIR:?}" || exit 1

        if [ "$#" == "4" ]; then
            local SRC_ROOT=${1}
            local GIT_PROVIDER=${2}
            local PROJECT_USER=${3}
            local PROJECT_NAME=${4}
            local PROJECT_DIR="${SRC_ROOT}/${PROJECT_NAME}" # "${SRC_ROOT}/${GIT_PROVIDER}/${PROJECT_USER}/${PROJECT_NAME}"
        elif [ "$#" == "5" ]; then
            local SRC_ROOT=${1}
            local GIT_PROVIDER=${2}
            local PROJECT_USER=${3}
            local PROJECT_NAME=${4}
            local PROJECT_DIR="${SRC_ROOT}/${PROJECT_NAME}" # "${SRC_ROOT}/${GIT_PROVIDER}/${PROJECT_USER}/${PROJECT_NAME}"
            local OFFICIAL_PROJECT=${5}
        fi

        cd "${PROJECT_DIR}" || exit 1

        #         local FILENAME=README.md
        #         cat <<\*EOF* >"${PROJECT_DIR:?}/${FILENAME}"
        # *EOF*
    fi
}

function create_docker_app_project_readme_md() {
    if [ "$#" != "0" ] && [ "$#" != "4" ] && [ "$#" != "5" ]; then
        log_e "Usage: ${FUNCNAME[0]} <SRC_ROOT> <GIT_PROVIDER : bitbucket.com | github.com | gitlab.com> <PROJECT_USER> <PROJECT_NAME> [<OFFICIAL_PROJECT>]"
        log_e "${FUNCNAME[0]} $# ${*}"
    else
        log_m "${FUNCNAME[0]} $# ${*}"
        # cd "${TOP_DIR:?}" || exit 1

        if [ "$#" == "4" ]; then
            local SRC_ROOT=${1}
            local GIT_PROVIDER=${2}
            local PROJECT_USER=${3}
            local PROJECT_NAME=${4}
            local PROJECT_DIR="${SRC_ROOT}/${PROJECT_NAME}" # "${SRC_ROOT}/${GIT_PROVIDER}/${PROJECT_USER}/${PROJECT_NAME}"
        elif [ "$#" == "5" ]; then
            local SRC_ROOT=${1}
            local GIT_PROVIDER=${2}
            local PROJECT_USER=${3}
            local PROJECT_NAME=${4}
            local PROJECT_DIR="${SRC_ROOT}/${PROJECT_NAME}" # "${SRC_ROOT}/${GIT_PROVIDER}/${PROJECT_USER}/${PROJECT_NAME}"
            local OFFICIAL_PROJECT=${5}
        fi

        cd "${PROJECT_DIR}" || exit 1

        #         local FILENAME=README.md
        #         cat <<\*EOF* >"${PROJECT_DIR:?}/${FILENAME}"
        # *EOF*
    fi
}

function create_podman_app_project_readme_md() {
    if [ "$#" != "0" ] && [ "$#" != "4" ] && [ "$#" != "5" ]; then
        log_e "Usage: ${FUNCNAME[0]} <SRC_ROOT> <GIT_PROVIDER : bitbucket.com | github.com | gitlab.com> <PROJECT_USER> <PROJECT_NAME> [<OFFICIAL_PROJECT>]"
        log_e "${FUNCNAME[0]} $# ${*}"
    else
        log_m "${FUNCNAME[0]} $# ${*}"
        # cd "${TOP_DIR:?}" || exit 1

        if [ "$#" == "4" ]; then
            local SRC_ROOT=${1}
            local GIT_PROVIDER=${2}
            local PROJECT_USER=${3}
            local PROJECT_NAME=${4}
            local PROJECT_DIR="${SRC_ROOT}/${PROJECT_NAME}" # "${SRC_ROOT}/${GIT_PROVIDER}/${PROJECT_USER}/${PROJECT_NAME}"
        elif [ "$#" == "5" ]; then
            local SRC_ROOT=${1}
            local GIT_PROVIDER=${2}
            local PROJECT_USER=${3}
            local PROJECT_NAME=${4}
            local PROJECT_DIR="${SRC_ROOT}/${PROJECT_NAME}" # "${SRC_ROOT}/${GIT_PROVIDER}/${PROJECT_USER}/${PROJECT_NAME}"
            local OFFICIAL_PROJECT=${5}
        fi

        cd "${PROJECT_DIR}" || exit 1

        #         local FILENAME=README.md
        #         cat <<\*EOF* >"${PROJECT_DIR:?}/${FILENAME}"
        # *EOF*
    fi
}

function create_helm3_app_project_readme_md() {
    if [ "$#" != "0" ] && [ "$#" != "4" ] && [ "$#" != "5" ]; then
        log_e "Usage: ${FUNCNAME[0]} <SRC_ROOT> <GIT_PROVIDER : bitbucket.com | github.com | gitlab.com> <PROJECT_USER> <PROJECT_NAME> [<OFFICIAL_PROJECT>]"
        log_e "${FUNCNAME[0]} $# ${*}"
    else
        log_m "${FUNCNAME[0]} $# ${*}"
        # cd "${TOP_DIR:?}" || exit 1

        if [ "$#" == "4" ]; then
            local SRC_ROOT=${1}
            local GIT_PROVIDER=${2}
            local PROJECT_USER=${3}
            local PROJECT_NAME=${4}
            local PROJECT_DIR="${SRC_ROOT}/${PROJECT_NAME}" # "${SRC_ROOT}/${GIT_PROVIDER}/${PROJECT_USER}/${PROJECT_NAME}"
        elif [ "$#" == "5" ]; then
            local SRC_ROOT=${1}
            local GIT_PROVIDER=${2}
            local PROJECT_USER=${3}
            local PROJECT_NAME=${4}
            local PROJECT_DIR="${SRC_ROOT}/${PROJECT_NAME}" # "${SRC_ROOT}/${GIT_PROVIDER}/${PROJECT_USER}/${PROJECT_NAME}"
            local OFFICIAL_PROJECT=${5}
        fi

        cd "${PROJECT_DIR}" || exit 1

        #         local FILENAME=README.md
        #         cat <<\*EOF* >"${PROJECT_DIR:?}/${FILENAME}"
        # *EOF*
    fi
}

function create_deployment_app_project_readme_md() {
    if [ "$#" != "0" ] && [ "$#" != "4" ] && [ "$#" != "5" ]; then
        log_e "Usage: ${FUNCNAME[0]} <SRC_ROOT> <GIT_PROVIDER : bitbucket.com | github.com | gitlab.com> <PROJECT_USER> <PROJECT_NAME> [<OFFICIAL_PROJECT>]"
        log_e "${FUNCNAME[0]} $# ${*}"
    else
        log_m "${FUNCNAME[0]} $# ${*}"
        # cd "${TOP_DIR:?}" || exit 1

        if [ "$#" == "4" ]; then
            local SRC_ROOT=${1}
            local GIT_PROVIDER=${2}
            local PROJECT_USER=${3}
            local PROJECT_NAME=${4}
            local PROJECT_DIR="${SRC_ROOT}/${PROJECT_NAME}" # "${SRC_ROOT}/${GIT_PROVIDER}/${PROJECT_USER}/${PROJECT_NAME}"
        elif [ "$#" == "5" ]; then
            local SRC_ROOT=${1}
            local GIT_PROVIDER=${2}
            local PROJECT_USER=${3}
            local PROJECT_NAME=${4}
            local PROJECT_DIR="${SRC_ROOT}/${PROJECT_NAME}" # "${SRC_ROOT}/${GIT_PROVIDER}/${PROJECT_USER}/${PROJECT_NAME}"
            local OFFICIAL_PROJECT=${5}
        fi

        cd "${PROJECT_DIR}" || exit 1

        #         local FILENAME=README.md
        #         cat <<\*EOF* >"${PROJECT_DIR:?}/${FILENAME}"
        # *EOF*
    fi
}

function create_terraform_app_project_readme_md() {
    if [ "$#" != "0" ] && [ "$#" != "4" ] && [ "$#" != "5" ]; then
        log_e "Usage: ${FUNCNAME[0]} <SRC_ROOT> <GIT_PROVIDER : bitbucket.com | github.com | gitlab.com> <PROJECT_USER> <PROJECT_NAME> [<OFFICIAL_PROJECT>]"
        log_e "${FUNCNAME[0]} $# ${*}"
    else
        log_m "${FUNCNAME[0]} $# ${*}"
        # cd "${TOP_DIR:?}" || exit 1

        if [ "$#" == "4" ]; then
            local SRC_ROOT=${1}
            local GIT_PROVIDER=${2}
            local PROJECT_USER=${3}
            local PROJECT_NAME=${4}
            local PROJECT_DIR="${SRC_ROOT}/${PROJECT_NAME}" # "${SRC_ROOT}/${GIT_PROVIDER}/${PROJECT_USER}/${PROJECT_NAME}"
        elif [ "$#" == "5" ]; then
            local SRC_ROOT=${1}
            local GIT_PROVIDER=${2}
            local PROJECT_USER=${3}
            local PROJECT_NAME=${4}
            local PROJECT_DIR="${SRC_ROOT}/${PROJECT_NAME}" # "${SRC_ROOT}/${GIT_PROVIDER}/${PROJECT_USER}/${PROJECT_NAME}"
            local OFFICIAL_PROJECT=${5}
        fi

        cd "${PROJECT_DIR}" || exit 1

        #         local FILENAME=README.md
        #         cat <<\*EOF* >"${PROJECT_DIR:?}/${FILENAME}"
        # *EOF*
    fi
}

function create_golang_app_project_readme_md() {
    if [ "$#" != "0" ] && [ "$#" != "4" ] && [ "$#" != "5" ]; then
        log_e "Usage: ${FUNCNAME[0]} <SRC_ROOT> <GIT_PROVIDER : bitbucket.com | github.com | gitlab.com> <PROJECT_USER> <PROJECT_NAME> [<OFFICIAL_PROJECT>]"
        log_e "${FUNCNAME[0]} $# ${*}"
    else
        log_m "${FUNCNAME[0]} $# ${*}"
        # cd "${TOP_DIR:?}" || exit 1

        if [ "$#" == "4" ]; then
            local SRC_ROOT=${1}
            local GIT_PROVIDER=${2}
            local PROJECT_USER=${3}
            local PROJECT_NAME=${4}
            local PROJECT_DIR="${SRC_ROOT}/${PROJECT_NAME}" # "${SRC_ROOT}/${GIT_PROVIDER}/${PROJECT_USER}/${PROJECT_NAME}"
        elif [ "$#" == "5" ]; then
            local SRC_ROOT=${1}
            local GIT_PROVIDER=${2}
            local PROJECT_USER=${3}
            local PROJECT_NAME=${4}
            local PROJECT_DIR="${SRC_ROOT}/${PROJECT_NAME}" # "${SRC_ROOT}/${GIT_PROVIDER}/${PROJECT_USER}/${PROJECT_NAME}"
            local OFFICIAL_PROJECT=${5}
        fi

        cd "${PROJECT_DIR}" || exit 1

        #         local FILENAME=README.md
        #         cat <<\*EOF* >"${PROJECT_DIR:?}/${FILENAME}"
        # *EOF*
    fi
}

function create_typescript_app_project_readme_md() {
    if [ "$#" != "0" ] && [ "$#" != "4" ] && [ "$#" != "5" ]; then
        log_e "Usage: ${FUNCNAME[0]} <SRC_ROOT> <GIT_PROVIDER : bitbucket.com | github.com | gitlab.com> <PROJECT_USER> <PROJECT_NAME> [<OFFICIAL_PROJECT>]"
        log_e "${FUNCNAME[0]} $# ${*}"
    else
        log_m "${FUNCNAME[0]} $# ${*}"
        # cd "${TOP_DIR:?}" || exit 1

        if [ "$#" == "4" ]; then
            local SRC_ROOT=${1}
            local GIT_PROVIDER=${2}
            local PROJECT_USER=${3}
            local PROJECT_NAME=${4}
            local PROJECT_DIR="${SRC_ROOT}/${PROJECT_NAME}" # "${SRC_ROOT}/${GIT_PROVIDER}/${PROJECT_USER}/${PROJECT_NAME}"
        elif [ "$#" == "5" ]; then
            local SRC_ROOT=${1}
            local GIT_PROVIDER=${2}
            local PROJECT_USER=${3}
            local PROJECT_NAME=${4}
            local PROJECT_DIR="${SRC_ROOT}/${PROJECT_NAME}" # "${SRC_ROOT}/${GIT_PROVIDER}/${PROJECT_USER}/${PROJECT_NAME}"
            local OFFICIAL_PROJECT=${5}
        fi

        cd "${PROJECT_DIR}" || exit 1

        #         local FILENAME=README.md
        #         cat <<\*EOF* >"${PROJECT_DIR:?}/${FILENAME}"
        # *EOF*
    fi
}

function create_python3_app_project_readme_md() {
    if [ "$#" != "0" ] && [ "$#" != "4" ] && [ "$#" != "5" ]; then
        log_e "Usage: ${FUNCNAME[0]} <SRC_ROOT> <GIT_PROVIDER : bitbucket.com | github.com | gitlab.com> <PROJECT_USER> <PROJECT_NAME> [<OFFICIAL_PROJECT>]"
        log_e "${FUNCNAME[0]} $# ${*}"
    else
        log_m "${FUNCNAME[0]} $# ${*}"
        # cd "${TOP_DIR:?}" || exit 1

        if [ "$#" == "4" ]; then
            local SRC_ROOT=${1}
            local GIT_PROVIDER=${2}
            local PROJECT_USER=${3}
            local PROJECT_NAME=${4}
            local PROJECT_DIR="${SRC_ROOT}/${PROJECT_NAME}" # "${SRC_ROOT}/${GIT_PROVIDER}/${PROJECT_USER}/${PROJECT_NAME}"
        elif [ "$#" == "5" ]; then
            local SRC_ROOT=${1}
            local GIT_PROVIDER=${2}
            local PROJECT_USER=${3}
            local PROJECT_NAME=${4}
            local PROJECT_DIR="${SRC_ROOT}/${PROJECT_NAME}" # "${SRC_ROOT}/${GIT_PROVIDER}/${PROJECT_USER}/${PROJECT_NAME}"
            local OFFICIAL_PROJECT=${5}
        fi

        cd "${PROJECT_DIR}" || exit 1

        #         local FILENAME=README.md
        #         cat <<\*EOF* >"${PROJECT_DIR:?}/${FILENAME}"
        # *EOF*
    fi
}

function create_rust_app_project_readme_md() {
    if [ "$#" != "0" ] && [ "$#" != "4" ] && [ "$#" != "5" ]; then
        log_e "Usage: ${FUNCNAME[0]} <SRC_ROOT> <GIT_PROVIDER : bitbucket.com | github.com | gitlab.com> <PROJECT_USER> <PROJECT_NAME> [<OFFICIAL_PROJECT>]"
        log_e "${FUNCNAME[0]} $# ${*}"
    else
        log_m "${FUNCNAME[0]} $# ${*}"
        # cd "${TOP_DIR:?}" || exit 1

        if [ "$#" == "4" ]; then
            local SRC_ROOT=${1}
            local GIT_PROVIDER=${2}
            local PROJECT_USER=${3}
            local PROJECT_NAME=${4}
            local PROJECT_DIR="${SRC_ROOT}/${PROJECT_NAME}" # "${SRC_ROOT}/${GIT_PROVIDER}/${PROJECT_USER}/${PROJECT_NAME}"
        elif [ "$#" == "5" ]; then
            local SRC_ROOT=${1}
            local GIT_PROVIDER=${2}
            local PROJECT_USER=${3}
            local PROJECT_NAME=${4}
            local PROJECT_DIR="${SRC_ROOT}/${PROJECT_NAME}" # "${SRC_ROOT}/${GIT_PROVIDER}/${PROJECT_USER}/${PROJECT_NAME}"
            local OFFICIAL_PROJECT=${5}
        fi

        cd "${PROJECT_DIR}" || exit 1

        #         local FILENAME=README.md
        #         cat <<\*EOF* >"${PROJECT_DIR:?}/${FILENAME}"
        # *EOF*
    fi
}

#******************************************************************************
# create_project_cmd_sh

function create_project_cmd_sh() {
    if [ "$#" != "0" ] && [ "$#" != "1" ]; then
        log_e "Usage: ${FUNCNAME[0]} <PROJECT_TYPE>"
        log_e "${FUNCNAME[0]} $# ${*}"
    else
        log_m "${FUNCNAME[0]} $# ${*}"
        cd "${TOP_DIR:?}" || exit 1

        if [ "$#" == "1" ]; then
            local DISTPROJECT_TYPERO=${1}
        fi

        case ${PROJECT_TYPE} in
            ansible_app) create_ansible_app_project_cmd_sh ;;
            bash_app) create_bash_app_project_cmd_sh ;;
            bash_deployment_app) create_bash_deployment_app_project_cmd_sh ;;
            bash_install_app) create_bash_install_app_project_cmd_sh ;;
            bash_remote_deployment_app) create_bash_remote_deployment_app_project_cmd_sh ;;
            docker_app) create_docker_app_project_cmd_sh ;;
            podman_app) create_podman_app_project_cmd_sh ;;
            helm3_app) create_helm3_app_project_cmd_sh ;;
            deployment_app) create_deployment_app_project_cmd_sh ;;
            terraform_app) create_terraform_app_project_cmd_sh ;;
            golang_app) create_golang_app_project_cmd_sh ;;
            typescript_app) create_typescript_app_project_cmd_sh ;;
            python3_app) create_python3_app_project_cmd_sh ;;
            rust_app) create_rust_app_project_cmd_sh ;;
            *) ;;
        esac
    fi
}

function create_ansible_app_project_cmd_sh() {
    if [ "$#" != "0" ] && [ "$#" != "4" ] && [ "$#" != "5" ]; then
        log_e "Usage: ${FUNCNAME[0]} <SRC_ROOT> <GIT_PROVIDER : bitbucket.com | github.com | gitlab.com> <PROJECT_USER> <PROJECT_NAME> [<OFFICIAL_PROJECT>]"
        log_e "${FUNCNAME[0]} $# ${*}"
    else
        log_m "${FUNCNAME[0]} $# ${*}"
        # cd "${TOP_DIR:?}" || exit 1

        if [ "$#" == "4" ]; then
            local SRC_ROOT=${1}
            local GIT_PROVIDER=${2}
            local PROJECT_USER=${3}
            local PROJECT_NAME=${4}
            local PROJECT_DIR="${SRC_ROOT}/${PROJECT_NAME}" # "${SRC_ROOT}/${GIT_PROVIDER}/${PROJECT_USER}/${PROJECT_NAME}"
        elif [ "$#" == "5" ]; then
            local SRC_ROOT=${1}
            local GIT_PROVIDER=${2}
            local PROJECT_USER=${3}
            local PROJECT_NAME=${4}
            local PROJECT_DIR="${SRC_ROOT}/${PROJECT_NAME}" # "${SRC_ROOT}/${GIT_PROVIDER}/${PROJECT_USER}/${PROJECT_NAME}"
            local OFFICIAL_PROJECT=${5}
        fi

        cd "${PROJECT_DIR}" || exit 1

        #         local FILENAME=cmd.sh
        #         cat <<\*EOF* >"${PROJECT_DIR:?}/${FILENAME}"
        # *EOF*
    fi
}

function create_bash_app_project_cmd_sh() {
    if [ "$#" != "0" ] && [ "$#" != "4" ] && [ "$#" != "5" ]; then
        log_e "Usage: ${FUNCNAME[0]} <SRC_ROOT> <GIT_PROVIDER : bitbucket.com | github.com | gitlab.com> <PROJECT_USER> <PROJECT_NAME> [<OFFICIAL_PROJECT>]"
        log_e "${FUNCNAME[0]} $# ${*}"
    else
        log_m "${FUNCNAME[0]} $# ${*}"
        # cd "${TOP_DIR:?}" || exit 1

        if [ "$#" == "4" ]; then
            local SRC_ROOT=${1}
            local GIT_PROVIDER=${2}
            local PROJECT_USER=${3}
            local PROJECT_NAME=${4}
            local PROJECT_DIR="${SRC_ROOT}/${PROJECT_NAME}" # "${SRC_ROOT}/${GIT_PROVIDER}/${PROJECT_USER}/${PROJECT_NAME}"
        elif [ "$#" == "5" ]; then
            local SRC_ROOT=${1}
            local GIT_PROVIDER=${2}
            local PROJECT_USER=${3}
            local PROJECT_NAME=${4}
            local PROJECT_DIR="${SRC_ROOT}/${PROJECT_NAME}" # "${SRC_ROOT}/${GIT_PROVIDER}/${PROJECT_USER}/${PROJECT_NAME}"
            local OFFICIAL_PROJECT=${5}
        fi

        cd "${PROJECT_DIR}" || exit 1

        #         local FILENAME=cmd.sh
        #         cat <<\*EOF* >"${PROJECT_DIR:?}/${FILENAME}"
        # *EOF*
    fi
}

function create_bash_deployment_app_project_cmd_sh() {
    if [ "$#" != "0" ] && [ "$#" != "4" ] && [ "$#" != "5" ]; then
        log_e "Usage: ${FUNCNAME[0]} <SRC_ROOT> <GIT_PROVIDER : bitbucket.com | github.com | gitlab.com> <PROJECT_USER> <PROJECT_NAME> [<OFFICIAL_PROJECT>]"
        log_e "${FUNCNAME[0]} $# ${*}"
    else
        log_m "${FUNCNAME[0]} $# ${*}"
        # cd "${TOP_DIR:?}" || exit 1

        if [ "$#" == "4" ]; then
            local SRC_ROOT=${1}
            local GIT_PROVIDER=${2}
            local PROJECT_USER=${3}
            local PROJECT_NAME=${4}
            local PROJECT_DIR="${SRC_ROOT}/${PROJECT_NAME}" # "${SRC_ROOT}/${GIT_PROVIDER}/${PROJECT_USER}/${PROJECT_NAME}"
        elif [ "$#" == "5" ]; then
            local SRC_ROOT=${1}
            local GIT_PROVIDER=${2}
            local PROJECT_USER=${3}
            local PROJECT_NAME=${4}
            local PROJECT_DIR="${SRC_ROOT}/${PROJECT_NAME}" # "${SRC_ROOT}/${GIT_PROVIDER}/${PROJECT_USER}/${PROJECT_NAME}"
            local OFFICIAL_PROJECT=${5}
        fi

        cd "${PROJECT_DIR}" || exit 1

        #         local FILENAME=cmd.sh
        #         cat <<\*EOF* >"${PROJECT_DIR:?}/${FILENAME}"
        # *EOF*
    fi
}

function create_bash_install_app_project_cmd_sh() {
    if [ "$#" != "0" ] && [ "$#" != "4" ] && [ "$#" != "5" ]; then
        log_e "Usage: ${FUNCNAME[0]} <SRC_ROOT> <GIT_PROVIDER : bitbucket.com | github.com | gitlab.com> <PROJECT_USER> <PROJECT_NAME> [<OFFICIAL_PROJECT>]"
        log_e "${FUNCNAME[0]} $# ${*}"
    else
        log_m "${FUNCNAME[0]} $# ${*}"
        # cd "${TOP_DIR:?}" || exit 1

        if [ "$#" == "4" ]; then
            local SRC_ROOT=${1}
            local GIT_PROVIDER=${2}
            local PROJECT_USER=${3}
            local PROJECT_NAME=${4}
            local PROJECT_DIR="${SRC_ROOT}/${PROJECT_NAME}" # "${SRC_ROOT}/${GIT_PROVIDER}/${PROJECT_USER}/${PROJECT_NAME}"
        elif [ "$#" == "5" ]; then
            local SRC_ROOT=${1}
            local GIT_PROVIDER=${2}
            local PROJECT_USER=${3}
            local PROJECT_NAME=${4}
            local PROJECT_DIR="${SRC_ROOT}/${PROJECT_NAME}" # "${SRC_ROOT}/${GIT_PROVIDER}/${PROJECT_USER}/${PROJECT_NAME}"
            local OFFICIAL_PROJECT=${5}
        fi

        cd "${PROJECT_DIR}" || exit 1

        #         local FILENAME=cmd.sh
        #         cat <<\*EOF* >"${PROJECT_DIR:?}/${FILENAME}"
        # *EOF*
    fi
}

function create_bash_remote_deployment_app_project_cmd_sh() {
    if [ "$#" != "0" ] && [ "$#" != "4" ] && [ "$#" != "5" ]; then
        log_e "Usage: ${FUNCNAME[0]} <SRC_ROOT> <GIT_PROVIDER : bitbucket.com | github.com | gitlab.com> <PROJECT_USER> <PROJECT_NAME> [<OFFICIAL_PROJECT>]"
        log_e "${FUNCNAME[0]} $# ${*}"
    else
        log_m "${FUNCNAME[0]} $# ${*}"
        # cd "${TOP_DIR:?}" || exit 1

        if [ "$#" == "4" ]; then
            local SRC_ROOT=${1}
            local GIT_PROVIDER=${2}
            local PROJECT_USER=${3}
            local PROJECT_NAME=${4}
            local PROJECT_DIR="${SRC_ROOT}/${PROJECT_NAME}" # "${SRC_ROOT}/${GIT_PROVIDER}/${PROJECT_USER}/${PROJECT_NAME}"
        elif [ "$#" == "5" ]; then
            local SRC_ROOT=${1}
            local GIT_PROVIDER=${2}
            local PROJECT_USER=${3}
            local PROJECT_NAME=${4}
            local PROJECT_DIR="${SRC_ROOT}/${PROJECT_NAME}" # "${SRC_ROOT}/${GIT_PROVIDER}/${PROJECT_USER}/${PROJECT_NAME}"
            local OFFICIAL_PROJECT=${5}
        fi

        cd "${PROJECT_DIR}" || exit 1

        #         local FILENAME=cmd.sh
        #         cat <<\*EOF* >"${PROJECT_DIR:?}/${FILENAME}"
        # *EOF*
    fi
}

function create_docker_app_project_cmd_sh() {
    if [ "$#" != "0" ] && [ "$#" != "4" ] && [ "$#" != "5" ]; then
        log_e "Usage: ${FUNCNAME[0]} <SRC_ROOT> <GIT_PROVIDER : bitbucket.com | github.com | gitlab.com> <PROJECT_USER> <PROJECT_NAME> [<OFFICIAL_PROJECT>]"
        log_e "${FUNCNAME[0]} $# ${*}"
    else
        log_m "${FUNCNAME[0]} $# ${*}"
        # cd "${TOP_DIR:?}" || exit 1

        if [ "$#" == "4" ]; then
            local SRC_ROOT=${1}
            local GIT_PROVIDER=${2}
            local PROJECT_USER=${3}
            local PROJECT_NAME=${4}
            local PROJECT_DIR="${SRC_ROOT}/${PROJECT_NAME}" # "${SRC_ROOT}/${GIT_PROVIDER}/${PROJECT_USER}/${PROJECT_NAME}"
        elif [ "$#" == "5" ]; then
            local SRC_ROOT=${1}
            local GIT_PROVIDER=${2}
            local PROJECT_USER=${3}
            local PROJECT_NAME=${4}
            local PROJECT_DIR="${SRC_ROOT}/${PROJECT_NAME}" # "${SRC_ROOT}/${GIT_PROVIDER}/${PROJECT_USER}/${PROJECT_NAME}"
            local OFFICIAL_PROJECT=${5}
        fi

        cd "${PROJECT_DIR}" || exit 1

        #         local FILENAME=cmd.sh
        #         cat <<\*EOF* >"${PROJECT_DIR:?}/${FILENAME}"
        # *EOF*
    fi
}

function create_podman_app_project_cmd_sh() {
    if [ "$#" != "0" ] && [ "$#" != "4" ] && [ "$#" != "5" ]; then
        log_e "Usage: ${FUNCNAME[0]} <SRC_ROOT> <GIT_PROVIDER : bitbucket.com | github.com | gitlab.com> <PROJECT_USER> <PROJECT_NAME> [<OFFICIAL_PROJECT>]"
        log_e "${FUNCNAME[0]} $# ${*}"
    else
        log_m "${FUNCNAME[0]} $# ${*}"
        # cd "${TOP_DIR:?}" || exit 1

        if [ "$#" == "4" ]; then
            local SRC_ROOT=${1}
            local GIT_PROVIDER=${2}
            local PROJECT_USER=${3}
            local PROJECT_NAME=${4}
            local PROJECT_DIR="${SRC_ROOT}/${PROJECT_NAME}" # "${SRC_ROOT}/${GIT_PROVIDER}/${PROJECT_USER}/${PROJECT_NAME}"
        elif [ "$#" == "5" ]; then
            local SRC_ROOT=${1}
            local GIT_PROVIDER=${2}
            local PROJECT_USER=${3}
            local PROJECT_NAME=${4}
            local PROJECT_DIR="${SRC_ROOT}/${PROJECT_NAME}" # "${SRC_ROOT}/${GIT_PROVIDER}/${PROJECT_USER}/${PROJECT_NAME}"
            local OFFICIAL_PROJECT=${5}
        fi

        cd "${PROJECT_DIR}" || exit 1

        #         local FILENAME=cmd.sh
        #         cat <<\*EOF* >"${PROJECT_DIR:?}/${FILENAME}"
        # *EOF*
    fi
}

function create_helm3_app_project_cmd_sh() {
    if [ "$#" != "0" ] && [ "$#" != "4" ] && [ "$#" != "5" ]; then
        log_e "Usage: ${FUNCNAME[0]} <SRC_ROOT> <GIT_PROVIDER : bitbucket.com | github.com | gitlab.com> <PROJECT_USER> <PROJECT_NAME> [<OFFICIAL_PROJECT>]"
        log_e "${FUNCNAME[0]} $# ${*}"
    else
        log_m "${FUNCNAME[0]} $# ${*}"
        # cd "${TOP_DIR:?}" || exit 1

        if [ "$#" == "4" ]; then
            local SRC_ROOT=${1}
            local GIT_PROVIDER=${2}
            local PROJECT_USER=${3}
            local PROJECT_NAME=${4}
            local PROJECT_DIR="${SRC_ROOT}/${PROJECT_NAME}" # "${SRC_ROOT}/${GIT_PROVIDER}/${PROJECT_USER}/${PROJECT_NAME}"
        elif [ "$#" == "5" ]; then
            local SRC_ROOT=${1}
            local GIT_PROVIDER=${2}
            local PROJECT_USER=${3}
            local PROJECT_NAME=${4}
            local PROJECT_DIR="${SRC_ROOT}/${PROJECT_NAME}" # "${SRC_ROOT}/${GIT_PROVIDER}/${PROJECT_USER}/${PROJECT_NAME}"
            local OFFICIAL_PROJECT=${5}
        fi

        cd "${PROJECT_DIR}" || exit 1

        #         local FILENAME=cmd.sh
        #         cat <<\*EOF* >"${PROJECT_DIR:?}/${FILENAME}"
        # *EOF*
    fi
}

function create_deployment_app_project_cmd_sh() {
    if [ "$#" != "0" ] && [ "$#" != "4" ] && [ "$#" != "5" ]; then
        log_e "Usage: ${FUNCNAME[0]} <SRC_ROOT> <GIT_PROVIDER : bitbucket.com | github.com | gitlab.com> <PROJECT_USER> <PROJECT_NAME> [<OFFICIAL_PROJECT>]"
        log_e "${FUNCNAME[0]} $# ${*}"
    else
        log_m "${FUNCNAME[0]} $# ${*}"
        # cd "${TOP_DIR:?}" || exit 1

        if [ "$#" == "4" ]; then
            local SRC_ROOT=${1}
            local GIT_PROVIDER=${2}
            local PROJECT_USER=${3}
            local PROJECT_NAME=${4}
            local PROJECT_DIR="${SRC_ROOT}/${PROJECT_NAME}" # "${SRC_ROOT}/${GIT_PROVIDER}/${PROJECT_USER}/${PROJECT_NAME}"
        elif [ "$#" == "5" ]; then
            local SRC_ROOT=${1}
            local GIT_PROVIDER=${2}
            local PROJECT_USER=${3}
            local PROJECT_NAME=${4}
            local PROJECT_DIR="${SRC_ROOT}/${PROJECT_NAME}" # "${SRC_ROOT}/${GIT_PROVIDER}/${PROJECT_USER}/${PROJECT_NAME}"
            local OFFICIAL_PROJECT=${5}
        fi

        cd "${PROJECT_DIR}" || exit 1

        #         local FILENAME=cmd.sh
        #         cat <<\*EOF* >"${PROJECT_DIR:?}/${FILENAME}"
        # *EOF*
    fi
}

function create_terraform_app_project_cmd_sh() {
    if [ "$#" != "0" ] && [ "$#" != "4" ] && [ "$#" != "5" ]; then
        log_e "Usage: ${FUNCNAME[0]} <SRC_ROOT> <GIT_PROVIDER : bitbucket.com | github.com | gitlab.com> <PROJECT_USER> <PROJECT_NAME> [<OFFICIAL_PROJECT>]"
        log_e "${FUNCNAME[0]} $# ${*}"
    else
        log_m "${FUNCNAME[0]} $# ${*}"
        # cd "${TOP_DIR:?}" || exit 1

        if [ "$#" == "4" ]; then
            local SRC_ROOT=${1}
            local GIT_PROVIDER=${2}
            local PROJECT_USER=${3}
            local PROJECT_NAME=${4}
            local PROJECT_DIR="${SRC_ROOT}/${PROJECT_NAME}" # "${SRC_ROOT}/${GIT_PROVIDER}/${PROJECT_USER}/${PROJECT_NAME}"
        elif [ "$#" == "5" ]; then
            local SRC_ROOT=${1}
            local GIT_PROVIDER=${2}
            local PROJECT_USER=${3}
            local PROJECT_NAME=${4}
            local PROJECT_DIR="${SRC_ROOT}/${PROJECT_NAME}" # "${SRC_ROOT}/${GIT_PROVIDER}/${PROJECT_USER}/${PROJECT_NAME}"
            local OFFICIAL_PROJECT=${5}
        fi

        cd "${PROJECT_DIR}" || exit 1

        #         local FILENAME=cmd.sh
        #         cat <<\*EOF* >"${PROJECT_DIR:?}/${FILENAME}"
        # *EOF*
    fi
}

function create_golang_app_project_cmd_sh() {
    if [ "$#" != "0" ] && [ "$#" != "4" ] && [ "$#" != "5" ]; then
        log_e "Usage: ${FUNCNAME[0]} <SRC_ROOT> <GIT_PROVIDER : bitbucket.com | github.com | gitlab.com> <PROJECT_USER> <PROJECT_NAME> [<OFFICIAL_PROJECT>]"
        log_e "${FUNCNAME[0]} $# ${*}"
    else
        log_m "${FUNCNAME[0]} $# ${*}"
        # cd "${TOP_DIR:?}" || exit 1

        if [ "$#" == "4" ]; then
            local SRC_ROOT=${1}
            local GIT_PROVIDER=${2}
            local PROJECT_USER=${3}
            local PROJECT_NAME=${4}
            local PROJECT_DIR="${SRC_ROOT}/${PROJECT_NAME}" # "${SRC_ROOT}/${GIT_PROVIDER}/${PROJECT_USER}/${PROJECT_NAME}"
        elif [ "$#" == "5" ]; then
            local SRC_ROOT=${1}
            local GIT_PROVIDER=${2}
            local PROJECT_USER=${3}
            local PROJECT_NAME=${4}
            local PROJECT_DIR="${SRC_ROOT}/${PROJECT_NAME}" # "${SRC_ROOT}/${GIT_PROVIDER}/${PROJECT_USER}/${PROJECT_NAME}"
            local OFFICIAL_PROJECT=${5}
        fi

        cd "${PROJECT_DIR}" || exit 1

        #         local FILENAME=cmd.sh
        #         cat <<\*EOF* >"${PROJECT_DIR:?}/${FILENAME}"
        # *EOF*
    fi
}

function create_typescript_app_project_cmd_sh() {
    if [ "$#" != "0" ] && [ "$#" != "4" ] && [ "$#" != "5" ]; then
        log_e "Usage: ${FUNCNAME[0]} <SRC_ROOT> <GIT_PROVIDER : bitbucket.com | github.com | gitlab.com> <PROJECT_USER> <PROJECT_NAME> [<OFFICIAL_PROJECT>]"
        log_e "${FUNCNAME[0]} $# ${*}"
    else
        log_m "${FUNCNAME[0]} $# ${*}"
        # cd "${TOP_DIR:?}" || exit 1

        if [ "$#" == "4" ]; then
            local SRC_ROOT=${1}
            local GIT_PROVIDER=${2}
            local PROJECT_USER=${3}
            local PROJECT_NAME=${4}
            local PROJECT_DIR="${SRC_ROOT}/${PROJECT_NAME}" # "${SRC_ROOT}/${GIT_PROVIDER}/${PROJECT_USER}/${PROJECT_NAME}"
        elif [ "$#" == "5" ]; then
            local SRC_ROOT=${1}
            local GIT_PROVIDER=${2}
            local PROJECT_USER=${3}
            local PROJECT_NAME=${4}
            local PROJECT_DIR="${SRC_ROOT}/${PROJECT_NAME}" # "${SRC_ROOT}/${GIT_PROVIDER}/${PROJECT_USER}/${PROJECT_NAME}"
            local OFFICIAL_PROJECT=${5}
        fi

        cd "${PROJECT_DIR}" || exit 1

        #         local FILENAME=cmd.sh
        #         cat <<\*EOF* >"${PROJECT_DIR:?}/${FILENAME}"
        # *EOF*
    fi
}

function create_python3_app_project_cmd_sh() {
    if [ "$#" != "0" ] && [ "$#" != "4" ] && [ "$#" != "5" ]; then
        log_e "Usage: ${FUNCNAME[0]} <SRC_ROOT> <GIT_PROVIDER : bitbucket.com | github.com | gitlab.com> <PROJECT_USER> <PROJECT_NAME> [<OFFICIAL_PROJECT>]"
        log_e "${FUNCNAME[0]} $# ${*}"
    else
        log_m "${FUNCNAME[0]} $# ${*}"
        # cd "${TOP_DIR:?}" || exit 1

        if [ "$#" == "4" ]; then
            local SRC_ROOT=${1}
            local GIT_PROVIDER=${2}
            local PROJECT_USER=${3}
            local PROJECT_NAME=${4}
            local PROJECT_DIR="${SRC_ROOT}/${PROJECT_NAME}" # "${SRC_ROOT}/${GIT_PROVIDER}/${PROJECT_USER}/${PROJECT_NAME}"
        elif [ "$#" == "5" ]; then
            local SRC_ROOT=${1}
            local GIT_PROVIDER=${2}
            local PROJECT_USER=${3}
            local PROJECT_NAME=${4}
            local PROJECT_DIR="${SRC_ROOT}/${PROJECT_NAME}" # "${SRC_ROOT}/${GIT_PROVIDER}/${PROJECT_USER}/${PROJECT_NAME}"
            local OFFICIAL_PROJECT=${5}
        fi

        cd "${PROJECT_DIR}" || exit 1

        #         local FILENAME=cmd.sh
        #         cat <<\*EOF* >"${PROJECT_DIR:?}/${FILENAME}"
        # *EOF*
    fi
}

function create_rust_app_project_cmd_sh() {
    if [ "$#" != "0" ] && [ "$#" != "4" ] && [ "$#" != "5" ]; then
        log_e "Usage: ${FUNCNAME[0]} <SRC_ROOT> <GIT_PROVIDER : bitbucket.com | github.com | gitlab.com> <PROJECT_USER> <PROJECT_NAME> [<OFFICIAL_PROJECT>]"
        log_e "${FUNCNAME[0]} $# ${*}"
    else
        log_m "${FUNCNAME[0]} $# ${*}"
        # cd "${TOP_DIR:?}" || exit 1

        if [ "$#" == "4" ]; then
            local SRC_ROOT=${1}
            local GIT_PROVIDER=${2}
            local PROJECT_USER=${3}
            local PROJECT_NAME=${4}
            local PROJECT_DIR="${SRC_ROOT}/${PROJECT_NAME}" # "${SRC_ROOT}/${GIT_PROVIDER}/${PROJECT_USER}/${PROJECT_NAME}"
        elif [ "$#" == "5" ]; then
            local SRC_ROOT=${1}
            local GIT_PROVIDER=${2}
            local PROJECT_USER=${3}
            local PROJECT_NAME=${4}
            local PROJECT_DIR="${SRC_ROOT}/${PROJECT_NAME}" # "${SRC_ROOT}/${GIT_PROVIDER}/${PROJECT_USER}/${PROJECT_NAME}"
            local OFFICIAL_PROJECT=${5}
        fi

        cd "${PROJECT_DIR}" || exit 1

        #         local FILENAME=cmd.sh
        #         cat <<\*EOF* >"${PROJECT_DIR:?}/${FILENAME}"
        # *EOF*
    fi
}

#******************************************************************************
# create_project_makefile

function create_project_makefile() {
    if [ "$#" != "0" ] && [ "$#" != "1" ]; then
        log_e "Usage: ${FUNCNAME[0]} <PROJECT_TYPE>"
        log_e "${FUNCNAME[0]} $# ${*}"
    else
        log_m "${FUNCNAME[0]} $# ${*}"
        cd "${TOP_DIR:?}" || exit 1

        if [ "$#" == "1" ]; then
            local DISTPROJECT_TYPERO=${1}
        fi

        case ${PROJECT_TYPE} in
            ansible_app) create_ansible_app_project_makefile ;;
            bash_app) create_bash_app_project_makefile ;;
            bash_deployment_app) create_bash_deployment_app_project_makefile ;;
            bash_install_app) create_bash_install_app_project_makefile ;;
            bash_remote_deployment_app) create_bash_remote_deployment_app_project_makefile ;;
            docker_app) create_docker_app_project_makefile ;;
            podman_app) create_podman_app_project_makefile ;;
            helm3_app) create_helm3_app_project_makefile ;;
            deployment_app) create_deployment_app_project_makefile ;;
            terraform_app) create_terraform_app_project_makefile ;;
            golang_app) create_golang_app_project_makefile ;;
            typescript_app) create_typescript_app_project_makefile ;;
            python3_app) create_python3_app_project_makefile ;;
            rust_app) create_rust_app_project_makefile ;;
            *) ;;
        esac
    fi
}

function create_ansible_app_project_makefile() {
    if [ "$#" != "0" ] && [ "$#" != "4" ] && [ "$#" != "5" ]; then
        log_e "Usage: ${FUNCNAME[0]} <SRC_ROOT> <GIT_PROVIDER : bitbucket.com | github.com | gitlab.com> <PROJECT_USER> <PROJECT_NAME> [<OFFICIAL_PROJECT>]"
        log_e "${FUNCNAME[0]} $# ${*}"
    else
        log_m "${FUNCNAME[0]} $# ${*}"
        # cd "${TOP_DIR:?}" || exit 1

        if [ "$#" == "4" ]; then
            local SRC_ROOT=${1}
            local GIT_PROVIDER=${2}
            local PROJECT_USER=${3}
            local PROJECT_NAME=${4}
            local PROJECT_DIR="${SRC_ROOT}/${PROJECT_NAME}" # "${SRC_ROOT}/${GIT_PROVIDER}/${PROJECT_USER}/${PROJECT_NAME}"
        elif [ "$#" == "5" ]; then
            local SRC_ROOT=${1}
            local GIT_PROVIDER=${2}
            local PROJECT_USER=${3}
            local PROJECT_NAME=${4}
            local PROJECT_DIR="${SRC_ROOT}/${PROJECT_NAME}" # "${SRC_ROOT}/${GIT_PROVIDER}/${PROJECT_USER}/${PROJECT_NAME}"
            local OFFICIAL_PROJECT=${5}
        fi

        cd "${PROJECT_DIR}" || exit 1

        #         local FILENAME=Makefile
        #         cat <<\*EOF* >"${PROJECT_DIR:?}/${FILENAME}"
        # *EOF*
        unexpand -a -t 4 "${PROJECT_DIR:?}/${FILENAME}" >"${PROJECT_DIR:?}/${FILENAME}.tmp"
        mv "${PROJECT_DIR:?}/${FILENAME}.tmp" "${PROJECT_DIR:?}/${FILENAME}"
    fi
}

function create_bash_app_project_makefile() {
    if [ "$#" != "0" ] && [ "$#" != "4" ] && [ "$#" != "5" ]; then
        log_e "Usage: ${FUNCNAME[0]} <SRC_ROOT> <GIT_PROVIDER : bitbucket.com | github.com | gitlab.com> <PROJECT_USER> <PROJECT_NAME> [<OFFICIAL_PROJECT>]"
        log_e "${FUNCNAME[0]} $# ${*}"
    else
        log_m "${FUNCNAME[0]} $# ${*}"
        # cd "${TOP_DIR:?}" || exit 1

        if [ "$#" == "4" ]; then
            local SRC_ROOT=${1}
            local GIT_PROVIDER=${2}
            local PROJECT_USER=${3}
            local PROJECT_NAME=${4}
            local PROJECT_DIR="${SRC_ROOT}/${PROJECT_NAME}" # "${SRC_ROOT}/${GIT_PROVIDER}/${PROJECT_USER}/${PROJECT_NAME}"
        elif [ "$#" == "5" ]; then
            local SRC_ROOT=${1}
            local GIT_PROVIDER=${2}
            local PROJECT_USER=${3}
            local PROJECT_NAME=${4}
            local PROJECT_DIR="${SRC_ROOT}/${PROJECT_NAME}" # "${SRC_ROOT}/${GIT_PROVIDER}/${PROJECT_USER}/${PROJECT_NAME}"
            local OFFICIAL_PROJECT=${5}
        fi

        cd "${PROJECT_DIR}" || exit 1

        #         local FILENAME=Makefile
        #         cat <<\*EOF* >"${PROJECT_DIR:?}/${FILENAME}"
        # *EOF*
        unexpand -a -t 4 "${PROJECT_DIR:?}/${FILENAME}" >"${PROJECT_DIR:?}/${FILENAME}.tmp"
        mv "${PROJECT_DIR:?}/${FILENAME}.tmp" "${PROJECT_DIR:?}/${FILENAME}"
    fi
}

function create_bash_deployment_app_project_makefile() {
    if [ "$#" != "0" ] && [ "$#" != "4" ] && [ "$#" != "5" ]; then
        log_e "Usage: ${FUNCNAME[0]} <SRC_ROOT> <GIT_PROVIDER : bitbucket.com | github.com | gitlab.com> <PROJECT_USER> <PROJECT_NAME> [<OFFICIAL_PROJECT>]"
        log_e "${FUNCNAME[0]} $# ${*}"
    else
        log_m "${FUNCNAME[0]} $# ${*}"
        # cd "${TOP_DIR:?}" || exit 1

        if [ "$#" == "4" ]; then
            local SRC_ROOT=${1}
            local GIT_PROVIDER=${2}
            local PROJECT_USER=${3}
            local PROJECT_NAME=${4}
            local PROJECT_DIR="${SRC_ROOT}/${PROJECT_NAME}" # "${SRC_ROOT}/${GIT_PROVIDER}/${PROJECT_USER}/${PROJECT_NAME}"
        elif [ "$#" == "5" ]; then
            local SRC_ROOT=${1}
            local GIT_PROVIDER=${2}
            local PROJECT_USER=${3}
            local PROJECT_NAME=${4}
            local PROJECT_DIR="${SRC_ROOT}/${PROJECT_NAME}" # "${SRC_ROOT}/${GIT_PROVIDER}/${PROJECT_USER}/${PROJECT_NAME}"
            local OFFICIAL_PROJECT=${5}
        fi

        cd "${PROJECT_DIR}" || exit 1

        #         local FILENAME=Makefile
        #         cat <<\*EOF* >"${PROJECT_DIR:?}/${FILENAME}"
        # *EOF*
        unexpand -a -t 4 "${PROJECT_DIR:?}/${FILENAME}" >"${PROJECT_DIR:?}/${FILENAME}.tmp"
        mv "${PROJECT_DIR:?}/${FILENAME}.tmp" "${PROJECT_DIR:?}/${FILENAME}"
    fi
}

function create_bash_install_app_project_makefile() {
    if [ "$#" != "0" ] && [ "$#" != "4" ] && [ "$#" != "5" ]; then
        log_e "Usage: ${FUNCNAME[0]} <SRC_ROOT> <GIT_PROVIDER : bitbucket.com | github.com | gitlab.com> <PROJECT_USER> <PROJECT_NAME> [<OFFICIAL_PROJECT>]"
        log_e "${FUNCNAME[0]} $# ${*}"
    else
        log_m "${FUNCNAME[0]} $# ${*}"
        # cd "${TOP_DIR:?}" || exit 1

        if [ "$#" == "4" ]; then
            local SRC_ROOT=${1}
            local GIT_PROVIDER=${2}
            local PROJECT_USER=${3}
            local PROJECT_NAME=${4}
            local PROJECT_DIR="${SRC_ROOT}/${PROJECT_NAME}" # "${SRC_ROOT}/${GIT_PROVIDER}/${PROJECT_USER}/${PROJECT_NAME}"
        elif [ "$#" == "5" ]; then
            local SRC_ROOT=${1}
            local GIT_PROVIDER=${2}
            local PROJECT_USER=${3}
            local PROJECT_NAME=${4}
            local PROJECT_DIR="${SRC_ROOT}/${PROJECT_NAME}" # "${SRC_ROOT}/${GIT_PROVIDER}/${PROJECT_USER}/${PROJECT_NAME}"
            local OFFICIAL_PROJECT=${5}
        fi

        cd "${PROJECT_DIR}" || exit 1

        #         local FILENAME=Makefile
        #         cat <<\*EOF* >"${PROJECT_DIR:?}/${FILENAME}"
        # *EOF*
        unexpand -a -t 4 "${PROJECT_DIR:?}/${FILENAME}" >"${PROJECT_DIR:?}/${FILENAME}.tmp"
        mv "${PROJECT_DIR:?}/${FILENAME}.tmp" "${PROJECT_DIR:?}/${FILENAME}"
    fi
}

function create_bash_remote_deployment_app_project_makefile() {
    if [ "$#" != "0" ] && [ "$#" != "4" ] && [ "$#" != "5" ]; then
        log_e "Usage: ${FUNCNAME[0]} <SRC_ROOT> <GIT_PROVIDER : bitbucket.com | github.com | gitlab.com> <PROJECT_USER> <PROJECT_NAME> [<OFFICIAL_PROJECT>]"
        log_e "${FUNCNAME[0]} $# ${*}"
    else
        log_m "${FUNCNAME[0]} $# ${*}"
        # cd "${TOP_DIR:?}" || exit 1

        if [ "$#" == "4" ]; then
            local SRC_ROOT=${1}
            local GIT_PROVIDER=${2}
            local PROJECT_USER=${3}
            local PROJECT_NAME=${4}
            local PROJECT_DIR="${SRC_ROOT}/${PROJECT_NAME}" # "${SRC_ROOT}/${GIT_PROVIDER}/${PROJECT_USER}/${PROJECT_NAME}"
        elif [ "$#" == "5" ]; then
            local SRC_ROOT=${1}
            local GIT_PROVIDER=${2}
            local PROJECT_USER=${3}
            local PROJECT_NAME=${4}
            local PROJECT_DIR="${SRC_ROOT}/${PROJECT_NAME}" # "${SRC_ROOT}/${GIT_PROVIDER}/${PROJECT_USER}/${PROJECT_NAME}"
            local OFFICIAL_PROJECT=${5}
        fi

        cd "${PROJECT_DIR}" || exit 1

        #         local FILENAME=Makefile
        #         cat <<\*EOF* >"${PROJECT_DIR:?}/${FILENAME}"
        # *EOF*
        unexpand -a -t 4 "${PROJECT_DIR:?}/${FILENAME}" >"${PROJECT_DIR:?}/${FILENAME}.tmp"
        mv "${PROJECT_DIR:?}/${FILENAME}.tmp" "${PROJECT_DIR:?}/${FILENAME}"
    fi
}

function create_docker_app_project_makefile() {
    if [ "$#" != "0" ] && [ "$#" != "4" ] && [ "$#" != "5" ]; then
        log_e "Usage: ${FUNCNAME[0]} <SRC_ROOT> <GIT_PROVIDER : bitbucket.com | github.com | gitlab.com> <PROJECT_USER> <PROJECT_NAME> [<OFFICIAL_PROJECT>]"
        log_e "${FUNCNAME[0]} $# ${*}"
    else
        log_m "${FUNCNAME[0]} $# ${*}"
        # cd "${TOP_DIR:?}" || exit 1

        if [ "$#" == "4" ]; then
            local SRC_ROOT=${1}
            local GIT_PROVIDER=${2}
            local PROJECT_USER=${3}
            local PROJECT_NAME=${4}
            local PROJECT_DIR="${SRC_ROOT}/${PROJECT_NAME}" # "${SRC_ROOT}/${GIT_PROVIDER}/${PROJECT_USER}/${PROJECT_NAME}"
        elif [ "$#" == "5" ]; then
            local SRC_ROOT=${1}
            local GIT_PROVIDER=${2}
            local PROJECT_USER=${3}
            local PROJECT_NAME=${4}
            local PROJECT_DIR="${SRC_ROOT}/${PROJECT_NAME}" # "${SRC_ROOT}/${GIT_PROVIDER}/${PROJECT_USER}/${PROJECT_NAME}"
            local OFFICIAL_PROJECT=${5}
        fi

        cd "${PROJECT_DIR}" || exit 1

        local FILENAME=Makefile
        cat <<\*EOF* >"${PROJECT_DIR:?}/${FILENAME}"
# https://www.gnu.org/software/make/manual/make.html
# https://www.gnu.org/software/make/manual/html_node/Simple-Makefile.html
# TOP_DIR=$(shell dirname $(abspath $(lastword $(MAKEFILE_LIST))))
TOP_DIR=$(shell dirname $(abspath $(firstword $(MAKEFILE_LIST))))
PROJECT_TYPE=
# https://hub.docker.com/_/<OFFICIAL_DOCKER_PROJECT>
# make USE_OFFICIAL=1 <COMMAND>
ifdef USE_OFFICIAL
    # docker.io | quay.io | gcr.io
    DOCKER_REGISTRY=
    # <OFFICIAL_DOCKER_PROJECT> | $(shell echo $(notdir $(TOP_DIR)) | cut -d '/' -f2 | tr -d '[:space:]' | cut -d '_' -f2)
    DOCKER_PROJECT=$(shell echo $(notdir $(TOP_DIR)) | cut -d '/' -f2 | tr -d '[:space:]' | cut -d '_' -f2)
else
    # $(DISTRO)_base | cclhsu
    DOCKER_REGISTRY=alpine_base/
    # <DISTRO>_helloworld | $(notdir $(TOP_DIR)) | helloworld
    DOCKER_PROJECT=$(notdir $(TOP_DIR))
endif
DOCKER_PROJECT_NAME=$(shell echo $(DOCKER_PROJECT) | cut -d '/' -f2 | tr -d '[:space:]')
# Dockerfile | SDK.Dockerfile | SDKMAN.Dockerfile | Multi-Stages.Dockerfile
DOCKER_FILE=Dockerfile
# docker-compose.yml | docker-compose.yaml
DOCKER_COMPOSE_FILE=docker-compose.yml

# latest | alpine3.14 | 13.3-buster
DOCKER_TAG=latest
# USER_NAME=
# USER_PASSWORD=
# SRC_DIR=
# MOUNT_DIR=
PORT=8080
DB_NAME=
DB_USER_NAME=
DB_USER_PASSWORD=
DB_PORT=5432
PROJECT_FOLDER=/project
DATA_FOLDER=data

# docker_network | <docker-compose-project>_docker_network | host
# DOCKER_NETWORK=docker_network
# DOCKER_RUN=docker run --rm -d
DOCKER_RUN=docker run --rm -ti
# DOCKER_PARAMETERS=--network host --user $(id -u):$(id -g)
# DOCKER_PARAMETERS=-e USER_NAME=$(USER_NAME) -e USER_PASSWORD=$(USER_PASSWORD) -p $(PORT):$(PORT) -v $(SRC_DIR):$(MOUNT_DIR)
# DOCKER_PARAMETERS=-e DB_NAME=$(DB_NAME) -e DB_USER_NAME=$(DB_USER_NAME) -e DB_USER_PASSWORD=$(DB_USER_PASSWORD) -p $(DB_PORT):$(DB_PORT)
# DOCKER_COMMAND=/bin/bash
# DOCKER_COMMAND=entrypoint.sh

# ifneq ("$(wildcard VERSION.txt)", "")
#     TAG=$(shell grep -i version VERSION.txt | cut -d '=' -f 2 | tr -d '[:space:]')
# else ifdef LATEST
#     TAG=latest
# else
#     TAG=latest
# endif

# ifneq ("$(wildcard ${HOME}/.my_libs/$(PROJECT_TYPE)/myenv)", "")
#     include ${HOME}/.my_libs/$(PROJECT_TYPE)/myenv
# else ifneq ("$(wildcard env)", "")
#     include env
# else
#     GITHUB_USER=cclhsu
#     GITHUB_USER_PASSWORD=
#     GITHUB_USER_TOKEN=
#     GITHUB_USER_EMAIL=cclhsu@yahoo.com
#     DOCKER_USER=cclhsu
#     DOCKER_PASSWORD=
# endif

##### HOWTO #####


##### ##### #####

.DEFAULT_GOAL := help

.PHONY: help
help: ## help
    @echo -e "\n======================================================================\n"
    @echo -e "\n>>> help...\n"
    @#make -rpn | sed -n -e '/^$$/ { n ; /^[^ .#][^ ]*:/ { s/:.*$$// ; p ; } ; }' | sort | awk 'BEGIN {FS = ":.*?## "}; {printf "\033[36m%-30s\033[0m %s\n", $$1, $$2}'
    @grep -E '^[a-zA-Z_-]+:.*?## .*$$' $(MAKEFILE_LIST) | sort | awk 'BEGIN {FS = ":.*?## "}; {printf "\033[36m%-30s\033[0m %s\n", $$1, $$2}'
    @echo -e "\n======================================================================\n"

.PHONY: all
all:  ## all
    @echo -e "\n======================================================================\n"
    @echo -e "\n>>> ...\n"
    make clean
    make build
    make list
    @echo -e "\n======================================================================\n"

.PHONY: lint
lint:  ## lint
    @echo -e "\n======================================================================\n"
    @echo -e "\n>>> lint...\n"
    @echo -e "\n======================================================================\n"

.PHONY: build
build: ## build
    @echo -e "\n======================================================================\n"
    @echo -e "\n>>> build...\n"
    @# make clean
    @# docker build -f $(DOCKER_FILE) -t $(DOCKER_REGISTRY)$(DOCKER_PROJECT):$(DOCKER_TAG) .
    docker build --rm -f $(DOCKER_FILE) -t $(DOCKER_REGISTRY)$(DOCKER_PROJECT):$(DOCKER_TAG) .
    docker rmi $(shell docker images -f "dangling=true" -q) 2>/dev/null; true
    @echo -e "\n======================================================================\n"

.PHONY: nocache
nocache: ## nocache
    @echo -e "\n======================================================================\n"
    @echo -e "\n>>> nocache...\n"
    @# make clean
    @# docker build -f $(DOCKER_FILE) -t $(DOCKER_REGISTRY)$(DOCKER_PROJECT):$(DOCKER_TAG) --no-cache .
    docker build --rm -f $(DOCKER_FILE) -t $(DOCKER_REGISTRY)$(DOCKER_PROJECT):$(DOCKER_TAG) --no-cache .
    docker rmi $(shell docker images -f "dangling=true" -q) 2>/dev/null; true
    @echo -e "\n======================================================================\n"

.PHONY: pull
pull: ## pull
    @echo -e "\n======================================================================\n"
    @echo -e "\n>>> pull...\n"
    docker pull $(DOCKER_REGISTRY)$(DOCKER_PROJECT):$(DOCKER_TAG)
    @echo -e "\n======================================================================\n"

.PHONY: push
push: ## push
    @echo -e "\n======================================================================\n"
    @echo -e "\n>>> push...\n"
    docker push $(DOCKER_REGISTRY)$(DOCKER_PROJECT):$(DOCKER_TAG)
    @echo -e "\n======================================================================\n"

.PHONY: run
run: ## run
    @echo -e "\n======================================================================\n"
    @echo -e "\n>>> run...\n"
    $(DOCKER_RUN) $(DOCKER_PARAMETERS) --name $(DOCKER_PROJECT_NAME) $(DOCKER_REGISTRY)$(DOCKER_PROJECT):$(DOCKER_TAG) $(DOCKER_COMMAND)
    @echo -e "\n======================================================================\n"

.PHONY: stop
stop: ## stop
    @echo -e "\n======================================================================\n"
    @echo -e "\n>>> stop...\n"
    docker stop $(DOCKER_PROJECT_NAME); true
    docker rm -f $(DOCKER_PROJECT_NAME) 2>/dev/null; true
    docker volume prune --force 2>/dev/null; true
    rm -rf tmp
    sudo rm -rf ${DATA_FOLDER}
    @echo -e "\n======================================================================\n"

.PHONY: logs
logs: ## logs
    @echo -e "\n======================================================================\n"
    @echo -e "\n>>> logs...\n"
    docker logs $(DOCKER_PROJECT_NAME)
    @echo -e "\n======================================================================\n"

.PHONY: bash_container
bash_container: ## bash_container
    @echo -e "\n======================================================================\n"
    @echo -e "\n>>> bash_container...\n"
    bash -c "clear && docker exec -it $(DOCKER_PROJECT_NAME) /bin/sh"
    @echo -e "\n======================================================================\n"

.PHONY: bash
bash: ## bash
    @echo -e "\n======================================================================\n"
    @echo -e "\n>>> bash...\n"
    @# $(COMMAND) /bin/bash
    $(DOCKER_RUN) --entrypoint "" $(DOCKER_PARAMETERS) -h $(DOCKER_PROJECT_NAME) --name $(DOCKER_PROJECT_NAME) $(DOCKER_REGISTRY)$(DOCKER_PROJECT):$(DOCKER_TAG) /bin/bash
    @echo -e "\n======================================================================\n"

.PHONY: clean
clean: ## clean
    @echo -e "\n======================================================================\n"
    @echo -e "\n>>> clean...\n"
    docker rm -f $(DOCKER_PROJECT) 2>/dev/null; true
    docker rmi $(DOCKER_REGISTRY)$(DOCKER_PROJECT):$(DOCKER_TAG) 2>/dev/null; true
    docker rm $(shell docker ps -a -q) 2>/dev/null; true
    docker rmi $(shell docker images -f "dangling=true" -q) 2>/dev/null; true
    docker volume prune --force 2>/dev/null; true
    rm -rf tmp
    @# sudo rm -rf ${SRC_DIR}
    @# find "$(TOP_DIR)" -type f -name "*.log" -print -delete;
    @# find "$(TOP_DIR)" -type f -name "*.pyc" -print -delete;
    @# find "$(TOP_DIR)" -type f -name "*.pid" -print -delete;
    @echo -e "\n======================================================================\n"

.PHONY: cp_default_config
cp_default_config:
    @echo -e "\n======================================================================\n"
    @echo -e "\n>>> ...\n"
    rm -rf defaultfs
    mkdir -p defaultfs/etc/
    docker cp $(DOCKER_PROJECT_NAME):/etc/$(APP) defaultfs/etc/$(APP) 2>/dev/null; true
    docker cp $(DOCKER_PROJECT_NAME):/etc/$(APP).conf defaultfs/etc/$(APP).conf 2>/dev/null; true
    @# mkdir -p defaultfs/etc/conf.d
    @# docker cp $(DOCKER_PROJECT_NAME):/etc/conf.d/$(APP) defaultfs/etc/conf.d/$(APP) 2>/dev/null; true
    @# mkdir -p defaultfs/etc/init.d
    @# docker cp $(DOCKER_PROJECT_NAME):/etc/init.d/$(APP) defaultfs/etc/init.d/$(APP) 2>/dev/null; true
    @# mkdir -p defaultfs/etc/logrotate.d
    @# docker cp $(DOCKER_PROJECT_NAME):/etc/logrotate.d/$(APP) defaultfs/etc/logrotate.d/$(APP) 2>/dev/null; true
    @# mkdir -p defaultfs/etc/sysconfig/
    @# docker cp $(DOCKER_PROJECT_NAME):/etc/sysconfig/$(APP) defaultfs/etc/sysconfig/$(APP) 2>/dev/null; true
    @# mkdir -p defaultfs/etc/ssl
    @# docker cp $(DOCKER_PROJECT_NAME):/etc/ssl/$(APP) defaultfs/etc/ssl/$(APP) 2>/dev/null; true
    @# mkdir -p defaultfs/etc/pki
    @# docker cp $(DOCKER_PROJECT_NAME):/etc/pki/$(APP) defaultfs/etc/pki/$(APP) 2>/dev/null; true
    @# mkdir -p defaultfs/usr/share/
    @# docker cp $(DOCKER_PROJECT_NAME):/usr/share/$(APP) defaultfs/usr/share/$(APP) 2>/dev/null; true
    @# mkdir -p defaultfs/var/www/
    @# docker cp $(DOCKER_PROJECT_NAME):/var/www/html defaultfs/var/www/html 2>/dev/null; true
    @echo -e "\n======================================================================\n"

.PHONY: stop_all
stop_all:
    @echo -e "\n======================================================================\n"
    @echo -e "\n>>> ...\n"
    docker stop $(shell docker ps -a -q) 2>/dev/null; true
    docker volume prune --force 2>/dev/null; true
    @echo -e "\n======================================================================\n"

.PHONY: list
list: ## list
    @echo -e "\n======================================================================\n"
    @echo -e "\n>>> list...\n"
    docker ps -a && echo
    docker volume ls && echo
    docker images && echo
    @echo -e "\n======================================================================\n"

# .PHONY: curl
# curl: ## curl
#      @echo -e "\n======================================================================\n"
#      @echo -e "\n>>> curl...\n"
#      @# curl -x 0.0.0.0:3128 -L http://www.google.com/
#      curl -OL http://localhost:${PORT}
#      @echo -e "\n======================================================================\n"

# .PHONY: browser
# browser: ## browser
#      @echo -e "\n======================================================================\n"
#      @echo -e "\n>>> browser...\n"
#      open http://localhost:${PORT}/
#      @echo -e "\n======================================================================\n"
*EOF*
        unexpand -a -t 4 "${PROJECT_DIR:?}/${FILENAME}" >"${PROJECT_DIR:?}/${FILENAME}.tmp"
        mv "${PROJECT_DIR:?}/${FILENAME}.tmp" "${PROJECT_DIR:?}/${FILENAME}"
    fi
}

function create_podman_app_project_makefile() {
    if [ "$#" != "0" ] && [ "$#" != "4" ] && [ "$#" != "5" ]; then
        log_e "Usage: ${FUNCNAME[0]} <SRC_ROOT> <GIT_PROVIDER : bitbucket.com | github.com | gitlab.com> <PROJECT_USER> <PROJECT_NAME> [<OFFICIAL_PROJECT>]"
        log_e "${FUNCNAME[0]} $# ${*}"
    else
        log_m "${FUNCNAME[0]} $# ${*}"
        # cd "${TOP_DIR:?}" || exit 1

        if [ "$#" == "4" ]; then
            local SRC_ROOT=${1}
            local GIT_PROVIDER=${2}
            local PROJECT_USER=${3}
            local PROJECT_NAME=${4}
            local PROJECT_DIR="${SRC_ROOT}/${PROJECT_NAME}" # "${SRC_ROOT}/${GIT_PROVIDER}/${PROJECT_USER}/${PROJECT_NAME}"
        elif [ "$#" == "5" ]; then
            local SRC_ROOT=${1}
            local GIT_PROVIDER=${2}
            local PROJECT_USER=${3}
            local PROJECT_NAME=${4}
            local PROJECT_DIR="${SRC_ROOT}/${PROJECT_NAME}" # "${SRC_ROOT}/${GIT_PROVIDER}/${PROJECT_USER}/${PROJECT_NAME}"
            local OFFICIAL_PROJECT=${5}
        fi

        cd "${PROJECT_DIR}" || exit 1

        local FILENAME=Makefile
        cat <<\*EOF* >"${PROJECT_DIR:?}/${FILENAME}"
# https://www.gnu.org/software/make/manual/make.html
# https://www.gnu.org/software/make/manual/html_node/Simple-Makefile.html
# TOP_DIR=$(shell dirname $(abspath $(lastword $(MAKEFILE_LIST))))
TOP_DIR=$(shell dirname $(abspath $(firstword $(MAKEFILE_LIST))))
PROJECT_TYPE=
# https://hub.podman.com/_/<OFFICIAL_PODMAN_PROJECT>
# make USE_OFFICIAL=1 <COMMAND>
ifdef USE_OFFICIAL
    # docker.io | quay.io | gcr.io
    PODMAN_REGISTRY=
    # <OFFICIAL_PODMAN_PROJECT> | $(shell echo $(notdir $(TOP_DIR)) | cut -d '/' -f2 | tr -d '[:space:]' | cut -d '_' -f2)
    PODMAN_PROJECT=$(shell echo $(notdir $(TOP_DIR)) | cut -d '/' -f2 | tr -d '[:space:]' | cut -d '_' -f2)
else
    # $(DISTRO)_base | cclhsu
    PODMAN_REGISTRY=alpine_base/
    # <DISTRO>_helloworld | $(notdir $(TOP_DIR)) | helloworld
    PODMAN_PROJECT=$(notdir $(TOP_DIR))
endif
PODMAN_PROJECT_NAME=$(shell echo $(PODMAN_PROJECT) | cut -d '/' -f2 | tr -d '[:space:]')
# Podmanfile | SDK.Podmanfile | SDKMAN.Podmanfile | Multi-Stages.Podmanfile
PODMAN_FILE=Podmanfile
# podman-compose.yml | podman-compose.yaml
PODMAN_COMPOSE_FILE=podman-compose.yml

# latest | alpine3.14 | 13.3-buster
PODMAN_TAG=latest
# USER_NAME=
# USER_PASSWORD=
# SRC_DIR=
# MOUNT_DIR=
PORT=8080
DB_NAME=
DB_USER_NAME=
DB_USER_PASSWORD=
DB_PORT=5432
PROJECT_FOLDER=/project
DATA_FOLDER=data

# podman_network | <podman-compose-project>_podman_network | host
# PODMAN_NETWORK=podman_network
# PODMAN_RUN=podman run --rm -d
PODMAN_RUN=podman run --rm -ti
# PODMAN_PARAMETERS=--network host --user $(id -u):$(id -g)
# PODMAN_PARAMETERS=-e USER_NAME=$(USER_NAME) -e USER_PASSWORD=$(USER_PASSWORD) -p $(PORT):$(PORT) -v $(SRC_DIR):$(MOUNT_DIR)
# PODMAN_PARAMETERS=-e DB_NAME=$(DB_NAME) -e DB_USER_NAME=$(DB_USER_NAME) -e DB_USER_PASSWORD=$(DB_USER_PASSWORD) -p $(DB_PORT):$(DB_PORT)
# PODMAN_COMMAND=/bin/bash
# PODMAN_COMMAND=entrypoint.sh

# ifneq ("$(wildcard VERSION.txt)", "")
#     TAG=$(shell grep -i version VERSION.txt | cut -d '=' -f 2 | tr -d '[:space:]')
# else ifdef LATEST
#     TAG=latest
# else
#     TAG=latest
# endif

# ifneq ("$(wildcard ${HOME}/.my_libs/$(PROJECT_TYPE)/myenv)", "")
#     include ${HOME}/.my_libs/$(PROJECT_TYPE)/myenv
# else ifneq ("$(wildcard env)", "")
#     include env
# else
#     GITHUB_USER=cclhsu
#     GITHUB_USER_PASSWORD=
#     GITHUB_USER_TOKEN=
#     GITHUB_USER_EMAIL=cclhsu@yahoo.com
#     PODMAN_USER=cclhsu
#     PODMAN_PASSWORD=
# endif

##### HOWTO #####


##### ##### #####

.DEFAULT_GOAL := help

.PHONY: help
help: ## help
    @echo -e "\n======================================================================\n"
    @echo -e "\n>>> help...\n"
    @#make -rpn | sed -n -e '/^$$/ { n ; /^[^ .#][^ ]*:/ { s/:.*$$// ; p ; } ; }' | sort | awk 'BEGIN {FS = ":.*?## "}; {printf "\033[36m%-30s\033[0m %s\n", $$1, $$2}'
    @grep -E '^[a-zA-Z_-]+:.*?## .*$$' $(MAKEFILE_LIST) | sort | awk 'BEGIN {FS = ":.*?## "}; {printf "\033[36m%-30s\033[0m %s\n", $$1, $$2}'
    @echo -e "\n======================================================================\n"

.PHONY: all
all:  ## all
    @echo -e "\n======================================================================\n"
    @echo -e "\n>>> ...\n"
    make clean
    make build
    make list
    @echo -e "\n======================================================================\n"

.PHONY: lint
lint:  ## lint
    @echo -e "\n======================================================================\n"
    @echo -e "\n>>> lint...\n"
    @echo -e "\n======================================================================\n"

.PHONY: build
build: ## build
    @echo -e "\n======================================================================\n"
    @echo -e "\n>>> build...\n"
    @# make clean
    @# podman build -f $(PODMAN_FILE) -t $(PODMAN_REGISTRY)$(PODMAN_PROJECT):$(PODMAN_TAG) .
    podman build --rm -f $(PODMAN_FILE) -t $(PODMAN_REGISTRY)$(PODMAN_PROJECT):$(PODMAN_TAG) .
    podman rmi $(shell podman images -f "dangling=true" -q) 2>/dev/null; true
    @echo -e "\n======================================================================\n"

.PHONY: nocache
nocache: ## nocache
    @echo -e "\n======================================================================\n"
    @echo -e "\n>>> nocache...\n"
    @# make clean
    @# podman build -f $(PODMAN_FILE) -t $(PODMAN_REGISTRY)$(PODMAN_PROJECT):$(PODMAN_TAG) --no-cache .
    podman build --rm -f $(PODMAN_FILE) -t $(PODMAN_REGISTRY)$(PODMAN_PROJECT):$(PODMAN_TAG) --no-cache .
    podman rmi $(shell podman images -f "dangling=true" -q) 2>/dev/null; true
    @echo -e "\n======================================================================\n"

.PHONY: pull
pull: ## pull
    @echo -e "\n======================================================================\n"
    @echo -e "\n>>> pull...\n"
    podman pull $(PODMAN_REGISTRY)$(PODMAN_PROJECT):$(PODMAN_TAG)
    @echo -e "\n======================================================================\n"

.PHONY: push
push: ## push
    @echo -e "\n======================================================================\n"
    @echo -e "\n>>> push...\n"
    podman push $(PODMAN_REGISTRY)$(PODMAN_PROJECT):$(PODMAN_TAG)
    @echo -e "\n======================================================================\n"

.PHONY: run
run: ## run
    @echo -e "\n======================================================================\n"
    @echo -e "\n>>> run...\n"
    $(PODMAN_RUN) $(PODMAN_PARAMETERS) --name $(PODMAN_PROJECT_NAME) $(PODMAN_REGISTRY)$(PODMAN_PROJECT):$(PODMAN_TAG) $(PODMAN_COMMAND)
    @echo -e "\n======================================================================\n"

.PHONY: stop
stop: ## stop
    @echo -e "\n======================================================================\n"
    @echo -e "\n>>> stop...\n"
    podman stop $(PODMAN_PROJECT_NAME); true
    podman rm -f $(PODMAN_PROJECT_NAME) 2>/dev/null; true
    podman volume prune --force 2>/dev/null; true
    rm -rf tmp
    sudo rm -rf ${DATA_FOLDER}
    @echo -e "\n======================================================================\n"

.PHONY: logs
logs: ## logs
    @echo -e "\n======================================================================\n"
    @echo -e "\n>>> logs...\n"
    podman logs $(PODMAN_PROJECT_NAME)
    @echo -e "\n======================================================================\n"

.PHONY: bash_container
bash_container: ## bash_container
    @echo -e "\n======================================================================\n"
    @echo -e "\n>>> bash_container...\n"
    bash -c "clear && podman exec -it $(PODMAN_PROJECT_NAME) /bin/sh"
    @echo -e "\n======================================================================\n"

.PHONY: bash
bash: ## bash
    @echo -e "\n======================================================================\n"
    @echo -e "\n>>> bash...\n"
    @# $(COMMAND) /bin/bash
    $(PODMAN_RUN) --entrypoint "" $(PODMAN_PARAMETERS) -h $(PODMAN_PROJECT_NAME) --name $(PODMAN_PROJECT_NAME) $(PODMAN_REGISTRY)$(PODMAN_PROJECT):$(PODMAN_TAG) /bin/bash
    @echo -e "\n======================================================================\n"

.PHONY: clean
clean: ## clean
    @echo -e "\n======================================================================\n"
    @echo -e "\n>>> clean...\n"
    podman rm -f $(PODMAN_PROJECT) 2>/dev/null; true
    podman rmi $(PODMAN_REGISTRY)$(PODMAN_PROJECT):$(PODMAN_TAG) 2>/dev/null; true
    podman rm $(shell podman ps -a -q) 2>/dev/null; true
    podman rmi $(shell podman images -f "dangling=true" -q) 2>/dev/null; true
    podman volume prune --force 2>/dev/null; true
    rm -rf tmp
    @# sudo rm -rf ${SRC_DIR}
    @# find "$(TOP_DIR)" -type f -name "*.log" -print -delete;
    @# find "$(TOP_DIR)" -type f -name "*.pyc" -print -delete;
    @# find "$(TOP_DIR)" -type f -name "*.pid" -print -delete;
    @echo -e "\n======================================================================\n"

.PHONY: cp_default_config
cp_default_config:
    @echo -e "\n======================================================================\n"
    @echo -e "\n>>> ...\n"
    rm -rf defaultfs
    mkdir -p defaultfs/etc/
    podman cp $(DOCKER_PROJECT_NAME):/etc/$(APP) defaultfs/etc/$(APP) 2>/dev/null; true
    podman cp $(DOCKER_PROJECT_NAME):/etc/$(APP).conf defaultfs/etc/$(APP).conf 2>/dev/null; true
    @# mkdir -p defaultfs/etc/conf.d
    @# podman cp $(DOCKER_PROJECT_NAME):/etc/conf.d/$(APP) defaultfs/etc/conf.d/$(APP) 2>/dev/null; true
    @# mkdir -p defaultfs/etc/init.d
    @# podman cp $(DOCKER_PROJECT_NAME):/etc/init.d/$(APP) defaultfs/etc/init.d/$(APP) 2>/dev/null; true
    @# mkdir -p defaultfs/etc/logrotate.d
    @# podman cp $(DOCKER_PROJECT_NAME):/etc/logrotate.d/$(APP) defaultfs/etc/logrotate.d/$(APP) 2>/dev/null; true
    @# mkdir -p defaultfs/etc/sysconfig/
    @# podman cp $(DOCKER_PROJECT_NAME):/etc/sysconfig/$(APP) defaultfs/etc/sysconfig/$(APP) 2>/dev/null; true
    @# mkdir -p defaultfs/etc/ssl
    @# podman cp $(DOCKER_PROJECT_NAME):/etc/ssl/$(APP) defaultfs/etc/ssl/$(APP) 2>/dev/null; true
    @# mkdir -p defaultfs/etc/pki
    @# podman cp $(DOCKER_PROJECT_NAME):/etc/pki/$(APP) defaultfs/etc/pki/$(APP) 2>/dev/null; true
    @# mkdir -p defaultfs/usr/share/
    @# podman cp $(DOCKER_PROJECT_NAME):/usr/share/$(APP) defaultfs/usr/share/$(APP) 2>/dev/null; true
    @# mkdir -p defaultfs/var/www/
    @# podman cp $(DOCKER_PROJECT_NAME):/var/www/html defaultfs/var/www/html 2>/dev/null; true
    @echo -e "\n======================================================================\n"

.PHONY: stop_all
stop_all:
    @echo -e "\n======================================================================\n"
    @echo -e "\n>>> ...\n"
    podman stop $(shell podman ps -a -q) 2>/dev/null; true
    podman volume prune --force 2>/dev/null; true
    @echo -e "\n======================================================================\n"

.PHONY: list
list: ## list
    @echo -e "\n======================================================================\n"
    @echo -e "\n>>> list...\n"
    podman ps -a && echo
    podman volume ls && echo
    podman images && echo
    @echo -e "\n======================================================================\n"

# .PHONY: curl
# curl: ## curl
#      @echo -e "\n======================================================================\n"
#      @echo -e "\n>>> curl...\n"
#      @# curl -x 0.0.0.0:3128 -L http://www.google.com/
#      curl -OL http://localhost:${PORT}
#      @echo -e "\n======================================================================\n"

# .PHONY: browser
# browser: ## browser
#      @echo -e "\n======================================================================\n"
#      @echo -e "\n>>> browser...\n"
#      open http://localhost:${PORT}/
#      @echo -e "\n======================================================================\n"
*EOF*
        unexpand -a -t 4 "${PROJECT_DIR:?}/${FILENAME}" >"${PROJECT_DIR:?}/${FILENAME}.tmp"
        mv "${PROJECT_DIR:?}/${FILENAME}.tmp" "${PROJECT_DIR:?}/${FILENAME}"
    fi
}

function create_helm3_app_project_makefile() {
    if [ "$#" != "0" ] && [ "$#" != "4" ] && [ "$#" != "5" ]; then
        log_e "Usage: ${FUNCNAME[0]} <SRC_ROOT> <GIT_PROVIDER : bitbucket.com | github.com | gitlab.com> <PROJECT_USER> <PROJECT_NAME> [<OFFICIAL_PROJECT>]"
        log_e "${FUNCNAME[0]} $# ${*}"
    else
        log_m "${FUNCNAME[0]} $# ${*}"
        # cd "${TOP_DIR:?}" || exit 1

        if [ "$#" == "4" ]; then
            local SRC_ROOT=${1}
            local GIT_PROVIDER=${2}
            local PROJECT_USER=${3}
            local PROJECT_NAME=${4}
            local PROJECT_DIR="${SRC_ROOT}/${PROJECT_NAME}" # "${SRC_ROOT}/${GIT_PROVIDER}/${PROJECT_USER}/${PROJECT_NAME}"
        elif [ "$#" == "5" ]; then
            local SRC_ROOT=${1}
            local GIT_PROVIDER=${2}
            local PROJECT_USER=${3}
            local PROJECT_NAME=${4}
            local PROJECT_DIR="${SRC_ROOT}/${PROJECT_NAME}" # "${SRC_ROOT}/${GIT_PROVIDER}/${PROJECT_USER}/${PROJECT_NAME}"
            local OFFICIAL_PROJECT=${5}
        fi

        cd "${PROJECT_DIR}" || exit 1

        #         local FILENAME=Makefile
        #         cat <<\*EOF* >"${PROJECT_DIR:?}/${FILENAME}"
        # *EOF*
        unexpand -a -t 4 "${PROJECT_DIR:?}/${FILENAME}" >"${PROJECT_DIR:?}/${FILENAME}.tmp"
        mv "${PROJECT_DIR:?}/${FILENAME}.tmp" "${PROJECT_DIR:?}/${FILENAME}"
    fi
}

function create_deployment_app_project_makefile() {
    if [ "$#" != "0" ] && [ "$#" != "4" ] && [ "$#" != "5" ]; then
        log_e "Usage: ${FUNCNAME[0]} <SRC_ROOT> <GIT_PROVIDER : bitbucket.com | github.com | gitlab.com> <PROJECT_USER> <PROJECT_NAME> [<OFFICIAL_PROJECT>]"
        log_e "${FUNCNAME[0]} $# ${*}"
    else
        log_m "${FUNCNAME[0]} $# ${*}"
        # cd "${TOP_DIR:?}" || exit 1

        if [ "$#" == "4" ]; then
            local SRC_ROOT=${1}
            local GIT_PROVIDER=${2}
            local PROJECT_USER=${3}
            local PROJECT_NAME=${4}
            local PROJECT_DIR="${SRC_ROOT}/${PROJECT_NAME}" # "${SRC_ROOT}/${GIT_PROVIDER}/${PROJECT_USER}/${PROJECT_NAME}"
        elif [ "$#" == "5" ]; then
            local SRC_ROOT=${1}
            local GIT_PROVIDER=${2}
            local PROJECT_USER=${3}
            local PROJECT_NAME=${4}
            local PROJECT_DIR="${SRC_ROOT}/${PROJECT_NAME}" # "${SRC_ROOT}/${GIT_PROVIDER}/${PROJECT_USER}/${PROJECT_NAME}"
            local OFFICIAL_PROJECT=${5}
        fi

        cd "${PROJECT_DIR}" || exit 1

        #         local FILENAME=Makefile
        #         cat <<\*EOF* >"${PROJECT_DIR:?}/${FILENAME}"
        # *EOF*
        unexpand -a -t 4 "${PROJECT_DIR:?}/${FILENAME}" >"${PROJECT_DIR:?}/${FILENAME}.tmp"
        mv "${PROJECT_DIR:?}/${FILENAME}.tmp" "${PROJECT_DIR:?}/${FILENAME}"
    fi
}

function create_terraform_app_project_makefile() {
    if [ "$#" != "0" ] && [ "$#" != "4" ] && [ "$#" != "5" ]; then
        log_e "Usage: ${FUNCNAME[0]} <SRC_ROOT> <GIT_PROVIDER : bitbucket.com | github.com | gitlab.com> <PROJECT_USER> <PROJECT_NAME> [<OFFICIAL_PROJECT>]"
        log_e "${FUNCNAME[0]} $# ${*}"
    else
        log_m "${FUNCNAME[0]} $# ${*}"
        # cd "${TOP_DIR:?}" || exit 1

        if [ "$#" == "4" ]; then
            local SRC_ROOT=${1}
            local GIT_PROVIDER=${2}
            local PROJECT_USER=${3}
            local PROJECT_NAME=${4}
            local PROJECT_DIR="${SRC_ROOT}/${PROJECT_NAME}" # "${SRC_ROOT}/${GIT_PROVIDER}/${PROJECT_USER}/${PROJECT_NAME}"
        elif [ "$#" == "5" ]; then
            local SRC_ROOT=${1}
            local GIT_PROVIDER=${2}
            local PROJECT_USER=${3}
            local PROJECT_NAME=${4}
            local PROJECT_DIR="${SRC_ROOT}/${PROJECT_NAME}" # "${SRC_ROOT}/${GIT_PROVIDER}/${PROJECT_USER}/${PROJECT_NAME}"
            local OFFICIAL_PROJECT=${5}
        fi

        cd "${PROJECT_DIR}" || exit 1

        #         local FILENAME=Makefile
        #         cat <<\*EOF* >"${PROJECT_DIR:?}/${FILENAME}"
        # *EOF*
        unexpand -a -t 4 "${PROJECT_DIR:?}/${FILENAME}" >"${PROJECT_DIR:?}/${FILENAME}.tmp"
        mv "${PROJECT_DIR:?}/${FILENAME}.tmp" "${PROJECT_DIR:?}/${FILENAME}"
    fi
}

function create_golang_app_project_makefile() {
    if [ "$#" != "0" ] && [ "$#" != "4" ] && [ "$#" != "5" ]; then
        log_e "Usage: ${FUNCNAME[0]} <SRC_ROOT> <GIT_PROVIDER : bitbucket.com | github.com | gitlab.com> <PROJECT_USER> <PROJECT_NAME> [<OFFICIAL_PROJECT>]"
        log_e "${FUNCNAME[0]} $# ${*}"
    else
        log_m "${FUNCNAME[0]} $# ${*}"
        # cd "${TOP_DIR:?}" || exit 1

        if [ "$#" == "4" ]; then
            local SRC_ROOT=${1}
            local GIT_PROVIDER=${2}
            local PROJECT_USER=${3}
            local PROJECT_NAME=${4}
            local PROJECT_DIR="${SRC_ROOT}/${PROJECT_NAME}" # "${SRC_ROOT}/${GIT_PROVIDER}/${PROJECT_USER}/${PROJECT_NAME}"
        elif [ "$#" == "5" ]; then
            local SRC_ROOT=${1}
            local GIT_PROVIDER=${2}
            local PROJECT_USER=${3}
            local PROJECT_NAME=${4}
            local PROJECT_DIR="${SRC_ROOT}/${PROJECT_NAME}" # "${SRC_ROOT}/${GIT_PROVIDER}/${PROJECT_USER}/${PROJECT_NAME}"
            local OFFICIAL_PROJECT=${5}
        fi

        cd "${PROJECT_DIR}" || exit 1

        local FILENAME=Makefile
        cat <<\*EOF* >"${PROJECT_DIR:?}/${FILENAME}"
# https://www.gnu.org/software/make/manual/make.html
# https://www.gnu.org/software/make/manual/html_node/Simple-Makefile.html
# TOP_DIR=$(shell dirname $(abspath $(lastword $(MAKEFILE_LIST))))
TOP_DIR=$(shell dirname $(abspath $(firstword $(MAKEFILE_LIST))))
PROJECT_TYPE=
PROJECT_NAME=$(notdir $(TOP_DIR))

# ifneq ("$(wildcard VERSION.txt)", "")
#     TAG=$(shell grep -i version VERSION.txt | cut -d '=' -f 2 | tr -d '[:space:]')
# else ifdef LATEST
#     TAG=latest
# else
#     TAG=latest
# endif

# ifneq ("$(wildcard ${HOME}/.my_libs/$(PROJECT_TYPE)/myenv)", "")
#     include ${HOME}/.my_libs/$(PROJECT_TYPE)/myenv
# else ifneq ("$(wildcard env)", "")
#     include env
# else
#     GITHUB_USER=cclhsu
#     GITHUB_USER_PASSWORD=
#     GITHUB_USER_TOKEN=
#     GITHUB_USER_EMAIL=cclhsu@yahoo.com
#     DOCKER_USER=cclhsu
#     DOCKER_PASSWORD=
# endif

##### HOWTO #####


##### ##### #####

.DEFAULT_GOAL := help

.PHONY: help
help: ## help
    @echo -e "\n======================================================================\n"
    @echo -e "\n>>> help...\n"
    @#make -rpn | sed -n -e '/^$$/ { n ; /^[^ .#][^ ]*:/ { s/:.*$$// ; p ; } ; }' | sort | awk 'BEGIN {FS = ":.*?## "}; {printf "\033[36m%-30s\033[0m %s\n", $$1, $$2}'
    @grep -E '^[a-zA-Z_-]+:.*?## .*$$' $(MAKEFILE_LIST) | sort | awk 'BEGIN {FS = ":.*?## "}; {printf "\033[36m%-30s\033[0m %s\n", $$1, $$2}'
    @echo -e "\n======================================================================\n"

.PHONY: all
all:  ## all
    @echo -e "\n======================================================================\n"
    @echo -e "\n>>> ...\n"
    make clean
    make build
    make list
    @echo -e "\n======================================================================\n"

.PHONY: lint
lint:  ## lint
    @echo -e "\n======================================================================\n"
    @echo -e "\n>>> lint...\n"
    @echo -e "\n======================================================================\n"

.PHONY: init
init: ## init
    @echo -e "\n======================================================================\n"
    @echo -e "\n>>> init...\n"
    @# mkdir src tests
    export GO111MODULE=on
    go mod init github.com/$(GITHUB_USER)/$(PROJECT_NAME)
    go mod vendor
    @echo -e "\n======================================================================\n"

.PHONY: build
build: ## build
    @echo -e "\n======================================================================\n"
    @echo -e "\n>>> build...\n"
    @# mkdir -p $(TOP_DIR)/data/bin
    go build
    @echo -e "\n======================================================================\n"

.PHONY: run
run: ## run
    @echo -e "\n======================================================================\n"
    @echo -e "\n>>> run...\n"
    $(TOP_DIR)/$(PROJECT_NAME)
    @echo -e "\n======================================================================\n"

.PHONY: test
test: ## test
    @echo -e "\n======================================================================\n"
    @echo -e "\n>>> test...\n"
    go build
    go test -v
    go test -cover
    @echo -e "\n======================================================================\n"

.PHONY: clean
clean: ## clean
    @echo -e "\n======================================================================\n"
    @echo -e "\n>>> clean...\n"
    rm -rf $(TOP_DIR)/$(PROJECT_NAME)
    rm -rf $(TOP_DIR)/data/bin
    @echo -e "\n======================================================================\n"

.PHONY: list
list:  ## list
    @echo -e "\n======================================================================\n"
    @echo -e "\n>>> list...\n"
    @echo -e "\n======================================================================\n"
*EOF*
        unexpand -a -t 4 "${PROJECT_DIR:?}/${FILENAME}" >"${PROJECT_DIR:?}/${FILENAME}.tmp"
        mv "${PROJECT_DIR:?}/${FILENAME}.tmp" "${PROJECT_DIR:?}/${FILENAME}"
    fi
}

function create_typescript_app_project_makefile() {
    if [ "$#" != "0" ] && [ "$#" != "4" ] && [ "$#" != "5" ]; then
        log_e "Usage: ${FUNCNAME[0]} <SRC_ROOT> <GIT_PROVIDER : bitbucket.com | github.com | gitlab.com> <PROJECT_USER> <PROJECT_NAME> [<OFFICIAL_PROJECT>]"
        log_e "${FUNCNAME[0]} $# ${*}"
    else
        log_m "${FUNCNAME[0]} $# ${*}"
        # cd "${TOP_DIR:?}" || exit 1

        if [ "$#" == "4" ]; then
            local SRC_ROOT=${1}
            local GIT_PROVIDER=${2}
            local PROJECT_USER=${3}
            local PROJECT_NAME=${4}
            local PROJECT_DIR="${SRC_ROOT}/${PROJECT_NAME}" # "${SRC_ROOT}/${GIT_PROVIDER}/${PROJECT_USER}/${PROJECT_NAME}"
        elif [ "$#" == "5" ]; then
            local SRC_ROOT=${1}
            local GIT_PROVIDER=${2}
            local PROJECT_USER=${3}
            local PROJECT_NAME=${4}
            local PROJECT_DIR="${SRC_ROOT}/${PROJECT_NAME}" # "${SRC_ROOT}/${GIT_PROVIDER}/${PROJECT_USER}/${PROJECT_NAME}"
            local OFFICIAL_PROJECT=${5}
        fi

        cd "${PROJECT_DIR}" || exit 1

        local FILENAME=Makefile
        cat <<\*EOF* >"${PROJECT_DIR:?}/${FILENAME}"
# https://www.gnu.org/software/make/manual/make.html
# https://www.gnu.org/software/make/manual/html_node/Simple-Makefile.html
# TOP_DIR=$(shell dirname $(abspath $(lastword $(MAKEFILE_LIST))))
TOP_DIR=$(shell dirname $(abspath $(firstword $(MAKEFILE_LIST))))
PROJECT_TYPE=
PROJECT_NAME=$(notdir $(TOP_DIR))

# ifneq ("$(wildcard VERSION.txt)", "")
#     TAG=$(shell grep -i version VERSION.txt | cut -d '=' -f 2 | tr -d '[:space:]')
# else ifdef LATEST
#     TAG=latest
# else
#     TAG=latest
# endif

# ifneq ("$(wildcard ${HOME}/.my_libs/$(PROJECT_TYPE)/myenv)", "")
#     include ${HOME}/.my_libs/$(PROJECT_TYPE)/myenv
# else ifneq ("$(wildcard env)", "")
#     include env
# else
#     GITHUB_USER=cclhsu
#     GITHUB_USER_PASSWORD=
#     GITHUB_USER_TOKEN=
#     GITHUB_USER_EMAIL=cclhsu@yahoo.com
#     DOCKER_USER=cclhsu
#     DOCKER_PASSWORD=
# endif

##### HOWTO #####


##### ##### #####

.DEFAULT_GOAL := help

.PHONY: help
help: ## help
    @echo -e "\n======================================================================\n"
    @echo -e "\n>>> help...\n"
    @#make -rpn | sed -n -e '/^$$/ { n ; /^[^ .#][^ ]*:/ { s/:.*$$// ; p ; } ; }' | sort | awk 'BEGIN {FS = ":.*?## "}; {printf "\033[36m%-30s\033[0m %s\n", $$1, $$2}'
    @grep -E '^[a-zA-Z_-]+:.*?## .*$$' $(MAKEFILE_LIST) | sort | awk 'BEGIN {FS = ":.*?## "}; {printf "\033[36m%-30s\033[0m %s\n", $$1, $$2}'
    @echo -e "\n======================================================================\n"

.PHONY: all
all:  ## all
    @echo -e "\n======================================================================\n"
    @echo -e "\n>>> ...\n"
    make clean
    make build
    make list
    @echo -e "\n======================================================================\n"

.PHONY: lint
lint:  ## lint
    @echo -e "\n======================================================================\n"
    @echo -e "\n>>> lint...\n"
    eslint --ext .ts --fix
    @echo -e "\n======================================================================\n"

.PHONY: init
init: ## init
    @echo -e "\n======================================================================\n"
    @echo -e "\n>>> init...\n"
    @# mkdir src tests
    @# sudo npm install --global typescript ts-node
    npm init -y
    tsc --init
    @echo -e "\n======================================================================\n"

.PHONY: build
build: ## build
    @echo -e "\n======================================================================\n"
    @echo -e "\n>>> build...\n"
    @# mkdir -p $(TOP_DIR)/data/bin
    tsc src/main.ts
    @echo -e "\n======================================================================\n"

.PHONY: run
run: ## run
    @echo -e "\n======================================================================\n"
    @echo -e "\n>>> run...\n"
    node src/main.js
    @echo -e "\n======================================================================\n"

.PHONY: test
test: ## test
    @echo -e "\n======================================================================\n"
    @echo -e "\n>>> test...\n"
    @# npm install typescript ts-node @types/node --save-dev
    @# sudo npm install --global chai mocha nyc jasmine jest ts-jest
    @# npm install -D chai mocha nyc @types/mocha @types/chai
    @# npm install -D nyc jasmine @types/jasmine
    @# npm install -D jest ts-jest @types/jest
    npm test
    npm run coverage
    @echo -e "\n======================================================================\n"

.PHONY: clean
clean: ## clean
    @echo -e "\n======================================================================\n"
    @echo -e "\n>>> clean...\n"
    rm -rf $(TOP_DIR)/$(PROJECT_NAME)
    rm -rf $(TOP_DIR)/data/bin
    rm -rf src/main.js package-lock.json node_modules .nyc_output
    @echo -e "\n======================================================================\n"

.PHONY: list
list:  ## list
    @echo -e "\n======================================================================\n"
    @echo -e "\n>>> list...\n"
    @echo -e "\n======================================================================\n"
*EOF*
        unexpand -a -t 4 "${PROJECT_DIR:?}/${FILENAME}" >"${PROJECT_DIR:?}/${FILENAME}.tmp"
        mv "${PROJECT_DIR:?}/${FILENAME}.tmp" "${PROJECT_DIR:?}/${FILENAME}"
    fi
}

function create_python3_app_project_makefile() {
    if [ "$#" != "0" ] && [ "$#" != "4" ] && [ "$#" != "5" ]; then
        log_e "Usage: ${FUNCNAME[0]} <SRC_ROOT> <GIT_PROVIDER : bitbucket.com | github.com | gitlab.com> <PROJECT_USER> <PROJECT_NAME> [<OFFICIAL_PROJECT>]"
        log_e "${FUNCNAME[0]} $# ${*}"
    else
        log_m "${FUNCNAME[0]} $# ${*}"
        # cd "${TOP_DIR:?}" || exit 1

        if [ "$#" == "4" ]; then
            local SRC_ROOT=${1}
            local GIT_PROVIDER=${2}
            local PROJECT_USER=${3}
            local PROJECT_NAME=${4}
            local PROJECT_DIR="${SRC_ROOT}/${PROJECT_NAME}" # "${SRC_ROOT}/${GIT_PROVIDER}/${PROJECT_USER}/${PROJECT_NAME}"
        elif [ "$#" == "5" ]; then
            local SRC_ROOT=${1}
            local GIT_PROVIDER=${2}
            local PROJECT_USER=${3}
            local PROJECT_NAME=${4}
            local PROJECT_DIR="${SRC_ROOT}/${PROJECT_NAME}" # "${SRC_ROOT}/${GIT_PROVIDER}/${PROJECT_USER}/${PROJECT_NAME}"
            local OFFICIAL_PROJECT=${5}
        fi

        cd "${PROJECT_DIR}" || exit 1

        local FILENAME=Makefile
        cat <<\*EOF* >"${PROJECT_DIR:?}/${FILENAME}"
# https://www.gnu.org/software/make/manual/make.html
# https://www.gnu.org/software/make/manual/html_node/Simple-Makefile.html
# TOP_DIR=$(shell dirname $(abspath $(lastword $(MAKEFILE_LIST))))
TOP_DIR=$(shell dirname $(abspath $(firstword $(MAKEFILE_LIST))))
PROJECT_TYPE=
PROJECT_NAME=$(notdir $(TOP_DIR))

# ifneq ("$(wildcard VERSION.txt)", "")
#     TAG=$(shell grep -i version VERSION.txt | cut -d '=' -f 2 | tr -d '[:space:]')
# else ifdef LATEST
#     TAG=latest
# else
#     TAG=latest
# endif

# ifneq ("$(wildcard ${HOME}/.my_libs/$(PROJECT_TYPE)/myenv)", "")
#     include ${HOME}/.my_libs/$(PROJECT_TYPE)/myenv
# else ifneq ("$(wildcard env)", "")
#     include env
# else
#     GITHUB_USER=cclhsu
#     GITHUB_USER_PASSWORD=
#     GITHUB_USER_TOKEN=
#     GITHUB_USER_EMAIL=cclhsu@yahoo.com
#     DOCKER_USER=cclhsu
#     DOCKER_PASSWORD=
# endif

##### HOWTO #####


##### ##### #####

.DEFAULT_GOAL := help

.PHONY: help
help: ## help
    @echo -e "\n======================================================================\n"
    @echo -e "\n>>> help...\n"
    @#make -rpn | sed -n -e '/^$$/ { n ; /^[^ .#][^ ]*:/ { s/:.*$$// ; p ; } ; }' | sort | awk 'BEGIN {FS = ":.*?## "}; {printf "\033[36m%-30s\033[0m %s\n", $$1, $$2}'
    @grep -E '^[a-zA-Z_-]+:.*?## .*$$' $(MAKEFILE_LIST) | sort | awk 'BEGIN {FS = ":.*?## "}; {printf "\033[36m%-30s\033[0m %s\n", $$1, $$2}'
    @echo -e "\n======================================================================\n"

.PHONY: all
all:  ## all
    @echo -e "\n======================================================================\n"
    @echo -e "\n>>> ...\n"
    make clean
    make build
    make list
    @echo -e "\n======================================================================\n"

.PHONY: lint
lint:  ## lint
    @echo -e "\n======================================================================\n"
    @echo -e "\n>>> lint...\n"
    @echo -e "\n======================================================================\n"

.PHONY: init
init: ## init
    @echo -e "\n======================================================================\n"
    @echo -e "\n>>> init...\n"
    @# mkdir src tests
    @echo -e "\n======================================================================\n"

.PHONY: build
build: ## build
    @echo -e "\n======================================================================\n"
    @echo -e "\n>>> build...\n"
    @# mkdir -p $(TOP_DIR)/data/bin
    @echo -e "\n======================================================================\n"

.PHONY: run
run: ## run
    @echo -e "\n======================================================================\n"
    @echo -e "\n>>> run...\n"
    @echo -e "\n======================================================================\n"

.PHONY: test
test: ## test
    @echo -e "\n======================================================================\n"
    @echo -e "\n>>> test...\n"
    @echo -e "\n======================================================================\n"

.PHONY: clean
clean: ## clean
    @echo -e "\n======================================================================\n"
    @echo -e "\n>>> clean...\n"
    rm -rf $(TOP_DIR)/$(PROJECT_NAME)
    rm -rf $(TOP_DIR)/data/bin
    @echo -e "\n======================================================================\n"

.PHONY: list
list:  ## list
    @echo -e "\n======================================================================\n"
    @echo -e "\n>>> list...\n"
    @echo -e "\n======================================================================\n"
*EOF*
        unexpand -a -t 4 "${PROJECT_DIR:?}/${FILENAME}" >"${PROJECT_DIR:?}/${FILENAME}.tmp"
        mv "${PROJECT_DIR:?}/${FILENAME}.tmp" "${PROJECT_DIR:?}/${FILENAME}"
    fi
}

function create_rust_app_project_makefile() {
    if [ "$#" != "0" ] && [ "$#" != "4" ] && [ "$#" != "5" ]; then
        log_e "Usage: ${FUNCNAME[0]} <SRC_ROOT> <GIT_PROVIDER : bitbucket.com | github.com | gitlab.com> <PROJECT_USER> <PROJECT_NAME> [<OFFICIAL_PROJECT>]"
        log_e "${FUNCNAME[0]} $# ${*}"
    else
        log_m "${FUNCNAME[0]} $# ${*}"
        # cd "${TOP_DIR:?}" || exit 1

        if [ "$#" == "4" ]; then
            local SRC_ROOT=${1}
            local GIT_PROVIDER=${2}
            local PROJECT_USER=${3}
            local PROJECT_NAME=${4}
            local PROJECT_DIR="${SRC_ROOT}/${PROJECT_NAME}" # "${SRC_ROOT}/${GIT_PROVIDER}/${PROJECT_USER}/${PROJECT_NAME}"
        elif [ "$#" == "5" ]; then
            local SRC_ROOT=${1}
            local GIT_PROVIDER=${2}
            local PROJECT_USER=${3}
            local PROJECT_NAME=${4}
            local PROJECT_DIR="${SRC_ROOT}/${PROJECT_NAME}" # "${SRC_ROOT}/${GIT_PROVIDER}/${PROJECT_USER}/${PROJECT_NAME}"
            local OFFICIAL_PROJECT=${5}
        fi

        cd "${PROJECT_DIR}" || exit 1

        local FILENAME=Makefile
        cat <<\*EOF* >"${PROJECT_DIR:?}/${FILENAME}"
# https://www.gnu.org/software/make/manual/make.html
# https://www.gnu.org/software/make/manual/html_node/Simple-Makefile.html
# TOP_DIR=$(shell dirname $(abspath $(lastword $(MAKEFILE_LIST))))
TOP_DIR=$(shell dirname $(abspath $(firstword $(MAKEFILE_LIST))))
PROJECT_TYPE=
PROJECT_NAME=$(notdir $(TOP_DIR))

# ifneq ("$(wildcard VERSION.txt)", "")
#     TAG=$(shell grep -i version VERSION.txt | cut -d '=' -f 2 | tr -d '[:space:]')
# else ifdef LATEST
#     TAG=latest
# else
#     TAG=latest
# endif

# ifneq ("$(wildcard ${HOME}/.my_libs/$(PROJECT_TYPE)/myenv)", "")
#     include ${HOME}/.my_libs/$(PROJECT_TYPE)/myenv
# else ifneq ("$(wildcard env)", "")
#     include env
# else
#     GITHUB_USER=cclhsu
#     GITHUB_USER_PASSWORD=
#     GITHUB_USER_TOKEN=
#     GITHUB_USER_EMAIL=cclhsu@yahoo.com
#     DOCKER_USER=cclhsu
#     DOCKER_PASSWORD=
# endif

##### HOWTO #####


##### ##### #####

.DEFAULT_GOAL := help

.PHONY: help
help: ## help
    @echo -e "\n======================================================================\n"
    @echo -e "\n>>> help...\n"
    @#make -rpn | sed -n -e '/^$$/ { n ; /^[^ .#][^ ]*:/ { s/:.*$$// ; p ; } ; }' | sort | awk 'BEGIN {FS = ":.*?## "}; {printf "\033[36m%-30s\033[0m %s\n", $$1, $$2}'
    @grep -E '^[a-zA-Z_-]+:.*?## .*$$' $(MAKEFILE_LIST) | sort | awk 'BEGIN {FS = ":.*?## "}; {printf "\033[36m%-30s\033[0m %s\n", $$1, $$2}'
    @echo -e "\n======================================================================\n"

.PHONY: all
all:  ## all
    @echo -e "\n======================================================================\n"
    @echo -e "\n>>> ...\n"
    make clean
    make build
    make list
    @echo -e "\n======================================================================\n"

.PHONY: lint
lint:  ## lint
    @echo -e "\n======================================================================\n"
    @echo -e "\n>>> lint...\n"
    @# rustup component add clippy
    cargo clippy --fix
    @echo -e "\n======================================================================\n"

.PHONY: init
init: ## init
    @echo -e "\n======================================================================\n"
    @echo -e "\n>>> init...\n"
    @# mkdir src tests
    cargo init
    @echo -e "\n======================================================================\n"

.PHONY: build
build: ## build
    @echo -e "\n======================================================================\n"
    @echo -e "\n>>> build...\n"
    @# mkdir -p $(TOP_DIR)/data/bin
    cargo build
    @# rustc main.rs -o $(PROJECT_NAME)
    @# rustc main.rs -o $(TOP_DIR)/data/bin/$(PROJECT_NAME)
    @echo -e "\n======================================================================\n"

.PHONY: run
run: ## run
    @echo -e "\n======================================================================\n"
    @echo -e "\n>>> run...\n"
    $(TOP_DIR)/target/debug/$(PROJECT_NAME)
    @# $(TOP_DIR)/$(PROJECT_NAME)
    @# $(TOP_DIR)/data/bin/$(PROJECT_NAME)
    @echo -e "\n======================================================================\n"

.PHONY: test
test: ## test
    @echo -e "\n======================================================================\n"
    @echo -e "\n>>> test...\n"
    cargo test
    @echo -e "\n======================================================================\n"

.PHONY: clean
clean: ## clean
    @echo -e "\n======================================================================\n"
    @echo -e "\n>>> clean...\n"
    rm -rf $(TOP_DIR)/$(PROJECT_NAME)
    rm -rf $(TOP_DIR)/data/bin
    rm -rf $(TOP_DIR)/target
    rm -rf .git .gitignore Cargo.lock Cargo.toml
    @echo -e "\n======================================================================\n"

.PHONY: list
list:  ## list
    @echo -e "\n======================================================================\n"
    @echo -e "\n>>> list...\n"
    @echo -e "\n======================================================================\n"
*EOF*
        unexpand -a -t 4 "${PROJECT_DIR:?}/${FILENAME}" >"${PROJECT_DIR:?}/${FILENAME}.tmp"
        mv "${PROJECT_DIR:?}/${FILENAME}.tmp" "${PROJECT_DIR:?}/${FILENAME}"
    fi
}

#******************************************************************************
# clean_project

function clean_project() {
    if [ "$#" != "0" ] && [ "$#" != "1" ]; then
        log_e "Usage: ${FUNCNAME[0]} <PROJECT_TYPE>"
        log_e "${FUNCNAME[0]} $# ${*}"
    else
        log_m "${FUNCNAME[0]} $# ${*}"
        cd "${TOP_DIR:?}" || exit 1

        if [ "$#" == "1" ]; then
            local DISTPROJECT_TYPERO=${1}
        fi

        case ${PROJECT_TYPE} in
            ansible_app) clean_ansible_app_project ;;
            bash_app) clean_bash_app_project ;;
            bash_deployment_app) clean_bash_deployment_app_project ;;
            bash_install_app) clean_bash_install_app_project ;;
            bash_remote_deployment_app) clean_bash_remote_deployment_app_project ;;
            docker_app) clean_docker_app_project ;;
            podman_app) clean_podman_app_project ;;
            helm3_app) clean_helm3_app_project ;;
            deployment_app) clean_deployment_app_project ;;
            terraform_app) clean_terraform_app_project ;;
            golang_app) clean_golang_app_project ;;
            typescript_app) clean_typescript_app_project ;;
            python3_app) clean_python3_app_project ;;
            rust_app) clean_rust_app_project ;;
            *) ;;
        esac
    fi
}

function clean_ansible_app_project() {
    if [ "$#" != "0" ] && [ "$#" != "4" ]; then
        log_e "Usage: ${FUNCNAME[0]} <SRC_ROOT> <GIT_PROVIDER : bitbucket.com | github.com | gitlab.com> <PROJECT_USER> <PROJECT_NAME>"
        log_e "${FUNCNAME[0]} $# ${*}"
    else
        log_m "${FUNCNAME[0]} $# ${*}"
        # cd "${TOP_DIR:?}" || exit 1

        if [ "$#" == "4" ]; then
            local SRC_ROOT=${1}
            local GIT_PROVIDER=${2}
            local PROJECT_USER=${3}
            local PROJECT_NAME=${4}
            local PROJECT_DIR="${SRC_ROOT}/${PROJECT_NAME}" # "${SRC_ROOT}/${GIT_PROVIDER}/${PROJECT_USER}/${PROJECT_NAME}"
        fi

        cd "${PROJECT_DIR}" || exit 1

        # rm -rf ${CONFIGURATION_MANAGEMENT_TOP_DIR}/{invetories,playbooks,roles}
    fi
}

function clean_bash_app_project() {
    if [ "$#" != "0" ] && [ "$#" != "4" ]; then
        log_e "Usage: ${FUNCNAME[0]} <SRC_ROOT> <GIT_PROVIDER : bitbucket.com | github.com | gitlab.com> <PROJECT_USER> <PROJECT_NAME>"
        log_e "${FUNCNAME[0]} $# ${*}"
    else
        log_m "${FUNCNAME[0]} $# ${*}"
        # cd "${TOP_DIR:?}" || exit 1

        if [ "$#" == "4" ]; then
            local SRC_ROOT=${1}
            local GIT_PROVIDER=${2}
            local PROJECT_USER=${3}
            local PROJECT_NAME=${4}
            local PROJECT_DIR="${SRC_ROOT}/${PROJECT_NAME}" # "${SRC_ROOT}/${GIT_PROVIDER}/${PROJECT_USER}/${PROJECT_NAME}"
        fi

        cd "${PROJECT_DIR}" || exit 1
    fi
}

function clean_bash_deployment_app_project() {
    if [ "$#" != "0" ] && [ "$#" != "4" ]; then
        log_e "Usage: ${FUNCNAME[0]} <SRC_ROOT> <GIT_PROVIDER : bitbucket.com | github.com | gitlab.com> <PROJECT_USER> <PROJECT_NAME>"
        log_e "${FUNCNAME[0]} $# ${*}"
    else
        log_m "${FUNCNAME[0]} $# ${*}"
        # cd "${TOP_DIR:?}" || exit 1

        if [ "$#" == "4" ]; then
            local SRC_ROOT=${1}
            local GIT_PROVIDER=${2}
            local PROJECT_USER=${3}
            local PROJECT_NAME=${4}
            local PROJECT_DIR="${SRC_ROOT}/${PROJECT_NAME}" # "${SRC_ROOT}/${GIT_PROVIDER}/${PROJECT_USER}/${PROJECT_NAME}"
        fi

        cd "${PROJECT_DIR}" || exit 1
    fi
}

function clean_bash_install_app_project() {
    if [ "$#" != "0" ] && [ "$#" != "4" ]; then
        log_e "Usage: ${FUNCNAME[0]} <SRC_ROOT> <GIT_PROVIDER : bitbucket.com | github.com | gitlab.com> <PROJECT_USER> <PROJECT_NAME>"
        log_e "${FUNCNAME[0]} $# ${*}"
    else
        log_m "${FUNCNAME[0]} $# ${*}"
        # cd "${TOP_DIR:?}" || exit 1

        if [ "$#" == "4" ]; then
            local SRC_ROOT=${1}
            local GIT_PROVIDER=${2}
            local PROJECT_USER=${3}
            local PROJECT_NAME=${4}
            local PROJECT_DIR="${SRC_ROOT}/${PROJECT_NAME}" # "${SRC_ROOT}/${GIT_PROVIDER}/${PROJECT_USER}/${PROJECT_NAME}"
        fi

        cd "${PROJECT_DIR}" || exit 1
    fi
}

function clean_bash_remote_deployment_app_project() {
    if [ "$#" != "0" ] && [ "$#" != "4" ]; then
        log_e "Usage: ${FUNCNAME[0]} <SRC_ROOT> <GIT_PROVIDER : bitbucket.com | github.com | gitlab.com> <PROJECT_USER> <PROJECT_NAME>"
        log_e "${FUNCNAME[0]} $# ${*}"
    else
        log_m "${FUNCNAME[0]} $# ${*}"
        # cd "${TOP_DIR:?}" || exit 1

        if [ "$#" == "4" ]; then
            local SRC_ROOT=${1}
            local GIT_PROVIDER=${2}
            local PROJECT_USER=${3}
            local PROJECT_NAME=${4}
            local PROJECT_DIR="${SRC_ROOT}/${PROJECT_NAME}" # "${SRC_ROOT}/${GIT_PROVIDER}/${PROJECT_USER}/${PROJECT_NAME}"
        fi

        cd "${PROJECT_DIR}" || exit 1
    fi
}

function clean_docker_app_project() {
    if [ "$#" != "0" ] && [ "$#" != "4" ]; then
        log_e "Usage: ${FUNCNAME[0]} <SRC_ROOT> <GIT_PROVIDER : bitbucket.com | github.com | gitlab.com> <PROJECT_USER> <PROJECT_NAME>"
        log_e "${FUNCNAME[0]} $# ${*}"
    else
        log_m "${FUNCNAME[0]} $# ${*}"
        # cd "${TOP_DIR:?}" || exit 1

        if [ "$#" == "4" ]; then
            local SRC_ROOT=${1}
            local GIT_PROVIDER=${2}
            local PROJECT_USER=${3}
            local PROJECT_NAME=${4}
            local PROJECT_DIR="${SRC_ROOT}/${PROJECT_NAME}" # "${SRC_ROOT}/${GIT_PROVIDER}/${PROJECT_USER}/${PROJECT_NAME}"
        fi

        cd "${PROJECT_DIR}" || exit 1
    fi
}

function clean_podman_app_project() {
    if [ "$#" != "0" ] && [ "$#" != "4" ]; then
        log_e "Usage: ${FUNCNAME[0]} <SRC_ROOT> <GIT_PROVIDER : bitbucket.com | github.com | gitlab.com> <PROJECT_USER> <PROJECT_NAME>"
        log_e "${FUNCNAME[0]} $# ${*}"
    else
        log_m "${FUNCNAME[0]} $# ${*}"
        # cd "${TOP_DIR:?}" || exit 1

        if [ "$#" == "4" ]; then
            local SRC_ROOT=${1}
            local GIT_PROVIDER=${2}
            local PROJECT_USER=${3}
            local PROJECT_NAME=${4}
            local PROJECT_DIR="${SRC_ROOT}/${PROJECT_NAME}" # "${SRC_ROOT}/${GIT_PROVIDER}/${PROJECT_USER}/${PROJECT_NAME}"
        fi

        cd "${PROJECT_DIR}" || exit 1
    fi
}

function clean_helm3_app_project() {
    if [ "$#" != "0" ] && [ "$#" != "4" ]; then
        log_e "Usage: ${FUNCNAME[0]} <SRC_ROOT> <GIT_PROVIDER : bitbucket.com | github.com | gitlab.com> <PROJECT_USER> <PROJECT_NAME>"
        log_e "${FUNCNAME[0]} $# ${*}"
    else
        log_m "${FUNCNAME[0]} $# ${*}"
        # cd "${TOP_DIR:?}" || exit 1

        if [ "$#" == "4" ]; then
            local SRC_ROOT=${1}
            local GIT_PROVIDER=${2}
            local PROJECT_USER=${3}
            local PROJECT_NAME=${4}
            local PROJECT_DIR="${SRC_ROOT}/${PROJECT_NAME}" # "${SRC_ROOT}/${GIT_PROVIDER}/${PROJECT_USER}/${PROJECT_NAME}"
        fi

        cd "${PROJECT_DIR}" || exit 1
    fi
}

function clean_deployment_app_project() {
    if [ "$#" != "0" ] && [ "$#" != "4" ]; then
        log_e "Usage: ${FUNCNAME[0]} <SRC_ROOT> <GIT_PROVIDER : bitbucket.com | github.com | gitlab.com> <PROJECT_USER> <PROJECT_NAME>"
        log_e "${FUNCNAME[0]} $# ${*}"
    else
        log_m "${FUNCNAME[0]} $# ${*}"
        # cd "${TOP_DIR:?}" || exit 1

        if [ "$#" == "4" ]; then
            local SRC_ROOT=${1}
            local GIT_PROVIDER=${2}
            local PROJECT_USER=${3}
            local PROJECT_NAME=${4}
            local PROJECT_DIR="${SRC_ROOT}/${PROJECT_NAME}" # "${SRC_ROOT}/${GIT_PROVIDER}/${PROJECT_USER}/${PROJECT_NAME}"
        fi

        cd "${PROJECT_DIR}" || exit 1
    fi
}

function clean_terraform_app_project() {
    if [ "$#" != "0" ] && [ "$#" != "4" ]; then
        log_e "Usage: ${FUNCNAME[0]} <SRC_ROOT> <GIT_PROVIDER : bitbucket.com | github.com | gitlab.com> <PROJECT_USER> <PROJECT_NAME>"
        log_e "${FUNCNAME[0]} $# ${*}"
    else
        log_m "${FUNCNAME[0]} $# ${*}"
        # cd "${TOP_DIR:?}" || exit 1

        if [ "$#" == "4" ]; then
            local SRC_ROOT=${1}
            local GIT_PROVIDER=${2}
            local PROJECT_USER=${3}
            local PROJECT_NAME=${4}
            local PROJECT_DIR="${SRC_ROOT}/${PROJECT_NAME}" # "${SRC_ROOT}/${GIT_PROVIDER}/${PROJECT_USER}/${PROJECT_NAME}"
        fi

        cd "${PROJECT_DIR}" || exit 1
    fi
}

function clean_golang_app_project() {
    if [ "$#" != "0" ] && [ "$#" != "4" ]; then
        log_e "Usage: ${FUNCNAME[0]} <SRC_ROOT> <GIT_PROVIDER : bitbucket.com | github.com | gitlab.com> <PROJECT_USER> <PROJECT_NAME>"
        log_e "${FUNCNAME[0]} $# ${*}"
    else
        log_m "${FUNCNAME[0]} $# ${*}"
        # cd "${TOP_DIR:?}" || exit 1

        if [ "$#" == "4" ]; then
            local SRC_ROOT=${1}
            local GIT_PROVIDER=${2}
            local PROJECT_USER=${3}
            local PROJECT_NAME=${4}
            local PROJECT_DIR="${SRC_ROOT}/${PROJECT_NAME}" # "${SRC_ROOT}/${GIT_PROVIDER}/${PROJECT_USER}/${PROJECT_NAME}"
        fi

        cd "${PROJECT_DIR}" || exit 1

        go clean -i -r -cache -testcache -modcache
        rm -rf bin vendor # data
    fi
}

function clean_typescript_app_project() {
    if [ "$#" != "0" ] && [ "$#" != "4" ]; then
        log_e "Usage: ${FUNCNAME[0]} <SRC_ROOT> <GIT_PROVIDER : bitbucket.com | github.com | gitlab.com> <PROJECT_USER> <PROJECT_NAME>"
        log_e "${FUNCNAME[0]} $# ${*}"
    else
        log_m "${FUNCNAME[0]} $# ${*}"
        # cd "${TOP_DIR:?}" || exit 1

        if [ "$#" == "4" ]; then
            local SRC_ROOT=${1}
            local GIT_PROVIDER=${2}
            local PROJECT_USER=${3}
            local PROJECT_NAME=${4}
            local PROJECT_DIR="${SRC_ROOT}/${PROJECT_NAME}" # "${SRC_ROOT}/${GIT_PROVIDER}/${PROJECT_USER}/${PROJECT_NAME}"
        fi

        cd "${PROJECT_DIR}" || exit 1

        go clean -i -r -cache -testcache -modcache
        rm -rf bin vendor # data
    fi
}

function clean_python3_app_project() {
    if [ "$#" != "0" ] && [ "$#" != "4" ]; then
        log_e "Usage: ${FUNCNAME[0]} <SRC_ROOT> <GIT_PROVIDER : bitbucket.com | github.com | gitlab.com> <PROJECT_USER> <PROJECT_NAME>"
        log_e "${FUNCNAME[0]} $# ${*}"
    else
        log_m "${FUNCNAME[0]} $# ${*}"
        # cd "${TOP_DIR:?}" || exit 1

        if [ "$#" == "4" ]; then
            local SRC_ROOT=${1}
            local GIT_PROVIDER=${2}
            local PROJECT_USER=${3}
            local PROJECT_NAME=${4}
            local PROJECT_DIR="${SRC_ROOT}/${PROJECT_NAME}" # "${SRC_ROOT}/${GIT_PROVIDER}/${PROJECT_USER}/${PROJECT_NAME}"
        fi

        cd "${PROJECT_DIR}" || exit 1
    fi
}

function clean_rust_app_project() {
    if [ "$#" != "0" ] && [ "$#" != "4" ]; then
        log_e "Usage: ${FUNCNAME[0]} <SRC_ROOT> <GIT_PROVIDER : bitbucket.com | github.com | gitlab.com> <PROJECT_USER> <PROJECT_NAME>"
        log_e "${FUNCNAME[0]} $# ${*}"
    else
        log_m "${FUNCNAME[0]} $# ${*}"
        # cd "${TOP_DIR:?}" || exit 1

        if [ "$#" == "4" ]; then
            local SRC_ROOT=${1}
            local GIT_PROVIDER=${2}
            local PROJECT_USER=${3}
            local PROJECT_NAME=${4}
            local PROJECT_DIR="${SRC_ROOT}/${PROJECT_NAME}" # "${SRC_ROOT}/${GIT_PROVIDER}/${PROJECT_USER}/${PROJECT_NAME}"
        fi

        cd "${PROJECT_DIR}" || exit 1

        go clean -i -r -cache -testcache -modcache
        rm -rf bin vendor # data
    fi
}

#******************************************************************************
#******************************************************************************
# Coding Test - Golang

function golang_create_project() {
    if [ "$#" != "0" ] && [ "$#" != "4" ]; then
        log_e "Usage: ${FUNCNAME[0]} <SRC_ROOT> <GIT_PROVIDER : bitbucket.com | github.com | gitlab.com> <PROJECT_USER> <PROJECT_NAME>"
        log_e "${FUNCNAME[0]} $# ${*}"
    else
        log_m "${FUNCNAME[0]} $# ${*}"
        # cd "${TOP_DIR:?}" || exit 1

        if [ "$#" == "4" ]; then
            local SRC_ROOT=${1}
            local GIT_PROVIDER=${2}
            local PROJECT_USER=${3}
            local PROJECT_NAME=${4}
            local PROJECT_DIR="${SRC_ROOT}/${PROJECT_NAME}" # "${SRC_ROOT}/${GIT_PROVIDER}/${PROJECT_USER}/${PROJECT_NAME}"
        fi

        mkdir -p ${PROJECT_DIR}
        cd "${PROJECT_DIR}" || exit 1

        cat <<\*EOF* >"${PROJECT_DIR}/main.go"
package main

// go build
// ./${PROJECT_NAME}

import (
    "fmt"
)

func HelloFunc(A []int) int {
    fmt.Printf("%v\n", A)
    return len(A)
}

func main() {
    A := []int{}
    result := HelloFunc(A)
    fmt.Printf("%v\n", result) // 0
}
*EOF*

        cat <<\*EOF* >"${PROJECT_DIR}/main_test.go"
package main

// go test -v . # -run <^TestName$>
// go test -cover . # -run <^TestName$>

import (
    "testing"
)

func TestHelloFunc(t *testing.T) {
    tests := []struct {
        name string
        A    []int
        want int
    }{
        // TODO: Add test cases.
        {
            name: "test case 1",
            A:    []int{},
            want: 0,
        },
        {
            name: "test case 2",
            A:    []int{1},
            want: 1,
        },
        {
            name: "test case 3",
            A:    []int{1, 2, 3},
            want: 3,
        },
    }
    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            if got := HelloFunc(tt.A); got != tt.want {
                t.Errorf("HelloFunc() = %v, want %v", got, tt.want)
            }
        })
    }
}

// func Test_main(t *testing.T) {
//  fmt.Println("Main Test Begin!")
//  // setup
//  tests := []struct {
//      name string
//  }{
//      // TODO: Add test cases.
//      {"Test Case Main"},
//  }
//  for _, tt := range tests {
//      t.Run(tt.name, func(t *testing.T) {
//          main()
//      })
//  }
//  // teardown
//  fmt.Println("Main Test End!")
// }
*EOF*

        export GO111MODULE=on
        go mod init github.com/${GITHUB_USER}/${PROJECT_NAME}
        go mod vendor
    fi
}

function golang_init_project() {
    if [ "$#" != "0" ] && [ "$#" != "4" ]; then
        log_e "Usage: ${FUNCNAME[0]} <SRC_ROOT> <GIT_PROVIDER : bitbucket.com | github.com | gitlab.com> <PROJECT_USER> <PROJECT_NAME>"
        log_e "${FUNCNAME[0]} $# ${*}"
    else
        log_m "${FUNCNAME[0]} $# ${*}"
        # cd "${TOP_DIR:?}" || exit 1

        if [ "$#" == "4" ]; then
            local SRC_ROOT=${1}
            local GIT_PROVIDER=${2}
            local PROJECT_USER=${3}
            local PROJECT_NAME=${4}
            local PROJECT_DIR="${SRC_ROOT}/${PROJECT_NAME}" # "${SRC_ROOT}/${GIT_PROVIDER}/${PROJECT_USER}/${PROJECT_NAME}"
        fi

        cd "${PROJECT_DIR}" || exit 1

    fi
}

function golang_build_and_run_project() {
    if [ "$#" != "0" ] && [ "$#" != "4" ]; then
        log_e "Usage: ${FUNCNAME[0]} <SRC_ROOT> <GIT_PROVIDER : bitbucket.com | github.com | gitlab.com> <PROJECT_USER> <PROJECT_NAME>"
        log_e "${FUNCNAME[0]} $# ${*}"
    else
        log_m "${FUNCNAME[0]} $# ${*}"
        # cd "${TOP_DIR:?}" || exit 1

        if [ "$#" == "4" ]; then
            local SRC_ROOT=${1}
            local GIT_PROVIDER=${2}
            local PROJECT_USER=${3}
            local PROJECT_NAME=${4}
            local PROJECT_DIR="${SRC_ROOT}/${PROJECT_NAME}" # "${SRC_ROOT}/${GIT_PROVIDER}/${PROJECT_USER}/${PROJECT_NAME}"
        fi

        cd "${PROJECT_DIR}" || exit 1

        go build
        ./${PROJECT_NAME}
    fi
}

function golang_build_and_run_test() {
    if [ "$#" != "0" ] && [ "$#" != "4" ]; then
        log_e "Usage: ${FUNCNAME[0]} <SRC_ROOT> <GIT_PROVIDER : bitbucket.com | github.com | gitlab.com> <PROJECT_USER> <PROJECT_NAME>"
        log_e "${FUNCNAME[0]} $# ${*}"
    else
        log_m "${FUNCNAME[0]} $# ${*}"
        # cd "${TOP_DIR:?}" || exit 1

        if [ "$#" == "4" ]; then
            local SRC_ROOT=${1}
            local GIT_PROVIDER=${2}
            local PROJECT_USER=${3}
            local PROJECT_NAME=${4}
            local PROJECT_DIR="${SRC_ROOT}/${PROJECT_NAME}" # "${SRC_ROOT}/${GIT_PROVIDER}/${PROJECT_USER}/${PROJECT_NAME}"
        fi

        cd "${PROJECT_DIR}" || exit 1

        go build
        go test -v
        go test -cover
    fi
}

function golang_clean_project() {
    if [ "$#" != "0" ] && [ "$#" != "4" ]; then
        log_e "Usage: ${FUNCNAME[0]} <SRC_ROOT> <GIT_PROVIDER : bitbucket.com | github.com | gitlab.com> <PROJECT_USER> <PROJECT_NAME>"
        log_e "${FUNCNAME[0]} $# ${*}"
    else
        log_m "${FUNCNAME[0]} $# ${*}"
        # cd "${TOP_DIR:?}" || exit 1

        if [ "$#" == "4" ]; then
            local SRC_ROOT=${1}
            local GIT_PROVIDER=${2}
            local PROJECT_USER=${3}
            local PROJECT_NAME=${4}
            local PROJECT_DIR="${SRC_ROOT}/${PROJECT_NAME}" # "${SRC_ROOT}/${GIT_PROVIDER}/${PROJECT_USER}/${PROJECT_NAME}"
        fi

        cd "${PROJECT_DIR}" || exit 1

        rm -rf ${PROJECT_NAME}
    fi
}

#******************************************************************************
# Coding Test - Python 3

function python3_create_project() {
    if [ "$#" != "0" ] && [ "$#" != "4" ]; then
        log_e "Usage: ${FUNCNAME[0]} <SRC_ROOT> <GIT_PROVIDER : bitbucket.com | github.com | gitlab.com> <PROJECT_USER> <PROJECT_NAME>"
        log_e "${FUNCNAME[0]} $# ${*}"
    else
        log_m "${FUNCNAME[0]} $# ${*}"
        # cd "${TOP_DIR:?}" || exit 1

        if [ "$#" == "4" ]; then
            local SRC_ROOT=${1}
            local GIT_PROVIDER=${2}
            local PROJECT_USER=${3}
            local PROJECT_NAME=${4}
            local PROJECT_DIR="${SRC_ROOT}/${PROJECT_NAME}" # "${SRC_ROOT}/${GIT_PROVIDER}/${PROJECT_USER}/${PROJECT_NAME}"
        fi

        mkdir -p ${PROJECT_DIR}
        cd "${PROJECT_DIR}" || exit 1

        cat <<\*EOF* >"${PROJECT_DIR}/__init__.py"
#!/usr/bin/env python3
# -*- coding:utf-8 -*-
*EOF*

        cat <<\*EOF* >"${PROJECT_DIR}/main.py"
#!/usr/bin/env python3
# -*- coding:utf-8 -*-

# python3 main.py

# import re
# import sys
# import math
# import random
# import os
# import collections
# import itertools


def helloFunc(A: [int]) -> int:
    return len(A)


if __name__ == '__main__':
    A = []
    result = helloFunc(A)
    print(result)  # 0
*EOF*

        cat <<\*EOF* >"${PROJECT_DIR}/test_main.py"
#!/usr/bin/env python3
# -*- coding:utf-8 -*-

# python3 -m pytest -s -v test_main.py

# import os
import pytest
from main import helloFunc


@pytest.mark.parametrize(
    "A, expected",
    [([], 0), ([1], 1), ([1, 2, 3], 3)],
)
def test_helloFunc(A: [int], expected: int):
    got = helloFunc(A)
    assert got == expected
*EOF*

    fi
}

function python3_init_project() {
    if [ "$#" != "0" ] && [ "$#" != "4" ]; then
        log_e "Usage: ${FUNCNAME[0]} <SRC_ROOT> <GIT_PROVIDER : bitbucket.com | github.com | gitlab.com> <PROJECT_USER> <PROJECT_NAME>"
        log_e "${FUNCNAME[0]} $# ${*}"
    else
        log_m "${FUNCNAME[0]} $# ${*}"
        # cd "${TOP_DIR:?}" || exit 1

        if [ "$#" == "4" ]; then
            local SRC_ROOT=${1}
            local GIT_PROVIDER=${2}
            local PROJECT_USER=${3}
            local PROJECT_NAME=${4}
            local PROJECT_DIR="${SRC_ROOT}/${PROJECT_NAME}" # "${SRC_ROOT}/${GIT_PROVIDER}/${PROJECT_USER}/${PROJECT_NAME}"
        fi

        cd "${PROJECT_DIR}" || exit 1

    fi
}

function python3_build_and_run_project() {
    if [ "$#" != "0" ] && [ "$#" != "4" ]; then
        log_e "Usage: ${FUNCNAME[0]} <SRC_ROOT> <GIT_PROVIDER : bitbucket.com | github.com | gitlab.com> <PROJECT_USER> <PROJECT_NAME>"
        log_e "${FUNCNAME[0]} $# ${*}"
    else
        log_m "${FUNCNAME[0]} $# ${*}"
        # cd "${TOP_DIR:?}" || exit 1

        if [ "$#" == "4" ]; then
            local SRC_ROOT=${1}
            local GIT_PROVIDER=${2}
            local PROJECT_USER=${3}
            local PROJECT_NAME=${4}
            local PROJECT_DIR="${SRC_ROOT}/${PROJECT_NAME}" # "${SRC_ROOT}/${GIT_PROVIDER}/${PROJECT_USER}/${PROJECT_NAME}"
        fi

        cd "${PROJECT_DIR}" || exit 1

        python3 main.py
    fi
}

function python3_build_and_run_test() {
    if [ "$#" != "0" ] && [ "$#" != "4" ]; then
        log_e "Usage: ${FUNCNAME[0]} <SRC_ROOT> <GIT_PROVIDER : bitbucket.com | github.com | gitlab.com> <PROJECT_USER> <PROJECT_NAME>"
        log_e "${FUNCNAME[0]} $# ${*}"
    else
        log_m "${FUNCNAME[0]} $# ${*}"
        # cd "${TOP_DIR:?}" || exit 1

        if [ "$#" == "4" ]; then
            local SRC_ROOT=${1}
            local GIT_PROVIDER=${2}
            local PROJECT_USER=${3}
            local PROJECT_NAME=${4}
            local PROJECT_DIR="${SRC_ROOT}/${PROJECT_NAME}" # "${SRC_ROOT}/${GIT_PROVIDER}/${PROJECT_USER}/${PROJECT_NAME}"
        fi

        cd "${PROJECT_DIR}" || exit 1

        python3 -m pytest -s -v test_main.py
    fi
}

function python3_clean_project() {
    if [ "$#" != "0" ] && [ "$#" != "4" ]; then
        log_e "Usage: ${FUNCNAME[0]} <SRC_ROOT> <GIT_PROVIDER : bitbucket.com | github.com | gitlab.com> <PROJECT_USER> <PROJECT_NAME>"
        log_e "${FUNCNAME[0]} $# ${*}"
    else
        log_m "${FUNCNAME[0]} $# ${*}"
        # cd "${TOP_DIR:?}" || exit 1

        if [ "$#" == "4" ]; then
            local SRC_ROOT=${1}
            local GIT_PROVIDER=${2}
            local PROJECT_USER=${3}
            local PROJECT_NAME=${4}
            local PROJECT_DIR="${SRC_ROOT}/${PROJECT_NAME}" # "${SRC_ROOT}/${GIT_PROVIDER}/${PROJECT_USER}/${PROJECT_NAME}"
        fi

        cd "${PROJECT_DIR}" || exit 1

        rm -rf __pycache__ .pytest_cache
    fi
}

#******************************************************************************
# Coding Test - Rust

function rust_create_project() {
    if [ "$#" != "0" ] && [ "$#" != "4" ]; then
        log_e "Usage: ${FUNCNAME[0]} <SRC_ROOT> <GIT_PROVIDER : bitbucket.com | github.com | gitlab.com> <PROJECT_USER> <PROJECT_NAME>"
        log_e "${FUNCNAME[0]} $# ${*}"
    else
        log_m "${FUNCNAME[0]} $# ${*}"
        # cd "${TOP_DIR:?}" || exit 1

        if [ "$#" == "4" ]; then
            local SRC_ROOT=${1}
            local GIT_PROVIDER=${2}
            local PROJECT_USER=${3}
            local PROJECT_NAME=${4}
            local PROJECT_DIR="${SRC_ROOT}/${PROJECT_NAME}" # "${SRC_ROOT}/${GIT_PROVIDER}/${PROJECT_USER}/${PROJECT_NAME}"
        fi

        mkdir -p ${PROJECT_DIR}/src
        cd "${PROJECT_DIR}" || exit 1

        cat <<\*EOF* >"${PROJECT_DIR}/src/main.rs"
// https://doc.rust-lang.org/rust-by-example/index.html
// https://github.com/rust-lang/book

pub fn hello_func(arr: &mut [i32]) -> usize {
   println!("{:?}", arr);
   return arr.len();
}

fn main(){
   // Print text to the console
   println!("Hello World!");

   let mut arr: [i32;0] = [0;0];
   let result = hello_func(&mut arr);
   println!("{:?}", result); // 0
}

#[cfg(test)]
mod main_tests;
*EOF*

        cat <<\*EOF* >"${PROJECT_DIR}/src/main_tests.rs"
// https://doc.rust-lang.org/cargo/commands/cargo-test.html
// https://doc.rust-lang.org/cargo/guide/tests.html
// https://doc.rust-lang.org/rust-by-example/testing/unit_testing.html
// https://doc.rust-lang.org/book/ch11-00-testing.html
// https://github.com/rust-lang/book

use super::*;

#[test]
fn test_hello_func() {
    let mut arr: [i32;0] = [0;0];
    assert_eq!(hello_func(&mut arr), 0);
}

#[test]
fn hello_func_test() {
    let mut arr: [i32;0] = [0;0];
    assert_eq!(hello_func(&mut arr), 0);
}

#[test]
#[ignore]
fn ignored_test() {
    let mut arr: [i32;0] = [0;0];
    assert_eq!(hello_func(&mut arr), 0);
}
*EOF*
    fi
}

function rust_init_project() {
    if [ "$#" != "0" ] && [ "$#" != "4" ]; then
        log_e "Usage: ${FUNCNAME[0]} <SRC_ROOT> <GIT_PROVIDER : bitbucket.com | github.com | gitlab.com> <PROJECT_USER> <PROJECT_NAME>"
        log_e "${FUNCNAME[0]} $# ${*}"
    else
        log_m "${FUNCNAME[0]} $# ${*}"
        # cd "${TOP_DIR:?}" || exit 1

        if [ "$#" == "4" ]; then
            local SRC_ROOT=${1}
            local GIT_PROVIDER=${2}
            local PROJECT_USER=${3}
            local PROJECT_NAME=${4}
            local PROJECT_DIR="${SRC_ROOT}/${PROJECT_NAME}" # "${SRC_ROOT}/${GIT_PROVIDER}/${PROJECT_USER}/${PROJECT_NAME}"
        fi

        cd "${PROJECT_DIR}" || exit 1

        cargo init
    fi
}

function rust_build_and_run_project() {
    if [ "$#" != "0" ] && [ "$#" != "4" ]; then
        log_e "Usage: ${FUNCNAME[0]} <SRC_ROOT> <GIT_PROVIDER : bitbucket.com | github.com | gitlab.com> <PROJECT_USER> <PROJECT_NAME>"
        log_e "${FUNCNAME[0]} $# ${*}"
    else
        log_m "${FUNCNAME[0]} $# ${*}"
        # cd "${TOP_DIR:?}" || exit 1

        if [ "$#" == "4" ]; then
            local SRC_ROOT=${1}
            local GIT_PROVIDER=${2}
            local PROJECT_USER=${3}
            local PROJECT_NAME=${4}
            local PROJECT_DIR="${SRC_ROOT}/${PROJECT_NAME}" # "${SRC_ROOT}/${GIT_PROVIDER}/${PROJECT_USER}/${PROJECT_NAME}"
        fi

        cd "${PROJECT_DIR}" || exit 1

        cargo build
        ${PROJECT_DIR}/target/debug/${PROJECT_NAME}
    fi
}

function rust_build_and_run_test() {
    if [ "$#" != "0" ] && [ "$#" != "4" ]; then
        log_e "Usage: ${FUNCNAME[0]} <SRC_ROOT> <GIT_PROVIDER : bitbucket.com | github.com | gitlab.com> <PROJECT_USER> <PROJECT_NAME>"
        log_e "${FUNCNAME[0]} $# ${*}"
    else
        log_m "${FUNCNAME[0]} $# ${*}"
        # cd "${TOP_DIR:?}" || exit 1

        if [ "$#" == "4" ]; then
            local SRC_ROOT=${1}
            local GIT_PROVIDER=${2}
            local PROJECT_USER=${3}
            local PROJECT_NAME=${4}
            local PROJECT_DIR="${SRC_ROOT}/${PROJECT_NAME}" # "${SRC_ROOT}/${GIT_PROVIDER}/${PROJECT_USER}/${PROJECT_NAME}"
        fi

        cd "${PROJECT_DIR}" || exit 1

        cargo build
        cargo test
    fi
}

function rust_clean_project() {
    if [ "$#" != "0" ] && [ "$#" != "4" ]; then
        log_e "Usage: ${FUNCNAME[0]} <SRC_ROOT> <GIT_PROVIDER : bitbucket.com | github.com | gitlab.com> <PROJECT_USER> <PROJECT_NAME>"
        log_e "${FUNCNAME[0]} $# ${*}"
    else
        log_m "${FUNCNAME[0]} $# ${*}"
        # cd "${TOP_DIR:?}" || exit 1

        if [ "$#" == "4" ]; then
            local SRC_ROOT=${1}
            local GIT_PROVIDER=${2}
            local PROJECT_USER=${3}
            local PROJECT_NAME=${4}
            local PROJECT_DIR="${SRC_ROOT}/${PROJECT_NAME}" # "${SRC_ROOT}/${GIT_PROVIDER}/${PROJECT_USER}/${PROJECT_NAME}"
        fi

        cd "${PROJECT_DIR}" || exit 1

        rm -rf ${PROJECT_DIR}/${PROJECT_NAME}
        rm -rf ${PROJECT_DIR}/data/bin
        rm -rf ${PROJECT_DIR}/target
        rm -rf .git .gitignore Cargo.lock Cargo.toml
    fi
}

#******************************************************************************
# Coding Test - typescript

function typescript_create_project() {
    if [ "$#" != "0" ] && [ "$#" != "4" ]; then
        log_e "Usage: ${FUNCNAME[0]} <SRC_ROOT> <GIT_PROVIDER : bitbucket.com | github.com | gitlab.com> <PROJECT_USER> <PROJECT_NAME>"
        log_e "${FUNCNAME[0]} $# ${*}"
    else
        log_m "${FUNCNAME[0]} $# ${*}"
        # cd "${TOP_DIR:?}" || exit 1

        if [ "$#" == "4" ]; then
            local SRC_ROOT=${1}
            local GIT_PROVIDER=${2}
            local PROJECT_USER=${3}
            local PROJECT_NAME=${4}
            local PROJECT_DIR="${SRC_ROOT}/${PROJECT_NAME}" # "${SRC_ROOT}/${GIT_PROVIDER}/${PROJECT_USER}/${PROJECT_NAME}"
        fi

        mkdir -p ${PROJECT_DIR}/{src,tests}
        cd "${PROJECT_DIR}" || exit 1

        cat <<\*EOF* >"${PROJECT_DIR}/src/index.html"
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>HelloWorld</title>
    <script src="main.js" defer></script>
</head>
<body>

</body>
</html>
*EOF*

        cat <<\*EOF* >"${PROJECT_DIR}/src/main.ts"
"use strict";
// https://docs.npmjs.com/creating-a-package-json-file
// https://www.typescriptlang.org/docs/handbook/tsconfig-json.html
// http://www.typescriptlang.org/
// https://www.typescriptlang.org/docs/
// https://www.tutorialspoint.com/typescript/index.htm
// https://www.typescripttutorial.net/
// https://www.tutorialsteacher.com/typescript/
// https://www.guru99.com/typescript-tutorial.html
// https://www.geeksforgeeks.org/hello-world-in-typescript-language/
// https://blog.marsen.me/2019/05/16/2019/typescript_unit_test/
// https://nodejs.dev/
// https://www.w3schools.com/nodejs/
// https://www.tutorialspoint.com/nodejs/index.htm
// https://www.w3schools.com/js/default.asp
// https://www.tutorialspoint.com/javascript/index.htm

// function hello_func(arr: Array<number>): number {
//     console.log(arr); // 0
//     return arr.length;
// }

// let message: string = 'Hello, World!';
// console.log(message);
// let arr: number[] = [];
// let result: number = hello_func(arr);
// console.log(result); // 0

export default class greet {
    static hello_func(arr: Array<number>): number {
        console.log(arr); // 0
        return arr.length;
    }
  }

let message: string = 'Hello, World!';
console.log(message);
let arr: number[] = [];
let result: number = greet.hello_func(arr);
console.log(result); // 0
*EOF*

        cat <<\*EOF* >"${PROJECT_DIR}/tests/main.test.ts"
// https://chiragrupani.medium.com/writing-unit-tests-in-typescript-d4719b8a0a40
// https://github.com/chiragrupani/TSUnitTestsSetup

import { expect } from 'chai';
import greet from '../src/main';

describe('greeting', function() {
  it('hello_func', function() {
    let arr:number[] = [];
    let result = greet.hello_func(arr);
    expect(result).equal(0);
  });
});
*EOF*

        #         cat <<*EOF* >"${PROJECT_DIR}/package.json"
        # {
        #   "name": "${PROJECT_NAME}",
        #   "version": "1.0.0",
        #   "description": "",
        #   "main": "src/main.js",
        #   "directories": {
        #     "test": "tests"
        #   },
        #   "scripts": {
        #     "test": "mocha -r ts-node/register tests/**/*.test.ts",
        #     "coverage": "nyc -r text -e .ts -x \"tests/*.test.ts\" npm run test"
        #   },
        #   "keywords": [],
        #   "author": "Clark Hsu",
        #   "license": "MIT",
        #   "devDependencies": {
        #     "@types/chai": "^4.2.21",
        #     "@types/mocha": "^9.0.0",
        #     "chai": "^4.3.4",
        #     "mocha": "^9.0.3",
        #     "nyc": "^15.1.0",
        #     "ts-node": "^10.2.0",
        #     "typescript": "^4.3.5"
        #   }
        # }
        # *EOF*

        #         cat <<\*EOF* >"${PROJECT_DIR}/tsconfig.json"
        # *EOF*

    fi
}

function typescript_init_project() {
    if [ "$#" != "0" ] && [ "$#" != "4" ]; then
        log_e "Usage: ${FUNCNAME[0]} <SRC_ROOT> <GIT_PROVIDER : bitbucket.com | github.com | gitlab.com> <PROJECT_USER> <PROJECT_NAME>"
        log_e "${FUNCNAME[0]} $# ${*}"
    else
        log_m "${FUNCNAME[0]} $# ${*}"
        # cd "${TOP_DIR:?}" || exit 1

        if [ "$#" == "4" ]; then
            local SRC_ROOT=${1}
            local GIT_PROVIDER=${2}
            local PROJECT_USER=${3}
            local PROJECT_NAME=${4}
            local PROJECT_DIR="${SRC_ROOT}/${PROJECT_NAME}" # "${SRC_ROOT}/${GIT_PROVIDER}/${PROJECT_USER}/${PROJECT_NAME}"
        fi

        cd "${PROJECT_DIR}" || exit 1

        # sudo npm install --global typescript ts-node
        npm init -y
        tsc --init # npx tsc --init
    fi
}

function typescript_build_and_run_project() {
    if [ "$#" != "0" ] && [ "$#" != "4" ]; then
        log_e "Usage: ${FUNCNAME[0]} <SRC_ROOT> <GIT_PROVIDER : bitbucket.com | github.com | gitlab.com> <PROJECT_USER> <PROJECT_NAME>"
        log_e "${FUNCNAME[0]} $# ${*}"
    else
        log_m "${FUNCNAME[0]} $# ${*}"
        # cd "${TOP_DIR:?}" || exit 1

        if [ "$#" == "4" ]; then
            local SRC_ROOT=${1}
            local GIT_PROVIDER=${2}
            local PROJECT_USER=${3}
            local PROJECT_NAME=${4}
            local PROJECT_DIR="${SRC_ROOT}/${PROJECT_NAME}" # "${SRC_ROOT}/${GIT_PROVIDER}/${PROJECT_USER}/${PROJECT_NAME}"
        fi

        cd "${PROJECT_DIR}" || exit 1

        tsc src/main.ts
        node src/main.js
    fi
}

function typescript_build_and_run_test() {
    if [ "$#" != "0" ] && [ "$#" != "4" ]; then
        log_e "Usage: ${FUNCNAME[0]} <SRC_ROOT> <GIT_PROVIDER : bitbucket.com | github.com | gitlab.com> <PROJECT_USER> <PROJECT_NAME>"
        log_e "${FUNCNAME[0]} $# ${*}"
    else
        log_m "${FUNCNAME[0]} $# ${*}"
        # cd "${TOP_DIR:?}" || exit 1

        if [ "$#" == "4" ]; then
            local SRC_ROOT=${1}
            local GIT_PROVIDER=${2}
            local PROJECT_USER=${3}
            local PROJECT_NAME=${4}
            local PROJECT_DIR="${SRC_ROOT}/${PROJECT_NAME}" # "${SRC_ROOT}/${GIT_PROVIDER}/${PROJECT_USER}/${PROJECT_NAME}"
        fi

        cd "${PROJECT_DIR}" || exit 1

        # npm install typescript ts-node @types/node --save-dev
        # sudo npm install --global chai mocha nyc jasmine jest ts-jest
        # npm install -D chai mocha nyc @types/mocha @types/chai
        # npm install -D nyc jasmine @types/jasmine
        # npm install -D jest ts-jest @types/jest
        npm test
        npm run coverage
    fi
}

function typescript_clean_project() {
    if [ "$#" != "0" ] && [ "$#" != "4" ]; then
        log_e "Usage: ${FUNCNAME[0]} <SRC_ROOT> <GIT_PROVIDER : bitbucket.com | github.com | gitlab.com> <PROJECT_USER> <PROJECT_NAME>"
        log_e "${FUNCNAME[0]} $# ${*}"
    else
        log_m "${FUNCNAME[0]} $# ${*}"
        # cd "${TOP_DIR:?}" || exit 1

        if [ "$#" == "4" ]; then
            local SRC_ROOT=${1}
            local GIT_PROVIDER=${2}
            local PROJECT_USER=${3}
            local PROJECT_NAME=${4}
            local PROJECT_DIR="${SRC_ROOT}/${PROJECT_NAME}" # "${SRC_ROOT}/${GIT_PROVIDER}/${PROJECT_USER}/${PROJECT_NAME}"
        fi

        cd "${PROJECT_DIR}" || exit 1

        rm -rf src/main.js package-lock.json node_modules .nyc_output
    fi
}

#******************************************************************************
#******************************************************************************
# requirements

function install_requirements() {
    if [ "$#" != "0" ]; then
        log_e "Usage: ${FUNCNAME[0]} <ARGS>"
        log_e "${FUNCNAME[0]} $# ${*}"
    else
        log_m "${FUNCNAME[0]} $# ${*}"
        cd "${TOP_DIR:?}" || exit 1

        case ${PLATFORM} in
            aws | azure | gcp) ;;
            libvirt) ;;
            openstack) ;;
            vmware | vsphere) ;;
            *) ;;
        esac

        case ${DISTRO} in
            alpine) ;;
            alma-linux | arch-linux | chromeos | coreos | gentoo | hyperiotos | oracle-linux | photonos | rocky-linux) ;;
            centos | fedora | rhel | debian | raspios | ubuntu | opensuse-leap | opensuse-tumbleweed | sles) ;;
            rancher-harvester | rancher-k3os | rancher-os) ;;
            cirros) ;;
            macos | macosx) ;;
            microsoft) ;;
            *) ;;
        esac

        case ${PROJECT_TYPE} in
            *) ;;
        esac

        case ${DEPLOYMENT_TYPE} in
            *) ;;
        esac

        set_packages_by_distribution
        if [ "${REQUIRED_PACKAGES}" != "" ]; then
            add_key_repo "${REQUIRED_PACKAGES_REPO_URL}" "${REQUIRED_PACKAGES_REPO_NAME}" "${REQUIRED_PACKAGES_KEY_URL}"
            echo -e "\n>>> Install packages: ${REQUIRED_PACKAGES}...\n"
            ${INSTALL_PACKAGE} ${REQUIRED_PACKAGES}
        fi
    fi
}

function uninstall_requirements() {
    if [ "$#" != "0" ]; then
        log_e "Usage: ${FUNCNAME[0]} <ARGS>"
        log_e "${FUNCNAME[0]} $# ${*}"
    else
        log_m "${FUNCNAME[0]} $# ${*}"
        cd "${TOP_DIR:?}" || exit 1

        case ${PLATFORM} in
            aws | azure | gcp) ;;
            libvirt) ;;
            openstack) ;;
            vmware | vsphere) ;;
            *) ;;
        esac

        case ${DISTRO} in
            alpine) ;;
            alma-linux | arch-linux | chromeos | coreos | gentoo | hyperiotos | oracle-linux | photonos | rocky-linux) ;;
            centos | fedora | rhel | debian | raspios | ubuntu | opensuse-leap | opensuse-tumbleweed | sles) ;;
            rancher-harvester | rancher-k3os | rancher-os) ;;
            cirros) ;;
            macos | macosx) ;;
            microsoft) ;;
            *) ;;
        esac

        case ${PROJECT_TYPE} in
            *) ;;
        esac

        case ${DEPLOYMENT_TYPE} in
            *) ;;
        esac

        set_packages_by_distribution
        if [ "${REQUIRED_PACKAGES}" != "" ]; then
            echo -e "\n>>> Uninstall packages: ${REQUIRED_PACKAGES}...\n"
            ${UNINSTALL_PACKAGE} ${REQUIRED_PACKAGES}
            delete_key_repo "${REQUIRED_PACKAGES_REPO_URL}" "${REQUIRED_PACKAGES_REPO_NAME}" "${REQUIRED_PACKAGES_KEY_URL}"
        fi
    fi
}

#******************************************************************************
#******************************************************************************
# install

function install() {
    if [ "$#" != "0" ] && [ "$#" != "8" ]; then
        log_e "Usage: ${FUNCNAME[0]} <GITHUB_USER> <GITHUB_PROJECT> <PACKAGE_VERSION> <PROJECT_BIN> <OS> <ARCH> <USER_BIN> <INSTALL_METHOD>"
        log_e "${FUNCNAME[0]} $# ${*}"
    else
        log_m "${FUNCNAME[0]} $# ${*}"
        cd "${TOP_DIR:?}" || exit 1

        mkdir -p "${TOP_DIR:?}/data/bin"

        if [ "$#" == "8" ]; then
            local GITHUB_USER=${1}
            local GITHUB_PROJECT=${2}
            local PACKAGE_VERSION=${3}
            local PROJECT_BIN=${4}
            local OS=${5}
            local ARCH=${6}
            local USER_BIN=${7}
            local INSTALL_METHOD=${8}
        fi

        # # https://github.com/{{ GITHUB_USER }}/{{ GITHUB_PROJECT }}/releases
        # # https://github.com/{{ GITHUB_USER }}/{{ GITHUB_PROJECT }}/releases/download/{{ PACKAGE_VERSION }}/${PROJECT_BIN}
        # local GITHUB_USER= #
        # local GITHUB_PROJECT=${PROJECT_BIN}
        # local PACKAGE_VERSION=$(curl -s "https://api.github.com/repos/${GITHUB_USER}/${GITHUB_PROJECT}/releases/latest" | jq --raw-output .tag_name) # v0.0.1 | 1.0.0 | stable | latest
        # local OS=$(uname -s | tr A-Z a-z)                                                                                          # darwin | linux
        # local ARCH=$(uname -m | sed -e 's/x86_64/amd64/' -e 's/aarch64/arm64/')                                                                             # amd64 | x86_64
        # echo ">>> Package: ${DISTRO}/${GITHUB_USER}/${GITHUB_PROJECT}/${PACKAGE_VERSION}/${PROJECT_BIN}-${OS}-${ARCH}"

        if [ "${INSTALL_METHOD}" == "bin" ] && [ ! -e "${USER_BIN}/${PROJECT_BIN}" ]; then
            install_by_bin # "${GITHUB_USER}" "${GITHUB_PROJECT}" "${PACKAGE_VERSION}" "${PROJECT_BIN}" "${OS}" "${ARCH}" "${USER_BIN}"
        elif [ "${INSTALL_METHOD}" == "tar" ] && [ ! -e "${USER_BIN}/${PROJECT_BIN}" ]; then
            install_by_tar # "${GITHUB_USER}" "${GITHUB_PROJECT}" "${PACKAGE_VERSION}" "${PROJECT_BIN}" "${OS}" "${ARCH}" "${USER_BIN}"
        elif [ "${INSTALL_METHOD}" == "bz2" ] && [ ! -e "${USER_BIN}/${PROJECT_BIN}" ]; then
            install_by_bz2 # "${GITHUB_USER}" "${GITHUB_PROJECT}" "${PACKAGE_VERSION}" "${PROJECT_BIN}" "${OS}" "${ARCH}" "${USER_BIN}"
        elif [ "${INSTALL_METHOD}" == "xz" ] && [ ! -e "${USER_BIN}/${PROJECT_BIN}" ]; then
            install_by_xz # "${GITHUB_USER}" "${GITHUB_PROJECT}" "${PACKAGE_VERSION}" "${PROJECT_BIN}" "${OS}" "${ARCH}" "${USER_BIN}"
        elif [ "${INSTALL_METHOD}" == "zstd" ] && [ ! -e "${USER_BIN}/${PROJECT_BIN}" ]; then
            install_by_zstd # "${GITHUB_USER}" "${GITHUB_PROJECT}" "${PACKAGE_VERSION}" "${PROJECT_BIN}" "${OS}" "${ARCH}" "${USER_BIN}"
        elif [ "${INSTALL_METHOD}" == "rar" ] && [ ! -e "${USER_BIN}/${PROJECT_BIN}" ]; then
            install_by_rar # "${GITHUB_USER}" "${GITHUB_PROJECT}" "${PACKAGE_VERSION}" "${PROJECT_BIN}" "${OS}" "${ARCH}" "${USER_BIN}"
        elif [ "${INSTALL_METHOD}" == "zip" ] && [ ! -e "${USER_BIN}/${PROJECT_BIN}" ]; then
            install_by_zip # "${GITHUB_USER}" "${GITHUB_PROJECT}" "${PACKAGE_VERSION}" "${PROJECT_BIN}" "${OS}" "${ARCH}" "${USER_BIN}"
        elif [ "${INSTALL_METHOD}" == "script" ] && [ ! -e "${USER_BIN}/${PROJECT_BIN}" ]; then
            install_by_script # "${PROJECT_BIN}" "${INSTALL_SCRIPT_URL}"
        elif [ "${INSTALL_METHOD}" == "snap" ] && [ ! -e "${USER_BIN}/${PROJECT_BIN}" ]; then
            install_by_snap # "${INSTALL_PACKAGE}" "${PACKAGES}" "${PACKAGES_REPO_URL}" "${PACKAGES_REPO_NAME}" "${PACKAGES_KEY_URL}"
        elif [ "${INSTALL_METHOD}" == "rpm" ] && [ ! -e "${USER_BIN}/${PROJECT_BIN}" ]; then
            install_by_rpm # "${INSTALL_PACKAGE}" "${PACKAGES}" "${PACKAGES_REPO_URL}" "${PACKAGES_REPO_NAME}" "${PACKAGES_KEY_URL}"
        elif [ "${INSTALL_METHOD}" == "go" ] && [ ! -e "${HOME}/go/bin/${PROJECT_GO_BIN}" ]; then
            install_by_go # "${PROJECT_GO_URL}" "${PROJECT_GO_BIN}"
        elif [ "${INSTALL_METHOD}" == "npm" ] && [ ! -e "${HOME}/.nvm/versions/node/$(node --version)/bin/${PROJECT_NPM_BIN}" ]; then
            install_by_npm # "${PROJECT_NPM_BIN}"
        # elif [ "${INSTALL_METHOD}" == "pip" ] && [ ! -e "${USER_BIN}/${PROJECT_PYTHON_BIN}" ]; then
        elif [ "${INSTALL_METHOD}" == "pip" ]; then
            install_by_pip # "${PROJECT_PYTHON_PACKAGES}" "${PROJECT_PYTHON_BIN}"
        elif [ "${INSTALL_METHOD}" == "docker" ]; then
            install_by_docker # "${DOCKER_USER}" "${DOCKER_PROJECT}" "${DOCKER_TAG}"
        elif [ "${INSTALL_METHOD}" == "podman" ]; then
            install_by_podman # "${PODMAN_USER}" "${PODMAN_PROJECT}" "${DOCKER_TAG}"
        fi
        get_version
        # systemctl status ${PROJECT_BIN}
    fi
}

function install_by_bin() {
    if [ "$#" != "0" ] && [ "$#" != "7" ]; then
        log_e "Usage: ${FUNCNAME[0]} [<GITHUB_USER> <GITHUB_PROJECT> <PACKAGE_VERSION> <PROJECT_BIN> <OS> <ARCH> <USER_BIN>]"
        log_e "${FUNCNAME[0]} $# ${*}"
    else
        log_m "${FUNCNAME[0]} $# ${*}"
        # cd "${TOP_DIR:?}" || exit 1

        if [ "$#" == "7" ]; then
            local GITHUB_USER=${1}
            local GITHUB_PROJECT=${2}
            local PACKAGE_VERSION=${3}
            local PROJECT_BIN=${4}
            local OS=${5}
            local ARCH=${6}
            local USER_BIN=${7}
        fi

        if [ ! -e "${TOP_DIR:?}/data/bin/${PROJECT_BIN}" ]; then
            # curl -L "https://github.com/${GITHUB_USER}/${GITHUB_PROJECT}/releases/download/${PACKAGE_VERSION}/${PROJECT_BIN}_${OS}-${ARCH}" -o "${TOP_DIR:?}/data/bin/${PROJECT_BIN}"
            echo -e "\n >>> Downloading ${PROJECT_BIN_URL}...\n"
            curl -L "${PROJECT_BIN_URL}" -o "${TOP_DIR:?}/data/bin/${PROJECT_BIN}"
        fi

        cd "${TOP_DIR:?}/data/bin" || exit 1
        chmod +x "${TOP_DIR:?}/data/bin/${PROJECT_BIN}"
        sudo mv "${TOP_DIR:?}/data/bin/${PROJECT_BIN}" "${USER_BIN}"
        # sudo install "${TOP_DIR:?}/data/bin/${PROJECT_BIN}" "${USER_BIN}"
    fi
}

function move_bin_to_user_bin() {
    if [ "$#" != "0" ] && [ "$#" != "7" ]; then
        log_e "Usage: ${FUNCNAME[0]} [<GITHUB_USER> <GITHUB_PROJECT> <PACKAGE_VERSION> <PROJECT_BIN> <OS> <ARCH> <USER_BIN>]"
        log_e "${FUNCNAME[0]} $# ${*}"
    else
        log_m "${FUNCNAME[0]} $# ${*}"
        # cd "${TOP_DIR:?}" || exit 1

        if [ -e "${TOP_DIR:?}/data/bin/${PROJECT_BIN}-${PACKAGE_VERSION}-${OS}-${ARCH}" ]; then
            local PROJECT_BIN_DIR="${PROJECT_BIN}-${PACKAGE_VERSION}-${OS}-${ARCH}"
        elif [ -e "${TOP_DIR:?}/data/bin/${PROJECT_BIN}-${PACKAGE_VERSION}" ]; then
            local PROJECT_BIN_DIR="${PROJECT_BIN}-${PACKAGE_VERSION}"
        elif [ -e "${TOP_DIR:?}/data/bin/${PROJECT_BIN}-${OS}-${ARCH}" ]; then
            local PROJECT_BIN_DIR="${PROJECT_BIN}-${OS}-${ARCH}"
        elif [ -e "${TOP_DIR:?}/data/bin/${PROJECT_BIN}-$(echo ${PACKAGE_VERSION} | sed 's/v//g')-${OS}-${ARCH}" ]; then
            local PROJECT_BIN_DIR="${PROJECT_BIN}-$(echo ${PACKAGE_VERSION} | sed 's/v//g')-${OS}-${ARCH}"
        elif [ -e "${TOP_DIR:?}/data/bin/${PROJECT_BIN}-$(echo ${PACKAGE_VERSION} | sed 's/v//g')" ]; then
            local PROJECT_BIN_DIR="${PROJECT_BIN}-$(echo ${PACKAGE_VERSION} | sed 's/v//g')"
        elif [ -e "${TOP_DIR:?}/data/bin/${PROJECT_BIN}_${PACKAGE_VERSION}_${OS}_${ARCH}" ]; then
            local PROJECT_BIN_DIR="${PROJECT_BIN}_${PACKAGE_VERSION}_${OS}_${ARCH}"
        elif [ -e "${TOP_DIR:?}/data/bin/${PROJECT_BIN}_${PACKAGE_VERSION}" ]; then
            local PROJECT_BIN_DIR="${PROJECT_BIN}_${PACKAGE_VERSION}"
        elif [ -e "${TOP_DIR:?}/data/bin/${PROJECT_BIN}_${OS}_${ARCH}" ]; then
            local PROJECT_BIN_DIR="${PROJECT_BIN}_${OS}_${ARCH}"
        elif [ -e "${TOP_DIR:?}/data/bin/${PROJECT_BIN}_$(echo ${PACKAGE_VERSION} | sed 's/v//g')_${OS}_${ARCH}" ]; then
            local PROJECT_BIN_DIR="${PROJECT_BIN}_$(echo ${PACKAGE_VERSION} | sed 's/v//g')_${OS}_${ARCH}"
        elif [ -e "${TOP_DIR:?}/data/bin/${PROJECT_BIN}_$(echo ${PACKAGE_VERSION} | sed 's/v//g')" ]; then
            local PROJECT_BIN_DIR="${PROJECT_BIN}_$(echo ${PACKAGE_VERSION} | sed 's/v//g')"
        else
            local PROJECT_BIN_DIR=""
            ls -alh "${TOP_DIR:?}/data/bin"
        fi

        if [ -f "${TOP_DIR:?}/data/bin/${PROJECT_BIN_DIR}" ]; then
            chmod +x "${TOP_DIR:?}/data/bin/${PROJECT_BIN_DIR}"
            sudo mv "${TOP_DIR:?}/data/bin/${PROJECT_BIN_DIR}" "${USER_BIN}/${PROJECT_BIN}"
        elif [ -f "${TOP_DIR:?}/data/bin/${PROJECT_BIN_DIR}/bin/${PROJECT_BIN}" ]; then
            chmod +x "${TOP_DIR:?}/data/bin/${PROJECT_BIN_DIR}/bin/${PROJECT_BIN}"
            sudo mv "${TOP_DIR:?}/data/bin/${PROJECT_BIN_DIR}/bin/${PROJECT_BIN}" "${USER_BIN}/${PROJECT_BIN}"
        else
            chmod +x "${TOP_DIR:?}/data/bin/${PROJECT_BIN_DIR}/${PROJECT_BIN}"
            sudo mv "${TOP_DIR:?}/data/bin/${PROJECT_BIN_DIR}/${PROJECT_BIN}" "${USER_BIN}"
            # sudo install "${TOP_DIR:?}/data/bin/${PROJECT_BIN_DIR}/${PROJECT_BIN}" "${USER_BIN}"
        fi

        if [ -f "${TOP_DIR:?}/data/bin/${PROJECT_BIN_DIR}ctl" ]; then
            chmod +x "${TOP_DIR:?}/data/bin/${PROJECT_BIN_DIR}ctl"
            sudo mv "${TOP_DIR:?}/data/bin/${PROJECT_BIN_DIR}ctl" "${USER_BIN}/${PROJECT_BIN}ctl"
        elif [ -f "${TOP_DIR:?}/data/bin/${PROJECT_BIN_DIR}/bin/${PROJECT_BIN}ctl" ]; then
            chmod +x "${TOP_DIR:?}/data/bin/${PROJECT_BIN_DIR}/bin/${PROJECT_BIN}ctl"
            sudo mv "${TOP_DIR:?}/data/bin/${PROJECT_BIN_DIR}/bin/${PROJECT_BIN}ctl" "${USER_BIN}/${PROJECT_BIN}ctl"
        elif [ -e "${TOP_DIR:?}/data/bin/${PROJECT_BIN_DIR}/${PROJECT_BIN}ctl" ]; then
            chmod +x "${TOP_DIR:?}/data/bin/${PROJECT_BIN_DIR}/${PROJECT_BIN}ctl"
            sudo mv "${TOP_DIR:?}/data/bin/${PROJECT_BIN_DIR}/${PROJECT_BIN}ctl" "${USER_BIN}ctl"
            # sudo install "${TOP_DIR:?}/data/bin/${PROJECT_BIN_DIR}/${PROJECT_BIN}ctl" "${USER_BIN}ctl"
        fi
    fi
}

function install_by_tar() {
    if [ "$#" != "0" ] && [ "$#" != "7" ]; then
        log_e "Usage: ${FUNCNAME[0]} [<GITHUB_USER> <GITHUB_PROJECT> <PACKAGE_VERSION> <PROJECT_BIN> <OS> <ARCH> <USER_BIN>]"
        log_e "${FUNCNAME[0]} $# ${*}"
    else
        log_m "${FUNCNAME[0]} $# ${*}"
        # cd "${TOP_DIR:?}" || exit 1

        if [ "$#" == "7" ]; then
            local GITHUB_USER=${1}
            local GITHUB_PROJECT=${2}
            local PACKAGE_VERSION=${3}
            local PROJECT_BIN=${4}
            local OS=${5}
            local ARCH=${6}
            local USER_BIN=${7}
        fi

        if [ ! -e "${TOP_DIR:?}/data/bin/${PROJECT_BIN}-${PACKAGE_VERSION}-${OS}-${ARCH}.tar.gz" ]; then
            # curl -L "https://github.com/${GITHUB_USER}/${GITHUB_PROJECT}/releases/download/${PACKAGE_VERSION}/${PROJECT_BIN}-${PACKAGE_VERSION}-${OS}-${ARCH}.tar.gz" -o "${TOP_DIR:?}/data/bin/${PROJECT_BIN}-${PACKAGE_VERSION}-${OS}-${ARCH}.tar.gz"
            echo -e "\n >>> Downloading ${PROJECT_TAR_URL}...\n"
            curl -L "${PROJECT_TAR_URL}" -o "${TOP_DIR:?}/data/bin/${PROJECT_BIN}-${PACKAGE_VERSION}-${OS}-${ARCH}.tar.gz"
        fi

        cd "${TOP_DIR:?}/data/bin" || exit 1
        tar zxfv "${PROJECT_BIN}-${PACKAGE_VERSION}-${OS}-${ARCH}.tar.gz"
        # tar xzvf "${PROJECT_BIN}-${PACKAGE_VERSION}-${OS}-${ARCH}.tar.gz" -C "${TOP_DIR:?}/data/bin" --strip-components=1
        # sudo tar xzvf "${PROJECT_BIN}-${PACKAGE_VERSION}-${OS}-${ARCH}.tar.gz" -C "${USER_BIN}"
        # sudo tar xzvf "${PROJECT_BIN}-${PACKAGE_VERSION}-${OS}-${ARCH}.tar.gz" -C "${USER_LOCAL_BIN}"

        move_bin_to_user_bin # "${GITHUB_USER}" "${GITHUB_PROJECT}" "${PACKAGE_VERSION}" "${PROJECT_BIN}" "${OS}" "${ARCH}" "${USER_BIN}"

        rm -rf "${TOP_DIR:?}/data/bin/${PROJECT_BIN}-${PACKAGE_VERSION}-${OS}-${ARCH}.tar.gz" "${TOP_DIR:?}/data/bin/${PROJECT_BIN_DIR}"
    fi
}

function install_by_bz2() {
    if [ "$#" != "0" ] && [ "$#" != "7" ]; then
        log_e "Usage: ${FUNCNAME[0]} [<GITHUB_USER> <GITHUB_PROJECT> <PACKAGE_VERSION> <PROJECT_BIN> <OS> <ARCH> <USER_BIN>]"
        log_e "${FUNCNAME[0]} $# ${*}"
    else
        log_m "${FUNCNAME[0]} $# ${*}"
        # cd "${TOP_DIR:?}" || exit 1

        if [ "$#" == "7" ]; then
            local GITHUB_USER=${1}
            local GITHUB_PROJECT=${2}
            local PACKAGE_VERSION=${3}
            local PROJECT_BIN=${4}
            local OS=${5}
            local ARCH=${6}
            local USER_BIN=${7}
        fi

        if [ ! -e "${TOP_DIR:?}/data/bin/${PROJECT_BIN}-${PACKAGE_VERSION}-${OS}-${ARCH}.bz2" ]; then
            # curl -L "https://github.com/${GITHUB_USER}/${GITHUB_PROJECT}/releases/download/${PACKAGE_VERSION}/${PROJECT_BIN}-${PACKAGE_VERSION}-${OS}-${ARCH}.bz2" -o "${TOP_DIR:?}/data/bin/${PROJECT_BIN}-${PACKAGE_VERSION}-${OS}-${ARCH}.bz2"
            echo -e "\n >>> Downloading ${PROJECT_BZ2_URL}...\n"
            curl -L "${PROJECT_BZ2_URL}" -o "${TOP_DIR:?}/data/bin/${PROJECT_BIN}-${PACKAGE_VERSION}-${OS}-${ARCH}.bz2"
        fi

        cd "${TOP_DIR:?}/data/bin" || exit 1
        bzip2 -d "${PROJECT_BIN}-${PACKAGE_VERSION}-${OS}-${ARCH}.bz2"

        move_bin_to_user_bin # "${GITHUB_USER}" "${GITHUB_PROJECT}" "${PACKAGE_VERSION}" "${PROJECT_BIN}" "${OS}" "${ARCH}" "${USER_BIN}"

        rm -rf "${TOP_DIR:?}/data/bin/${PROJECT_BIN}-${PACKAGE_VERSION}-${OS}-${ARCH}.bz2" "${TOP_DIR:?}/data/bin/${PROJECT_BIN_DIR}"
    fi
}

function install_by_xz() {
    if [ "$#" != "0" ] && [ "$#" != "7" ]; then
        log_e "Usage: ${FUNCNAME[0]} [<GITHUB_USER> <GITHUB_PROJECT> <PACKAGE_VERSION> <PROJECT_BIN> <OS> <ARCH> <USER_BIN>]"
        log_e "${FUNCNAME[0]} $# ${*}"
    else
        log_m "${FUNCNAME[0]} $# ${*}"
        # cd "${TOP_DIR:?}" || exit 1

        if [ "$#" == "7" ]; then
            local GITHUB_USER=${1}
            local GITHUB_PROJECT=${2}
            local PACKAGE_VERSION=${3}
            local PROJECT_BIN=${4}
            local OS=${5}
            local ARCH=${6}
            local USER_BIN=${7}
        fi

        if [ ! -e "${TOP_DIR:?}/data/bin/${PROJECT_BIN}-${PACKAGE_VERSION}-${OS}-${ARCH}.xz" ]; then
            # curl -L "https://github.com/${GITHUB_USER}/${GITHUB_PROJECT}/releases/download/${PACKAGE_VERSION}/${PROJECT_BIN}-${PACKAGE_VERSION}-${OS}-${ARCH}.xz" -o "${TOP_DIR:?}/data/bin/${PROJECT_BIN}-${PACKAGE_VERSION}-${OS}-${ARCH}.xz"
            echo -e "\n >>> Downloading ${PROJECT_XZ_URL}...\n"
            curl -L "${PROJECT_XZ_URL}" -o "${TOP_DIR:?}/data/bin/${PROJECT_BIN}-${PACKAGE_VERSION}-${OS}-${ARCH}.tar.xz"
        fi

        cd "${TOP_DIR:?}/data/bin" || exit 1
        tar Jxvf "${PROJECT_BIN}-${PACKAGE_VERSION}-${OS}-${ARCH}.tar.xz"
        # tar Jxvf "${PROJECT_BIN}-${PACKAGE_VERSION}-${OS}-${ARCH}.tar.xz" -C "${TOP_DIR:?}/data/bin" --strip-components=1
        # sudo tar Jxvf "${PROJECT_BIN}-${PACKAGE_VERSION}-${OS}-${ARCH}.tar.xz" -C "${USER_BIN}"
        # sudo tar Jxvf "${PROJECT_BIN}-${PACKAGE_VERSION}-${OS}-${ARCH}.tar.xz" -C "${USER_LOCAL_BIN}"

        move_bin_to_user_bin # "${GITHUB_USER}" "${GITHUB_PROJECT}" "${PACKAGE_VERSION}" "${PROJECT_BIN}" "${OS}" "${ARCH}" "${USER_BIN}"

        rm -rf "${TOP_DIR:?}/data/bin/${PROJECT_BIN}-${PACKAGE_VERSION}-${OS}-${ARCH}.xz" "${TOP_DIR:?}/data/bin/${PROJECT_BIN_DIR}"
    fi
}

# https://github.com/facebook/zstd
# https://www.systutorials.com/docs/linux/man/1-zstd/
function install_by_zstd() {
    if [ "$#" != "0" ] && [ "$#" != "7" ]; then
        log_e "Usage: ${FUNCNAME[0]} [<GITHUB_USER> <GITHUB_PROJECT> <PACKAGE_VERSION> <PROJECT_BIN> <OS> <ARCH> <USER_BIN>]"
        log_e "${FUNCNAME[0]} $# ${*}"
    else
        log_m "${FUNCNAME[0]} $# ${*}"
        # cd "${TOP_DIR:?}" || exit 1

        if [ "$#" == "7" ]; then
            local GITHUB_USER=${1}
            local GITHUB_PROJECT=${2}
            local PACKAGE_VERSION=${3}
            local PROJECT_BIN=${4}
            local OS=${5}
            local ARCH=${6}
            local USER_BIN=${7}
        fi

        if [ ! -e "${TOP_DIR:?}/data/bin/${PROJECT_BIN}-${PACKAGE_VERSION}-${OS}-${ARCH}.tar.zst" ]; then
            # curl -L "https://github.com/${GITHUB_USER}/${GITHUB_PROJECT}/releases/download/${PACKAGE_VERSION}/${PROJECT_BIN}-${PACKAGE_VERSION}-${OS}-${ARCH}.tar.zst" -o "${TOP_DIR:?}/data/bin/${PROJECT_BIN}-${PACKAGE_VERSION}-${OS}-${ARCH}.tar.zst"
            echo -e "\n >>> Downloading ${PROJECT_ZST_URL}...\n"
            curl -L "${PROJECT_ZST_URL}" -o "${TOP_DIR:?}/data/bin/${PROJECT_BIN}-${PACKAGE_VERSION}-${OS}-${ARCH}.tar.zst"
        fi

        cd "${TOP_DIR:?}/data/bin" || exit 1
        zstd --decompress "${PROJECT_BIN}-${PACKAGE_VERSION}-${OS}-${ARCH}.tar.zst"
        # zstd --decompress "${TOP_DIR:?}/data/bin" --decompress "${PROJECT_BIN}-${PACKAGE_VERSION}-${OS}-${ARCH}.tar.zst"
        # zstd --decompress "${USER_BIN}" --decompress "${PROJECT_BIN}-${PACKAGE_VERSION}-${OS}-${ARCH}.tar.zst"
        # zstd --decompress "${USER_LOCAL_BIN}" --decompress "${PROJECT_BIN}-${PACKAGE_VERSION}-${OS}-${ARCH}.tar.zst"

        move_bin_to_user_bin # "${GITHUB_USER}" "${GITHUB_PROJECT}" "${PACKAGE_VERSION}" "${PROJECT_BIN}" "${OS}" "${ARCH}" "${USER_BIN}"

        rm -rf "${TOP_DIR:?}/data/bin/${PROJECT_BIN}-${PACKAGE_VERSION}-${OS}-${ARCH}.tar.zst" "${TOP_DIR:?}/data/bin/${PROJECT_BIN_DIR}"
    fi
}

function install_by_rar() {
    if [ "$#" != "0" ] && [ "$#" != "7" ]; then
        log_e "Usage: ${FUNCNAME[0]} [<GITHUB_USER> <GITHUB_PROJECT> <PACKAGE_VERSION> <PROJECT_BIN> <OS> <ARCH> <USER_BIN>]"
        log_e "${FUNCNAME[0]} $# ${*}"
    else
        log_m "${FUNCNAME[0]} $# ${*}"
        # cd "${TOP_DIR:?}" || exit 1

        if [ "$#" == "7" ]; then
            local GITHUB_USER=${1}
            local GITHUB_PROJECT=${2}
            local PACKAGE_VERSION=${3}
            local PROJECT_BIN=${4}
            local OS=${5}
            local ARCH=${6}
            local USER_BIN=${7}
        fi

        if [ ! -e "${TOP_DIR:?}/data/bin/${PROJECT_BIN}-${PACKAGE_VERSION}-${OS}-${ARCH}.rar" ]; then
            # curl -L "https://github.com/${GITHUB_USER}/${GITHUB_PROJECT}/releases/download/${PACKAGE_VERSION}/${PROJECT_BIN}-${PACKAGE_VERSION}-${OS}-${ARCH}.rar" -o "${TOP_DIR:?}/data/bin/${PROJECT_BIN}-${PACKAGE_VERSION}-${OS}-${ARCH}.rar"
            echo -e "\n >>> Downloading ${PROJECT_ZIP_URL}...\n"
            curl -L "${PROJECT_ZIP_URL}" -o "${TOP_DIR:?}/data/bin/${PROJECT_BIN}-${PACKAGE_VERSION}-${OS}-${ARCH}.rar"
        fi

        cd "${TOP_DIR:?}/data/bin" || exit 1
        unrar x "${PROJECT_BIN}-${PACKAGE_VERSION}-${OS}-${ARCH}.rar"

        move_bin_to_user_bin # "${GITHUB_USER}" "${GITHUB_PROJECT}" "${PACKAGE_VERSION}" "${PROJECT_BIN}" "${OS}" "${ARCH}" "${USER_BIN}"

        rm -rf "${TOP_DIR:?}/data/bin/${PROJECT_BIN}-${PACKAGE_VERSION}-${OS}-${ARCH}.rar" "${TOP_DIR:?}/data/bin/${PROJECT_BIN_DIR}"
    fi
}

function install_by_zip() {
    if [ "$#" != "0" ] && [ "$#" != "7" ]; then
        log_e "Usage: ${FUNCNAME[0]} [<GITHUB_USER> <GITHUB_PROJECT> <PACKAGE_VERSION> <PROJECT_BIN> <OS> <ARCH> <USER_BIN>]"
        log_e "${FUNCNAME[0]} $# ${*}"
    else
        log_m "${FUNCNAME[0]} $# ${*}"
        # cd "${TOP_DIR:?}" || exit 1

        if [ "$#" == "7" ]; then
            local GITHUB_USER=${1}
            local GITHUB_PROJECT=${2}
            local PACKAGE_VERSION=${3}
            local PROJECT_BIN=${4}
            local OS=${5}
            local ARCH=${6}
            local USER_BIN=${7}
        fi

        if [ ! -e "${TOP_DIR:?}/data/bin/${PROJECT_BIN}-${PACKAGE_VERSION}-${OS}-${ARCH}.zip" ]; then
            # curl -L "https://github.com/${GITHUB_USER}/${GITHUB_PROJECT}/releases/download/${PACKAGE_VERSION}/${PROJECT_BIN}-${PACKAGE_VERSION}-${OS}-${ARCH}.zip" -o "${TOP_DIR:?}/data/bin/${PROJECT_BIN}-${PACKAGE_VERSION}-${OS}-${ARCH}.zip"
            echo -e "\n >>> Downloading ${PROJECT_ZIP_URL}...\n"
            curl -L "${PROJECT_ZIP_URL}" -o "${TOP_DIR:?}/data/bin/${PROJECT_BIN}-${PACKAGE_VERSION}-${OS}-${ARCH}.zip"
        fi

        cd "${TOP_DIR:?}/data/bin" || exit 1
        unzip "${PROJECT_BIN}-${PACKAGE_VERSION}-${OS}-${ARCH}.zip"

        move_bin_to_user_bin # "${GITHUB_USER}" "${GITHUB_PROJECT}" "${PACKAGE_VERSION}" "${PROJECT_BIN}" "${OS}" "${ARCH}" "${USER_BIN}"

        rm -rf "${TOP_DIR:?}/data/bin/${PROJECT_BIN}-${PACKAGE_VERSION}-${OS}-${ARCH}.zip" "${TOP_DIR:?}/data/bin/${PROJECT_BIN_DIR}"
    fi
}

function install_by_script() {
    if [ "$#" != "0" ] && [ "$#" != "2" ]; then
        log_e "Usage: ${FUNCNAME[0]} [<PROJECT_BIN> <INSTALL_SCRIPT_URL>]"
        log_e "${FUNCNAME[0]} $# ${*}"
    else
        log_m "${FUNCNAME[0]} $# ${*}"
        # cd "${TOP_DIR:?}" || exit 1

        if [ "$#" == "2" ]; then
            local PROJECT_BIN=${1}
            local INSTALL_SCRIPT_URL=${2}
        fi

        if [ ! -e "${TOP_DIR:?}/data/bin/install.sh" ]; then
            echo -e "\n >>> Downloading ${INSTALL_SCRIPT_URL}...\n"
            curl -L "${INSTALL_SCRIPT_URL}" -o "${TOP_DIR:?}/data/bin/install.sh"
            chmod +x "${TOP_DIR:?}/data/bin/install.sh"
        fi
        ${TOP_DIR:?}/data/bin/install.sh ${INSTALL_SCRIPT_RUN_PARAMETERS}

        while [ $(which ${PROJECT_BIN} 2>/dev/null | wc -l) == 0 ]; do
            echo "looping..."
            sleep 5
        done
        sleep 1

        rm -rf "${TOP_DIR:?}/data/bin/install.sh"
    fi
}

function install_by_snap() {
    if [ "$#" != "0" ] && [ "$#" != "5" ]; then
        log_e "Usage: ${FUNCNAME[0]} [<INSTALL_PACKAGE> <PACKAGES> <PACKAGES_REPO_URL> <PACKAGES_REPO_NAME> <PACKAGES_KEY_URL>]"
        log_e "${FUNCNAME[0]} $# ${*}"
    else
        log_m "${FUNCNAME[0]} $# ${*}"
        # cd "${TOP_DIR:?}" || exit 1

        if [ "$#" == "5" ]; then
            local INSTALL_PACKAGE=${1}
            local PACKAGES=${2}
            local PACKAGES_REPO_URL=${3}
            local PACKAGES_REPO_NAME=${4}
            local PACKAGES_KEY_URL=${5}
        fi

        case ${DISTRO} in
            alpine) ;;
            alma-linux | arch-linux | chromeos | coreos | gentoo | hyperiotos | oracle-linux | photonos | rocky-linux) ;;
            centos | fedora | rhel | debian | raspios | ubuntu) ;;
            opensuse-leap | opensuse-tumbleweed | sles) ;;
            rancher-harvester | rancher-k3os | rancher-os) ;;
            cirros) ;;
            macos | macosx) ;;
            microsoft) ;;
            *) ;;
        esac

        set_packages_by_distribution
        if [ "${PACKAGES}" != "" ]; then
            add_key_repo "${PACKAGES_REPO_URL}" "${PACKAGES_REPO_NAME}" "${PACKAGES_KEY_URL}"
            echo -e "\n>>> Install packages: ${PACKAGES}...\n"
            sudo zypper dist-upgrade --from snappy
            sudo snap install ${PACKAGES} --classic
        fi
    fi
}

function install_by_rpm() {
    if [ "$#" != "0" ] && [ "$#" != "5" ]; then
        log_e "Usage: ${FUNCNAME[0]} [<INSTALL_PACKAGE> <PACKAGES> <PACKAGES_REPO_URL> <PACKAGES_REPO_NAME> <PACKAGES_KEY_URL>]"
        log_e "${FUNCNAME[0]} $# ${*}"
    else
        log_m "${FUNCNAME[0]} $# ${*}"
        # cd "${TOP_DIR:?}" || exit 1

        if [ "$#" == "5" ]; then
            local INSTALL_PACKAGE=${1}
            local PACKAGES=${2}
            local PACKAGES_REPO_URL=${3}
            local PACKAGES_REPO_NAME=${4}
            local PACKAGES_KEY_URL=${5}
        fi

        case ${DISTRO} in
            alpine) ;;
            alma-linux | arch-linux | chromeos | coreos | gentoo | hyperiotos | oracle-linux | photonos | rocky-linux) ;;
            centos | fedora | rhel | debian | raspios | ubuntu) ;;
            opensuse-leap | opensuse-tumbleweed | sles)
                # local SLES_VERSION=15.3
                # local SLES_SP_VERSION=SP2
                # local CAASP_VERSION=4.5
                # ${ADD_REPO} http://updates.suse.de/SUSE/Products/SUSE-CAASP/4.5/x86_64/product/ SUSE_Products_SUSE-CaaSP_${CAASP_VERSION}_x86_64                     # SUSE_Products_SUSE-CaaSP_${CAASP_VERSION}_x86_64
                # ${ADD_REPO} http://updates.suse.de/SUSE/Updates/SUSE-CAASP/${CAASP_VERSION}/x86_64/update/SUSE:Updates:SUSE-CAASP:${CAASP_VERSION}:x86_64.repo       # SUSE_Updates_SUSE-CAASP_${CAASP_VERSION}_x86_64
                # ${ADD_REPO} http://updates.suse.de/SUSE/Updates/SLE-Module-Public-Cloud/15-SP1/x86_64/update/SUSE:Updates:SLE-Module-Public-Cloud:15-SP1:x86_64.repo # SUSE_Updates_SLE-Module-Public-Cloud_15-SP1_x86_64
                # local LEAP_VERSION=openSUSE_Leap_15.3
                # ${ADD_REPO} https://download.opensuse.org/repositories/devel:/gcc/${openSUSE_Leap_15.3}/                #
                # ${ADD_REPO} http://download.opensuse.org/repositories/devel:/languages:/go/${openSUSE_Leap_15.3}/       #
                # ${ADD_REPO} https://download.opensuse.org/repositories/devel:/languages:/nodejs/${openSUSE_Leap_15.3}/  #
                # ${ADD_REPO} http://download.opensuse.org/repositories/devel:/languages:/python/${openSUSE_Leap_15.3}/   #
                # ${ADD_REPO} http://download.opensuse.org/repositories/devel:/languages:/rust/${openSUSE_Leap_15.3}/     #
                # local SLES_VERSION=SLE_15_SP2
                # ${ADD_REPO} https://download.opensuse.org/repositories/Virtualization/#{SLES_VERSION}/                  #
                # ${REPO_UPDATE}
                ;;
            rancher-harvester | rancher-k3os | rancher-os) ;;
            cirros) ;;
            macos | macosx) ;;
            microsoft) ;;
            *) ;;
        esac

        set_packages_by_distribution
        if [ "${PACKAGES}" != "" ]; then
            add_key_repo "${PACKAGES_REPO_URL}" "${PACKAGES_REPO_NAME}" "${PACKAGES_KEY_URL}"
            echo -e "\n>>> Install packages: ${PACKAGES}...\n"
            ${INSTALL_PACKAGE} ${PACKAGES}
        fi
    fi
}

# function install_by_dmg() {
#     if [ "$#" != "0" ] && [ "$#" != "7" ]; then
#         log_e "Usage: ${FUNCNAME[0]} [<GITHUB_USER> <GITHUB_PROJECT> <PACKAGE_VERSION> <PROJECT_BIN> <OS> <ARCH> <USER_BIN>]"
#     else
#         log_m "${FUNCNAME[0]} $# ${*}"
#         # cd "${TOP_DIR:?}" || exit 1

#         if [ "$#" == "7" ]; then
#             local GITHUB_USER=${1}
#             local GITHUB_PROJECT=${2}
#             local PACKAGE_VERSION=${3}
#             local PROJECT_BIN=${4}
#             local OS=${5}
#             local ARCH=${6}
#             local USER_BIN=${7}
#         fi

#         if [ ! -e "${TOP_DIR:?}/data/bin/${PROJECT_BIN}-${PACKAGE_VERSION}-${OS}-${ARCH}.dmg" ]; then
#             echo -e "\n >>> Downloading ${PROJECT_DMG_URL}...\n"
#             curl -L "${PROJECT_DMG_URL}" -o "${TOP_DIR:?}/data/bin/${PROJECT_BIN}-${PACKAGE_VERSION}-${OS}-${ARCH}.dmg"
#         fi

#         cd "${TOP_DIR:?}/data/bin" || exit 1
#         unzip "${PROJECT_BIN}-${PACKAGE_VERSION}-${OS}-${ARCH}.dmg"

#         move_bin_to_user_bin # "${GITHUB_USER}" "${GITHUB_PROJECT}" "${PACKAGE_VERSION}" "${PROJECT_BIN}" "${OS}" "${ARCH}" "${USER_BIN}"

#         rm -rf "${TOP_DIR:?}/data/bin/${PROJECT_BIN}-${PACKAGE_VERSION}-${OS}-${ARCH}.dmg" "${TOP_DIR:?}/data/bin/${PROJECT_BIN_DIR}"
#     fi
# }

function install_by_go() {
    if [ "$#" != "0" ] && [ "$#" != "2" ]; then
        log_e "Usage: ${FUNCNAME[0]} [<PROJECT_GO_URL> <PROJECT_GO_BIN>] [<PACKAGE_VERSION>]"
        log_e "${FUNCNAME[0]} $# ${*}"
    else
        log_m "${FUNCNAME[0]} $# ${*}"
        # cd "${TOP_DIR:?}" || exit 1

        if [ "$#" == "2" ]; then
            local PROJECT_GO_URL=${1}
            local PROJECT_GO_BIN=${2}
        fi

        # export GOPATH=${HOME}/go
        # export PATH="${PATH}:$(go env GOPATH)/bin"

        if [ ! -e "${HOME}/go/bin/${PROJECT_GO_BIN}" ]; then
            GO111MODULE=on go get -v ${PROJECT_GO_URL}
            # GO111MODULE=on go get -v ${PROJECT_GO_URL}@${PACKAGE_VERSION}
        else
            GO111MODULE=on go get -v -u ${PROJECT_GO_URL}
            # GO111MODULE=on go get -v -u ${PROJECT_GO_URL}@${PACKAGE_VERSION}
        fi

        ls "${HOME}/go/bin/${PROJECT_GO_BIN}"
        ${PROJECT_GO_BIN} version
    fi
}

function install_by_npm() {
    if [ "$#" != "0" ] && [ "$#" != "1" ]; then
        log_e "Usage: ${FUNCNAME[0]} [<PROJECT_NPM_BIN>]"
        log_e "${FUNCNAME[0]} $# ${*}"
    else
        log_m "${FUNCNAME[0]} $# ${*}"
        # cd "${TOP_DIR:?}" || exit 1

        if [ "$#" == "1" ]; then
            local PROJECT_NPM_BIN=${1}
        fi

        if [ ! -e "${HOME}/.nvm/versions/node/$(node --version)/bin/${PROJECT_NPM_BIN}" ]; then
            sudo npm install --global ${PROJECT_NPM_BIN}
            # sudo npm install --global --unsafe-perm ${PROJECT_NPM_BIN} #--verbose
        else
            if [ "${SAVED_DEP}" == "prod" ]; then
                npm install --save ${PROJECT_NPM_BIN} @types/${PROJECT_NPM_BIN}
            elif [ "${SAVED_DEP}" == "dev" ]; then
                npm install --save-dev ${PROJECT_NPM_BIN} @types/${PROJECT_NPM_BIN}
            else
                npm install ${PROJECT_NPM_BIN} @types/${PROJECT_NPM_BIN}
            fi
        fi

        # echo ${PASSWORD} | sudo chown -R $(whoami) ${HOME}/.npm
        # echo ${PASSWORD} | sudo chmod -R 755 /usr/local/lib/node_modules/

        ls "${HOME}/.nvm/versions/node/$(node --version)/bin/${PROJECT_NPM_BIN}"
        ${PROJECT_NPM_BIN} --version
    fi
}

function install_by_pip() {
    if [ "$#" != "0" ] && [ "$#" != "2" ]; then
        log_e "Usage: ${FUNCNAME[0]} [<PROJECT_PYTHON_PACKAGES> <PROJECT_PYTHON_BIN>]"
        log_e "${FUNCNAME[0]} $# ${*}"
    else
        log_m "${FUNCNAME[0]} $# ${*}"
        # cd "${TOP_DIR:?}" || exit 1

        if [ "$#" == "2" ]; then
            local PROJECT_PYTHON_PACKAGES=${1}
            local PROJECT_PYTHON_BIN=${2}
        fi

        # if [ ! -e "${USER_BIN}/${PROJECT_PYTHON_BIN}" ]; then
        #     # https://docs.ansible.com/ansible/latest/installation_guide/intro_installation.html#id27
        #     # sudo pip3 install --upgrade --ignore-installed pip3
        #     sudo pip3 install --upgrade --ignore-installed ${PROJECT_PYTHON_PACKAGES}
        #     # pip3 install --user --upgrade ${PROJECT_PYTHON_PACKAGES}
        #     # ${INSTALL_PACKAGE} ${PROJECT_PYTHON_PACKAGES}
        # fi
        sudo pip3 install --upgrade --ignore-installed ${PROJECT_PYTHON_PACKAGES}

        # ls "${USER_BIN}/${1}"
        ${PROJECT_PYTHON_BIN} --version
    fi
}

function install_by_docker() {
    if [ "$#" != "0" ] && [ "$#" != "3" ]; then
        log_e "Usage: ${FUNCNAME[0]} <DOCKER_USER> <DOCKER_PROJECT> <DOCKER_TAG>"
        log_e "${FUNCNAME[0]} $# ${*}"
    else
        log_m "${FUNCNAME[0]} $# ${*}"
        cd "${TOP_DIR:?}" || exit 1

        if [ "$#" == "3" ]; then
            local DOCKER_USER=${1}    # ${GITHUB_USER}
            local DOCKER_PROJECT=${2} # ${GITHUB_PROJECT}
            local DOCKER_TAG=${3}     # latest | latest-alpine | v0.0.1
        fi

        docker pull ${DOCKER_USER}/${DOCKER_PROJECT}:${DOCKER_TAG}
    fi
}

function install_by_podman() {
    if [ "$#" != "0" ] && [ "$#" != "3" ]; then
        log_e "Usage: ${FUNCNAME[0]} <PODMAN_USER> <PODMAN_PROJECT> <PODMAN_TAG>"
        log_e "${FUNCNAME[0]} $# ${*}"
    else
        log_m "${FUNCNAME[0]} $# ${*}"
        cd "${TOP_DIR:?}" || exit 1

        if [ "$#" == "3" ]; then
            local PODMAN_USER=${1}    # ${GITHUB_USER}
            local PODMAN_PROJECT=${2} # ${GITHUB_PROJECT}
            local DOCKER_TAG=${3}     # latest | latest-alpine | v0.0.1
        fi

        podman pull ${PODMAN_USER}/${PODMAN_PROJECT}:${DOCKER_TAG}
    fi
}

#******************************************************************************
# dotfile and completion

function install_dotfiles() {
    if [ "$#" != "0" ]; then
        log_e "Usage: ${FUNCNAME[0]} <ARGS>"
    else
        log_m "${FUNCNAME[0]}" # ${*}

        if ! grep -q \.alias ${HOME}/.bashrc; then
            # echo 'test -s ${HOME}/.alias && . ${HOME}/.alias || true' >> ${HOME}/.bashrc
            echo '[[ $PS1 && -f ${HOME}/.alias ]] && source ${HOME}/.alias || true' >>${HOME}/.bashrc
        elif ! grep -q \.alias ${HOME}/.bash_profile; then
            # echo 'test -s ${HOME}/.alias && . ${HOME}/.alias || true' >> ${HOME}/.bash_profile
            echo '[[ $PS1 && -f ${HOME}/.alias ]] && source ${HOME}/.alias || true' >>${HOME}/.bash_profile
        fi

        # local DOT_FILES="alias tmux tmate"
        local DOT_FILES="alias"
        for DOT_FILE in ${DOT_FILES[*]}; do
            if [ -e "{MYDOT}/${DOT_FILE}_dotfile.conf" ]; then
                cp "${MYDOT}/${DOT_FILE}_dotfile.conf" "${HOME}/.${DOT_FILE}"
            fi
        done
    fi
}

function install_completion() {
    if [ "$#" != "0" ]; then
        log_e "Usage: ${FUNCNAME[0]} <ARGS>"
    else
        log_m "${FUNCNAME[0]}" # ${*}

        if ! grep -q bash_completion ${HOME}/.bashrc; then
            echo '[[ $PS1 && -f /usr/share/bash-completion/bash_completion ]] && source /usr/share/bash-completion/bash_completion || true' >>${HOME}/.bashrc
        elif ! grep -q bash_completion ${HOME}/.bash_profile; then
            echo '[[ $PS1 && -f /usr/local/etc/bash_completion ]] && source /usr/local/etc/bash_completion || true' >>${HOME}/.bash_profile
        fi

        cp ${MYCOMPLETION}/bash/*.bash ${BASH_COMPLETION_D}/
    fi
}

#******************************************************************************
# update

function update() {
    if [ "$#" != "0" ] && [ "$#" != "8" ]; then
        log_e "Usage: ${FUNCNAME[0]} <GITHUB_USER> <GITHUB_PROJECT> <PACKAGE_VERSION> <PROJECT_BIN> <OS> <ARCH> <USER_BIN> <INSTALL_METHOD>"
        log_e "${FUNCNAME[0]} $# ${*}"
    else
        log_m "${FUNCNAME[0]} $# ${*}"
        # cd "${TOP_DIR:?}" || exit 1

        # local PROJECT_BIN= #
        # local INSTALL_METHOD= #

        # case ${INSTALL_METHOD} in
        #     bin | tar | zip)             #
        #         update_by_bin_tar_zip # "${PROJECT_BIN}" "${USER_BIN}"
        #         ;;
        #     script)
        #         update_by_script # "${PKILL_SCRIPT_URL}" "${UNINSTALL_SCRIPT_URL}" "${PROJECT_BIN}"
        #         ;;
        #     snap)
        #         update_by_snap # "${UNINSTALL_PACKAGE}" "${PACKAGES}" "${PACKAGES_REPO_URL}" "${PACKAGES_REPO_NAME}" "${PACKAGES_KEY_URL}"
        #         ;;
        #     rpm)
        #         update_by_rpm # "${UNINSTALL_PACKAGE}" "${PACKAGES}" "${PACKAGES_REPO_URL}" "${PACKAGES_REPO_NAME}" "${PACKAGES_KEY_URL}"
        #         ;;
        #     go)
        #         update_by_go # "${PROJECT_GO_URL}" "${PROJECT_GO_BIN}"
        #         ;;
        #     npm)
        #         # update_by_npm # "${PROJECT_NPM_BIN}"
        #         npm update -g
        #         ;;
        #     pip)
        #         update_by_pip # "${PROJECT_PYTHON_PACKAGES}" "${PROJECT_PYTHON_BIN}"
        #         ;;
        #     docker)
        #         update_by_docker # "${DOCKER_USER}" "${DOCKER_PROJECT}" "${DOCKER_TAG}"
        #         ;;
        #     podman)
        #         update_by_podman # "${PODMAN_USER}" "${PODMAN_PROJECT}" "${DOCKER_TAG}"
        #         ;;
        #     *) ;;
        # esac

        bash -c "${REPO_UPDATE}"
        bash -c "${CLEAN_CACHE}"
    fi
}

#******************************************************************************
# upgrade

function upgrade() {
    if [ "$#" != "0" ] && [ "$#" != "8" ]; then
        log_e "Usage: ${FUNCNAME[0]} <GITHUB_USER> <GITHUB_PROJECT> <PACKAGE_VERSION> <PROJECT_BIN> <OS> <ARCH> <USER_BIN> <INSTALL_METHOD>"
        log_e "${FUNCNAME[0]} $# ${*}"
    else
        log_m "${FUNCNAME[0]} $# ${*}"
        # cd "${TOP_DIR:?}" || exit 1

        # local PROJECT_BIN= #
        # local INSTALL_METHOD= #

        # case ${INSTALL_METHOD} in
        #     bin | tar | zip)             #
        #         upgrade_by_bin_tar_zip # "${PROJECT_BIN}" "${USER_BIN}"
        #         ;;
        #     script)
        #         upgrade_by_script # "${PKILL_SCRIPT_URL}" "${UNINSTALL_SCRIPT_URL}" "${PROJECT_BIN}"
        #         ;;
        #     snap)
        #         upgrade_by_snap # "${UNINSTALL_PACKAGE}" "${PACKAGES}" "${PACKAGES_REPO_URL}" "${PACKAGES_REPO_NAME}" "${PACKAGES_KEY_URL}"
        #         ;;
        #     rpm)
        #         upgrade_by_rpm # "${UNINSTALL_PACKAGE}" "${PACKAGES}" "${PACKAGES_REPO_URL}" "${PACKAGES_REPO_NAME}" "${PACKAGES_KEY_URL}"
        #         ;;
        #     go)
        #         upgrade_by_go # "${PROJECT_GO_URL}" "${PROJECT_GO_BIN}"
        #         ;;
        #     npm)
        #         upgrade_by_npm # "${PROJECT_NPM_BIN}"
        #         ;;
        #     pip)
        #         upgrade_by_pip # "${PROJECT_PYTHON_PACKAGES}" "${PROJECT_PYTHON_BIN}"
        #         ;;
        #     docker)
        #         upgrade_by_docker # "${DOCKER_USER}" "${DOCKER_PROJECT}" "${DOCKER_TAG}"
        #         ;;
        #     podman)
        #         upgrade_by_podman # "${PODMAN_USER}" "${PODMAN_PROJECT}" "${DOCKER_TAG}"
        #         ;;
        #     *) ;;
        # esac

        bash -c "${UPGRADE_PACKAGE}"
        bash -c "${CLEAN_CACHE}"
    fi
}

#******************************************************************************
# uninstall

function uninstall() {
    if [ "$#" != "0" ]; then
        log_e "Usage: ${FUNCNAME[0]} <ARGS>"
        log_e "${FUNCNAME[0]} $# ${*}"
    else
        log_m "${FUNCNAME[0]} $# ${*}"
        # cd "${TOP_DIR:?}" || exit 1

        # local PROJECT_BIN= #
        # local INSTALL_METHOD= #

        case ${INSTALL_METHOD} in
            bin | tar | zip)             #
                uninstall_by_bin_tar_zip # "${PROJECT_BIN}" "${USER_BIN}"
                ;;
            script)
                uninstall_by_script # "${PKILL_SCRIPT_URL}" "${UNINSTALL_SCRIPT_URL}" "${PROJECT_BIN}"
                ;;
            snap)
                uninstall_by_snap # "${UNINSTALL_PACKAGE}" "${PACKAGES}" "${PACKAGES_REPO_URL}" "${PACKAGES_REPO_NAME}" "${PACKAGES_KEY_URL}"
                ;;
            rpm)
                uninstall_by_rpm # "${UNINSTALL_PACKAGE}" "${PACKAGES}" "${PACKAGES_REPO_URL}" "${PACKAGES_REPO_NAME}" "${PACKAGES_KEY_URL}"
                ;;
            go)
                uninstall_by_go # "${PROJECT_GO_URL}" "${PROJECT_GO_BIN}"
                ;;
            npm)
                uninstall_by_npm # "${PROJECT_NPM_BIN}"
                ;;
            pip)
                uninstall_by_pip # "${PROJECT_PYTHON_PACKAGES}" "${PROJECT_PYTHON_BIN}"
                ;;
            docker)
                uninstall_by_docker # "${DOCKER_USER}" "${DOCKER_PROJECT}" "${DOCKER_TAG}"
                ;;
            podman)
                uninstall_by_podman # "${PODMAN_USER}" "${PODMAN_PROJECT}" "${DOCKER_TAG}"
                ;;
            *) ;;
        esac
    fi
}

function uninstall_by_bin_tar_zip() {
    if [ "$#" != "0" ] && [ "$#" != "2" ]; then
        log_e "Usage: ${FUNCNAME[0]} [<PROJECT_BIN> <USER_BIN>]"
        log_e "${FUNCNAME[0]} $# ${*}"
    else
        log_m "${FUNCNAME[0]} $# ${*}"
        # cd "${TOP_DIR:?}" || exit 1

        if [ "$#" == "2" ]; then
            local PROJECT_BIN=${1}
            local USER_BIN=${2}
        fi

        # local PROJECT_BIN= #
        if [ $(which ${PROJECT_BIN} 2>/dev/null | wc -l) == 1 ]; then
            sudo rm -f "$(which ${PROJECT_BIN})"
            # ls -alh "${USER_BIN}/${PROJECT_BIN}"
        fi

        if [ $(which ${PROJECT_BIN}ctl 2>/dev/null | wc -l) == 1 ]; then
            sudo rm -f "$(which ${PROJECT_BIN})ctl"
            # ls -alh "${USER_BIN}/${PROJECT_BIN}ctl"
        fi

        if [ -e "${HOME}/.${PROJECT_BIN}" ]; then
            sudo rm -f "${HOME}/.${PROJECT_BIN}/${PROJECT_BIN}" 2>/dev/null && ls "${HOME}/.${PROJECT_BIN}"
            sudo rm -f "${HOME}/.${PROJECT_BIN}/bin/${PROJECT_BIN}" 2>/dev/null
            sudo rm -f "${HOME}/.${PROJECT_BIN}/plugins/${PROJECT_BIN}" 2>/dev/null
        fi

        if [ -e "${HOME}/.${PROJECT_BIN}.d" ]; then
            sudo rm -f "${HOME}/.${PROJECT_BIN}.d/${PROJECT_BIN}" 2>/dev/null && ls "${HOME}/.${PROJECT_BIN}.d"
            sudo rm -f "${HOME}/.${PROJECT_BIN}.d/bin/${PROJECT_BIN}" 2>/dev/null
            sudo rm -f "${HOME}/.${PROJECT_BIN}.d/plugins/${PROJECT_BIN}" 2>/dev/null
        fi
    fi
}

function uninstall_by_script() {
    if [ "$#" != "0" ] && [ "$#" != "3" ]; then
        log_e "Usage: ${FUNCNAME[0]} [<PKILL_SCRIPT_URL> <UNINSTALL_SCRIPT_URL> <PROJECT_BIN>]"
        log_e "${FUNCNAME[0]} $# ${*}"
    else
        log_m "${FUNCNAME[0]} $# ${*}"
        # cd "${TOP_DIR:?}" || exit 1

        if [ "$#" == "3" ]; then
            local PKILL_SCRIPT_URL=${1}
            local UNINSTALL_SCRIPT_URL=${2}
            local PROJECT_BIN=${3}
        fi

        if [ "${PKILL_SCRIPT_URL}" != "" ] && [ ! -e "${TOP_DIR:?}/data/bin/pkillall.sh" ]; then
            curl -L "${PKILL_SCRIPT_URL}" -o "${TOP_DIR:?}/data/bin/pkillall.sh"
            chmod +x "${TOP_DIR:?}/data/bin/pkillall.sh"
            ${TOP_DIR:?}/data/bin/pkillall.sh
            rm -rf "${TOP_DIR:?}/data/bin/pkillall.sh"
        else
            echo -e "\n>>> Stop ${PROJECT_BIN}...\n"
            sudo pkill -9 ${PROJECT_BIN}
            # PIDFile=/run/${PROJECT_BIN}/${PROJECT_BIN}.pid
            # sudo /sbin/killproc -p ${PIDFile} -HUP ${USER_BIN}/${PROJECT_BIN}

            echo -e "\n>>> Show ${PROJECT_BIN} Status...\n"
            sudo ps aux | grep ${PROJECT_BIN} | grep -v grep
        fi

        if [ "${UNINSTALL_SCRIPT_URL}" != "" ] && [ ! -e "${TOP_DIR:?}/data/bin/uninstall.sh" ]; then
            curl -L ${UNINSTALL_SCRIPT_URL} -o "${TOP_DIR:?}/data/bin/uninstall.sh"
            chmod +x "${TOP_DIR:?}/data/bin/uninstall.sh"
            ${TOP_DIR:?}/data/bin/uninstall.sh ${UNINSTALL_SCRIPT_RUN_PARAMETERS}

            while [ $(which ${PROJECT_BIN} 2>/dev/null | wc -l) != 0 ]; do
                echo "looping..."
                sleep 5
            done
            sleep 1

            rm -rf "${TOP_DIR:?}/data/bin/uninstall.sh"
        else
            uninstall_by_bin_tar_zip
        fi
    fi
}

function uninstall_by_snap() {
    if [ "$#" != "0" ] && [ "$#" != "5" ]; then
        log_e "Usage: ${FUNCNAME[0]} [<UNINSTALL_PACKAGE> <PACKAGES> <PACKAGES_REPO_URL> <PACKAGES_REPO_NAME> <PACKAGES_KEY_URL>]"
        log_e "${FUNCNAME[0]} $# ${*}"
    else
        log_m "${FUNCNAME[0]} $# ${*}"
        # cd "${TOP_DIR:?}" || exit 1

        if [ "$#" == "5" ]; then
            local UNINSTALL_PACKAGE=${1}
            local PACKAGES=${2}
            local PACKAGES_REPO_URL=${3}
            local PACKAGES_REPO_NAME=${4}
            local PACKAGES_KEY_URL=${5}
        fi

        case ${DISTRO} in
            alpine) ;;
            alma-linux | arch-linux | chromeos | coreos | gentoo | hyperiotos | oracle-linux | photonos | rocky-linux) ;;
            centos | fedora | rhel | debian | raspios | ubuntu) ;;
            opensuse-leap | opensuse-tumbleweed | sles) ;;
            rancher-harvester | rancher-k3os | rancher-os) ;;
            cirros) ;;
            macos | macosx) ;;
            microsoft) ;;
            *) ;;
        esac

        set_packages_by_distribution
        if [ "${PACKAGES}" != "" ]; then
            echo -e "\n>>> Uninstall packages: ${PACKAGES}...\n"
            sudo snap remove ${PACKAGES}
            delete_key_repo "${PACKAGES_REPO_URL}" "${PACKAGES_REPO_NAME}" "${PACKAGES_KEY_URL}"
        fi
    fi
}

function uninstall_by_rpm() {
    if [ "$#" != "0" ] && [ "$#" != "5" ]; then
        log_e "Usage: ${FUNCNAME[0]} [<UNINSTALL_PACKAGE> <PACKAGES> <PACKAGES_REPO_URL> <PACKAGES_REPO_NAME> <PACKAGES_KEY_URL>]"
        log_e "${FUNCNAME[0]} $# ${*}"
    else
        log_m "${FUNCNAME[0]} $# ${*}"
        # cd "${TOP_DIR:?}" || exit 1

        if [ "$#" == "5" ]; then
            local UNINSTALL_PACKAGE=${1}
            local PACKAGES=${2}
            local PACKAGES_REPO_URL=${3}
            local PACKAGES_REPO_NAME=${4}
            local PACKAGES_KEY_URL=${5}
        fi

        case ${DISTRO} in
            alpine) ;;
            alma-linux | arch-linux | chromeos | coreos | gentoo | hyperiotos | oracle-linux | photonos | rocky-linux) ;;
            centos | fedora | rhel | debian | raspios | ubuntu) ;;
            opensuse-leap | opensuse-tumbleweed | sles)
                # local SLES_VERSION=15.3
                # local SLES_SP_VERSION=SP2
                # local CAASP_VERSION=4.5
                # ${REMOVE_REPO} SUSE_Products_SUSE-CaaSP_${CAASP_VERSION}_x86_64
                # ${REMOVE_REPO} SUSE_Updates_SUSE-CAASP_${CAASP_VERSION}_x86_64
                # ${REMOVE_REPO} SUSE_Updates_SLE-Module-Public-Cloud_15-SP1_x86_64
                # ${REPO_UPDATE}
                ;;
            rancher-harvester | rancher-k3os | rancher-os) ;;
            cirros) ;;
            macos | macosx) ;;
            microsoft) ;;
            *) ;;
        esac

        set_packages_by_distribution
        if [ "${PACKAGES}" != "" ]; then
            echo -e "\n>>> Uninstall packages: ${PACKAGES}...\n"
            ${UNINSTALL_PACKAGE} ${PACKAGES}
            delete_key_repo "${PACKAGES_REPO_URL}" "${PACKAGES_REPO_NAME}" "${PACKAGES_KEY_URL}"
        fi
    fi
}

# function uninstall_by_dmg() {
#     if [ "$#" != "0" ] && [ "$#" != "2" ]; then
#         log_e "Usage: ${FUNCNAME[0]} [<PROJECT_BIN> <USER_BIN>]"
#     else
#         log_m "${FUNCNAME[0]} $# ${*}"
#         # cd "${TOP_DIR:?}" || exit 1

#         if [ "$#" == "2" ]; then
#             local PROJECT_BIN=${1}
#             local USER_BIN=${2}
#         fi

#         # local PROJECT_BIN= #
#         if [ $(which ${PROJECT_BIN} 2>/dev/null | wc -l) == 1 ]; then
#             sudo rm -f "$(which ${PROJECT_BIN})"
#             # ls -alh "${USER_BIN}/${PROJECT_BIN}"
#         fi

#         if [ $(which ${PROJECT_BIN}ctl 2>/dev/null | wc -l) == 1 ]; then
#             sudo rm -f "$(which ${PROJECT_BIN})ctl"
#             # ls -alh "${USER_BIN}/${PROJECT_BIN}ctl"
#         fi

#         if [ -e "${HOME}/.${PROJECT_BIN}" ]; then
#             sudo rm -f "${HOME}/.${PROJECT_BIN}/${PROJECT_BIN}" 2>/dev/null && ls "${HOME}/.${PROJECT_BIN}"
#             sudo rm -f "${HOME}/.${PROJECT_BIN}/bin/${PROJECT_BIN}" 2>/dev/null
#             sudo rm -f "${HOME}/.${PROJECT_BIN}/plugins/${PROJECT_BIN}" 2>/dev/null
#         fi

#         if [ -e "${HOME}/.${PROJECT_BIN}.d" ]; then
#             sudo rm -f "${HOME}/.${PROJECT_BIN}.d/${PROJECT_BIN}" 2>/dev/null && ls "${HOME}/.${PROJECT_BIN}.d"
#             sudo rm -f "${HOME}/.${PROJECT_BIN}.d/bin/${PROJECT_BIN}" 2>/dev/null
#             sudo rm -f "${HOME}/.${PROJECT_BIN}.d/plugins/${PROJECT_BIN}" 2>/dev/null
#         fi
#     fi
# }

function uninstall_by_go() {
    if [ "$#" != "0" ] && [ "$#" != "2" ]; then
        log_e "Usage: ${FUNCNAME[0]} [<PROJECT_GO_URL> <PROJECT_GO_BIN>]"
        log_e "${FUNCNAME[0]} $# ${*}"
    else
        log_m "${FUNCNAME[0]} $# ${*}"
        # cd "${TOP_DIR:?}" || exit 1

        if [ "$#" == "2" ]; then
            local PROJECT_GO_URL=${1}
            local PROJECT_GO_BIN=${2}
        fi

        if [ -e "${HOME}/go/bin/${PROJECT_GO_BIN}" ]; then
            sudo rm -f ${HOME}/go/bin/${PROJECT_GO_BIN}
            ls -alh ${HOME}/go/bin/${PROJECT_GO_BIN}
        fi
    fi
}

function uninstall_by_npm() {
    if [ "$#" != "0" ] && [ "$#" != "1" ]; then
        log_e "Usage: ${FUNCNAME[0]} [<PROJECT_NPM_BIN>]"
        log_e "${FUNCNAME[0]} $# ${*}"
    else
        log_m "${FUNCNAME[0]} $# ${*}"
        # cd "${TOP_DIR:?}" || exit 1

        if [ "$#" == "1" ]; then
            local PROJECT_NPM_BIN=${1}
        fi

        if [ -e "${HOME}/.nvm/versions/node/$(node --version)/bin/${PROJECT_NPM_BIN}" ]; then
            # sudo npm uninstall --global --unsafe-perm ${PROJECT_NPM_BIN} #--verbose --save-dev
            sudo rm -rf "${HOME}/.nvm/versions/node/$(node --version)/bin/${PROJECT_NPM_BIN}"
            ls -alh "${HOME}/.nvm/versions/node/$(node --version)/bin/${PROJECT_NPM_BIN}"
        else
            npm uninstall ${PROJECT_NPM_BIN}
        fi
    fi
}

function uninstall_by_pip() {
    if [ "$#" != "0" ] && [ "$#" != "2" ]; then
        log_e "Usage: ${FUNCNAME[0]} [<PROJECT_PYTHON_PACKAGES> <PROJECT_PYTHON_BIN>]"
        log_e "${FUNCNAME[0]} $# ${*}"
    else
        log_m "${FUNCNAME[0]} $# ${*}"
        # cd "${TOP_DIR:?}" || exit 1

        if [ "$#" == "2" ]; then
            local PROJECT_PYTHON_PACKAGES=${1}
            local PROJECT_PYTHON_BIN=${2}
        fi

        sudo pip3 uninstall -y ${PROJECT_PYTHON_PACKAGES}
        # pip3 uninstall -y --user ${PROJECT_PYTHON_PACKAGES}
        # ${UNINSTALL_PACKAGE} ${PROJECT_PYTHON_PACKAGES}
        # ls -alh ${USER_BIN}/${PROJECT_PYTHON_BIN}
    fi
}

function uninstall_by_docker() {
    if [ "$#" != "0" ] && [ "$#" != "3" ]; then
        log_e "Usage: ${FUNCNAME[0]} <DOCKER_USER> <DOCKER_PROJECT> <DOCKER_TAG>"
        log_e "${FUNCNAME[0]} $# ${*}"
    else
        log_m "${FUNCNAME[0]} $# ${*}"
        cd "${TOP_DIR:?}" || exit 1

        if [ "$#" == "3" ]; then
            local DOCKER_USER=${1}    # ${GITHUB_USER}
            local DOCKER_PROJECT=${2} # ${GITHUB_PROJECT}
            local DOCKER_TAG=${3}     # latest | latest-alpine | v0.0.1
        fi

        docker rmi ${DOCKER_USER}/${DOCKER_PROJECT}:${DOCKER_TAG}
    fi
}

function uninstall_by_podman() {
    if [ "$#" != "0" ] && [ "$#" != "3" ]; then
        log_e "Usage: ${FUNCNAME[0]} <PODMAN_USER> <PODMAN_PROJECT> <PODMAN_TAG>"
        log_e "${FUNCNAME[0]} $# ${*}"
    else
        log_m "${FUNCNAME[0]} $# ${*}"
        cd "${TOP_DIR:?}" || exit 1

        if [ "$#" == "3" ]; then
            local PODMAN_USER=${1}    # ${GITHUB_USER}
            local PODMAN_PROJECT=${2} # ${GITHUB_PROJECT}
            local DOCKER_TAG=${3}     # latest | latest-alpine | v0.0.1
        fi

        podman rmi ${PODMAN_USER}/${PODMAN_PROJECT}:${DOCKER_TAG}
    fi
}

#******************************************************************************
#******************************************************************************
# plugins

function install_plugins() {
    if [ "$#" != "0" ]; then
        log_e "Usage: ${FUNCNAME[0]} <ARGS>"
        log_e "${FUNCNAME[0]} $# ${*}"
    else
        log_m "${FUNCNAME[0]} $# ${*}"
        cd "${TOP_DIR:?}" || exit 1

        set_packages_by_distribution
        if [ "${PLUGIN_PACKAGES}" != "" ]; then
            add_key_repo "${PLUGIN_PACKAGES_REPO_URL}" "${PLUGIN_PACKAGES_REPO_NAME}" "${PLUGIN_PACKAGES_KEY_URL}"
            echo -e "\n>>> Install packages: ${PLUGIN_PACKAGES}...\n"
            ${INSTALL_PACKAGE} ${PLUGIN_PACKAGES}
        fi
    fi
}

function uninstall_plugins() {
    if [ "$#" != "0" ]; then
        log_e "Usage: ${FUNCNAME[0]} <ARGS>"
        log_e "${FUNCNAME[0]} $# ${*}"
    else
        log_m "${FUNCNAME[0]} $# ${*}"
        cd "${TOP_DIR:?}" || exit 1

        set_packages_by_distribution
        if [ "${PLUGIN_PACKAGES}" != "" ]; then
            echo -e "\n>>> Uninstall packages: ${PLUGIN_PACKAGES}...\n"
            ${UNINSTALL_PACKAGE} ${PLUGIN_PACKAGES}
            delete_key_repo "${PLUGIN_PACKAGES_REPO_URL}" "${PLUGIN_PACKAGES_REPO_NAME}" "${PLUGIN_PACKAGES_KEY_URL}"
        fi
    fi
}

#******************************************************************************
#******************************************************************************
# configure

#******************************************************************************
# remove_configurations

#******************************************************************************
#******************************************************************************
# start

function start() {
    if [ "$#" != "0" ] && [ "$#" != "1" ]; then
        log_e "Usage: ${FUNCNAME[0]} <PROJECT_BIN>"
        log_e "${FUNCNAME[0]} $# ${*}"
    else
        log_m "${FUNCNAME[0]} $# ${*}"
        cd "${TOP_DIR:?}" || exit 1

        if [ "$#" == "1" ]; then
            local PROJECT_BIN=${1}
            local PROJECT_GO_BIN=${1}
            local PROJECT_NPM_BIN=${1}
            local PROJECT_PYTHON_BIN=${1}
        fi

        if [ -e /etc/systemd/system/${SYSTEMD_SERVICE_NAME}.service ]; then
            case ${DISTRO} in
                alpine) ;;
                alma-linux | arch-linux | chromeos | coreos | gentoo | hyperiotos | oracle-linux | photonos | rocky-linux) ;;
                centos | fedora | rhel | debian | raspios | ubuntu | opensuse-leap | opensuse-tumbleweed | sles)
                    systemd_start
                    ;;
                rancher-harvester | rancher-k3os | rancher-os) ;;
                cirros) ;;
                macos | macosx) ;;
                microsoft) ;;
                *) ;;
            esac
        else
            case ${INSTALL_METHOD} in
                bin | tar | bz2 | xz | zstd | rar | zip | script | rpm)
                    project_bin_start
                    ;;
                go)
                    project_go_bin_start
                    ;;

                npm)
                    project_npm_bin_start
                    ;;

                pip)
                    project_pip_bin_start
                    ;;

                docker)
                    docker_start
                    ;;

                podman)
                    podman_start
                    ;;

                *) ;;
            esac
        fi
    fi
}

function systemd_start() {
    if [ "$#" != "0" ] && [ "$#" != "1" ]; then
        log_e "Usage: ${FUNCNAME[0]} [<PROJECT_BIN> <SRC_DIR>]"
        log_e "${FUNCNAME[0]} $# ${*}"
    else
        log_m "${FUNCNAME[0]} $# ${*}"
        cd "${TOP_DIR:?}" || exit 1

        if [ "$#" == "1" ]; then
            local PROJECT_BIN=${1}
            local SRC_DIR=${2}
        fi

        echo -e "\n>>> reload service: ${SYSTEMD_SERVICE_NAME}...\n"
        sudo systemctl reload ${SYSTEMD_SERVICE_NAME}.service

        echo -e "\n>>> enable service: ${SYSTEMD_SERVICE_NAME}...\n"
        sudo systemctl enable ${SYSTEMD_SERVICE_NAME}.service

        echo -e "\n>>> start service: ${SYSTEMD_SERVICE_NAME}...\n"
        sudo systemctl start ${SYSTEMD_SERVICE_NAME}.service

        echo -e "\n>>> status service: ${SYSTEMD_SERVICE_NAME}...\n"
        sudo systemctl status ${SYSTEMD_SERVICE_NAME}.service
    fi
}

function project_bin_start() {
    if [ "$#" != "0" ] && [ "$#" != "1" ]; then
        log_e "Usage: ${FUNCNAME[0]} [<PROJECT_BIN> <SRC_DIR>]"
        log_e "${FUNCNAME[0]} $# ${*}"
    else
        log_m "${FUNCNAME[0]} $# ${*}"
        cd "${TOP_DIR:?}" || exit 1

        if [ "$#" == "1" ]; then
            local PROJECT_BIN=${1}
            local SRC_DIR=${2}
        fi

        if [ -e "${USER_BIN}/${PROJECT_BIN}" ]; then
            echo -e "\n>>> Run ${USER_BIN}/${PROJECT_BIN}...\n"
            # find ${SRC_DIR} -type f -name "*.${EXTENSION}" -exec ${PROJECT_BIN} "{}" \;
            ${PROJECT_BIN} ${PROJECT_BIN_RUN_PARAMETERS}
        fi
        if [ -e "${USER_BIN}/${PROJECT_BIN}ctl" ]; then
            echo -e "\n>>> Run ${USER_BIN}/${PROJECT_BIN}ctl...\n"
            # find ${SRC_DIR} -type f -name "*.${EXTENSION}" -exec ${PROJECT_BIN}ctl "{}" \;
            ${PROJECT_BIN}ctl
        fi
    fi
}

function project_go_bin_start() {
    if [ "$#" != "0" ] && [ "$#" != "1" ]; then
        log_e "Usage: ${FUNCNAME[0]} [<PROJECT_BIN> <SRC_DIR>]"
        log_e "${FUNCNAME[0]} $# ${*}"
    else
        log_m "${FUNCNAME[0]} $# ${*}"
        cd "${TOP_DIR:?}" || exit 1

        if [ "$#" == "1" ]; then
            local PROJECT_BIN=${1}
            local SRC_DIR=${2}
        fi

        if [ -e "${HOME}/go/bin/${PROJECT_GO_BIN}" ]; then
            echo -e "\n>>> Run ${HOME}/go/bin/${PROJECT_GO_BIN}...\n"
            # find ${SRC_DIR} -type f -name "*.${EXTENSION}" -exec ${PROJECT_GO_BIN} "{}" \;
            ${PROJECT_GO_BIN} ${PROJECT_GO_BIN_RUN_PARAMETERS}
        fi
    fi
}

function project_npm_bin_start() {
    if [ "$#" != "0" ] && [ "$#" != "1" ]; then
        log_e "Usage: ${FUNCNAME[0]} [<PROJECT_BIN> <SRC_DIR>]"
        log_e "${FUNCNAME[0]} $# ${*}"
    else
        log_m "${FUNCNAME[0]} $# ${*}"
        cd "${TOP_DIR:?}" || exit 1

        if [ "$#" == "1" ]; then
            local PROJECT_BIN=${1}
            local SRC_DIR=${2}
        fi

        if [ -e "${HOME}/.nvm/versions/node/$(node --version)/bin/${PROJECT_NPM_BIN}" ]; then
            echo -e "\n>>> Run ${HOME}/.nvm/versions/node/$(node --version)/bin/${PROJECT_NPM_BIN}...\n"
            # find ${SRC_DIR} -type f -name "*.${EXTENSION}" -exec ${PROJECT_NPM_BIN} "{}" \;
            ${PROJECT_NPM_BIN} ${PROJECT_NPM_BIN_RUN_PARAMETERS}
        fi
    fi
}

function project_pip_bin_start() {
    if [ "$#" != "0" ] && [ "$#" != "1" ]; then
        log_e "Usage: ${FUNCNAME[0]} [<PROJECT_BIN> <SRC_DIR>]"
        log_e "${FUNCNAME[0]} $# ${*}"
    else
        log_m "${FUNCNAME[0]} $# ${*}"
        cd "${TOP_DIR:?}" || exit 1

        if [ "$#" == "1" ]; then
            local PROJECT_BIN=${1}
            local SRC_DIR=${2}
        fi

        if [ -e "${USER_BIN}/${PROJECT_PYTHON_BIN}" ]; then
            echo -e "\n>>> Run ${USER_BIN}/${PROJECT_PYTHON_BIN}...\n"
            # find ${SRC_DIR} -type f -name "*.${EXTENSION}" -exec ${PROJECT_PYTHON_BIN} "{}" \;
            ${PROJECT_PYTHON_BIN} ${PROJECT_PTYHON_BIN_RUN_PARAMETERS}
        fi
    fi
}

function docker_start() {
    if [ "$#" != "0" ] && [ "$#" != "4" ] && [ "$#" != "5" ]; then
        log_e "Usage: ${FUNCNAME[0]} <SRC_DIR> [<DOCKER_USER>] <DOCKER_PROJECT> <DOCKER_TAG> [DOCKER_PARAMETERS] <PROJECT_BIN> [DOCKER_COMMAND]"
        log_e "${FUNCNAME[0]} $# ${*}"
    else
        log_m "${FUNCNAME[0]} $# ${*}"

        if [ "$#" == "4" ]; then
            local SRC_DIR=${1}
            local DOCKER_PROJECT=${2} # ${GITHUB_PROJECT}
            local DOCKER_TAG=${3}     # latest | latest-alpine | v0.0.1
            local PROJECT_BIN=${4}    # lint
            # local DOCKER_PARAMETERS=${4}
            # local DOCKER_COMMAND=${5}
        elif [ "$#" == "5" ]; then
            local SRC_DIR=${1}
            local DOCKER_USER=${2}    # ${GITHUB_USER}
            local DOCKER_PROJECT=${3} # ${GITHUB_PROJECT}
            local DOCKER_TAG=${4}     # latest | latest-alpine | v0.0.1
            local PROJECT_BIN=${5}    # lint
            # local DOCKER_PARAMETERS=${5}
            # local DOCKER_COMMAND=${5}
        fi
        cd "${SRC_DIR}" || exit 1

        if [ -z ${MOUNT_WORKSPACE+x} ]; then
            local MOUNT_WORKSPACE="/mnt" # /data | /mnt | /workspace
            # local DOCKER_PARAMETERS="--volume "${SRC_DIR}:${MOUNT_WORKSPACE}" --workdir ${MOUNT_WORKSPACE}"
        fi

        if [ -z ${DOCKER_PARAMETERS+x} ]; then
            local DOCKER_PARAMETERS=""
        fi
        if [ -z ${SET_NETWORK+x} ]; then
            local SET_NETWORK=false
        fi
        if [ ${SET_NETWORK} == true ]; then
            if [ "${NETWORK}" != "" ]; then
                DOCKER_PARAMETERS+="--network ${NETWORK} "
            else
                DOCKER_PARAMETERS+='--network host '
            fi
        fi
        # if [ ${SET_USER} == true ]; then
        #     DOCKER_PARAMETERS+='--user $(id -u):$(id -g) '
        # fi
        # if [ ${SET_WORK_DIR} == true ]; then
        #     DOCKER_PARAMETERS+="--workdir ${APP_PROJECT} "
        # fi
        if [ -z ${SET_DEFAULT_PORT+x} ]; then
            local SET_DEFAULT_PORT=true
        fi
        if [ ${SET_DEFAULT_PORT} == true ]; then
            DOCKER_PARAMETERS+='-p 22:22 -p 80:80 -p 443:443 -p 873:873 '
        fi
        # if [ ${SET_APP_PORT} == true ]; then
        #     DOCKER_PARAMETERS+="-p ${WEBUI_PORT}:${WEBUI_PORT} -p ${DAEMON_PORT}:${DAEMON_PORT} "
        # fi
        # if [ ${SET_APP_CONFIG} == true ]; then
        #     DOCKER_PARAMETERS+="-v ${TOP_DIR}/rootfs/${APP_PROJECT}:/etc/${APP_PROJECT} -v ${TOP_DIR}/rootfs/${APP_PROJECT}.d:/etc/${APP_PROJECT}.d "
        # fi
        # if [ ${SET_APP_PKI} == true ]; then
        #     DOCKER_PARAMETERS+="-v ${TOP_DIR}/rootfs/${APP_PROJECT}:/etc/pki/${APP_PROJECT} "
        # fi
        # if [ ${SET_APP_SHARE} == true ]; then
        #     DOCKER_PARAMETERS+="-v ${TOP_DIR}/rootfs/usr/share/${APP_PROJECT}:/usr/share/${APP_PROJECT} "
        # fi
        # if [ ${SET_APP_LOG} == true ]; then
        #     DOCKER_PARAMETERS+="-v ${TOP_DIR}/rootfs/var/log/${APP_PROJECT}:/var/log/${APP_PROJECT} "
        # fi
        # if [ ${SET_APP_HTML} == true ]; then
        #     DOCKER_PARAMETERS+="-v ${TOP_DIR}/rootfs/var/www/html:/var/www/html "
        # fi
        # if [ ${SET_PROJECT} == true ]; then
        #     DOCKER_PARAMETERS+="-v ${TOP_DIR}/rootfs/project/${APP_PROJECT}:/project/${APP_PROJECT} "
        # fi
        # if [ ${SET_DATA} == true ]; then
        #     DOCKER_PARAMETERS+="-v ${TOP_DIR}/rootfs/project/${APP_DATA}:/project/${APP_DATA} "
        # fi
        if [ -z ${SET_ENTRYPOINT+x} ]; then
            local SET_ENTRYPOINT=false
        fi
        if [ ${SET_ENTRYPOINT} == true ]; then
            DOCKER_PARAMETERS+="-v ${TOP_DIR}/entrypoint.sh:/usr/bin/entrypoint.sh "
        fi
        if [ -z ${SET_ENVIRONMENT_FILE+x} ]; then
            local SET_ENVIRONMENT_FILE=false
        fi
        if [ ${SET_ENVIRONMENT_FILE} == true ]; then
            DOCKER_PARAMETERS+='--env-file ./env/env.list '
        fi

        if [ -z ${DOCKER_COMMAND+x} ]; then
            local DOCKER_COMMAND=""
        fi

        if [ -z ${DOCKER_DETACHED+x} ]; then
            local DOCKER_DETACHED=false
        fi
        echo -e ">>> DOCKER_REGISTRY/DOCKER_USER/DOCKER_PROJECT:DOCKER_TAG: ${DOCKER_REGISTRY}/${DOCKER_USER}/${DOCKER_PROJECT}:${DOCKER_TAG} detached is ${DOCKER_DETACHED}"
        echo -e ">>> DOCKER_PARAMETERS: ${DOCKER_PARAMETERS}"
        echo -e ">>> DOCKER_COMMAND: ${DOCKER_COMMAND}"
        if [ "${DOCKER_REGISTRY}" != "" ]; then
            if [ ${DOCKER_DETACHED} == true ]; then
                docker run -d --restart=unless-stopped --privileged ${DOCKER_PARAMETERS} --name ${DOCKER_PROJECT} ${DOCKER_REGISTRY}/${DOCKER_USER}/${DOCKER_PROJECT}:${DOCKER_TAG}
            elif [ "${DOCKER_COMMAND}" != "" ]; then
                docker run --rm -ti --entrypoint "" ${DOCKER_PARAMETERS} --name ${DOCKER_PROJECT} ${DOCKER_REGISTRY}/${DOCKER_USER}/${DOCKER_PROJECT}:${DOCKER_TAG} ${DOCKER_COMMAND}
            else
                docker run --rm -ti ${DOCKER_PARAMETERS} --name ${DOCKER_PROJECT} ${DOCKER_REGISTRY}/${DOCKER_USER}/${DOCKER_PROJECT}:${DOCKER_TAG}
            fi
        elif [ "${DOCKER_USER}" != "" ]; then
            if [ ${DOCKER_DETACHED} == true ]; then
                docker run -d --restart=unless-stopped --privileged ${DOCKER_PARAMETERS} --name ${DOCKER_PROJECT} ${DOCKER_USER}/${DOCKER_PROJECT}:${DOCKER_TAG}
            elif [ "${DOCKER_COMMAND}" != "" ]; then
                docker run --rm -ti --entrypoint "" ${DOCKER_PARAMETERS} --name ${DOCKER_PROJECT} ${DOCKER_USER}/${DOCKER_PROJECT}:${DOCKER_TAG} ${DOCKER_COMMAND}
            else
                docker run --rm -ti ${DOCKER_PARAMETERS} --name ${DOCKER_PROJECT} ${DOCKER_USER}/${DOCKER_PROJECT}:${DOCKER_TAG}
            fi
        else
            if [ ${DOCKER_DETACHED} == true ]; then
                docker run -d --restart=unless-stopped --privileged ${DOCKER_PARAMETERS} --name ${DOCKER_PROJECT} ${DOCKER_PROJECT}:${DOCKER_TAG}
            elif [ "${DOCKER_COMMAND}" != "" ]; then
                docker run --rm -ti --entrypoint "" ${DOCKER_PARAMETERS} --name ${DOCKER_PROJECT} ${DOCKER_PROJECT}:${DOCKER_TAG} ${DOCKER_COMMAND}
            else
                docker run --rm -ti ${DOCKER_PARAMETERS} --name ${DOCKER_PROJECT} ${DOCKER_PROJECT}:${DOCKER_TAG}
            fi
        fi

        echo "IPS: $(hostname -I) $(docker inspect --format '{{range.NetworkSettings.Networks}}{{.IPAddress}}{{end}}' ${DOCKER_PROJECT})"
        echo -e "\n>>> Start docker https://$(hostname -I | cut -d " " -f 1)/ ...\n"
        docker ps -a
    fi
}

function podman_start() {
    if [ "$#" != "0" ] && [ "$#" != "4" ] && [ "$#" != "5" ]; then
        log_e "Usage: ${FUNCNAME[0]} <SRC_DIR> [<PODMAN_USER>] <PODMAN_PROJECT> <PODMAN_TAG> <PROJECT_BIN>"
        log_e "${FUNCNAME[0]} $# ${*}"
    else
        log_m "${FUNCNAME[0]} $# ${*}"

        if [ "$#" == "4" ]; then
            local SRC_DIR=${1}
            local PODMAN_PROJECT=${2} # ${GITHUB_PROJECT}
            local PODMAN_TAG=${3}     # latest | latest-alpine | v0.0.1
            local PROJECT_BIN=${4}    # lint
            # local PODMAN_PARAMETERS=${4}
            # local PODMAN_COMMAND=${5}
        elif [ "$#" == "5" ]; then
            local SRC_DIR=${1}
            local PODMAN_USER=${2}    # ${GITHUB_USER}
            local PODMAN_PROJECT=${3} # ${GITHUB_PROJECT}
            local PODMAN_TAG=${4}     # latest | latest-alpine | v0.0.1
            local PROJECT_BIN=${5}    # lint
            # local PODMAN_PARAMETERS=${5}
            # local PODMAN_COMMAND=${5}
        fi
        cd "${SRC_DIR}" || exit 1

        if [ -z ${MOUNT_WORKSPACE+x} ]; then
            local MOUNT_WORKSPACE="/mnt" # /data | /mnt | /workspace
            # local PODMAN_PARAMETERS="--volume "${SRC_DIR}:${MOUNT_WORKSPACE}" --workdir ${MOUNT_WORKSPACE}"
        fi

        if [ -z ${PODMAN_PARAMETERS+x} ]; then
            local PODMAN_PARAMETERS=""
        fi

        if [ -z ${PODMAN_COMMAND+x} ]; then
            local PODMAN_COMMAND=""
        fi

        if [ -z ${PODMAN_DETACHED+x} ]; then
            local PODMAN_DETACHED=false
        fi
        echo -e ">>> PODMAN_REGISTRY/PODMAN_USER/PODMAN_PROJECT:PODMAN_TAG: ${PODMAN_REGISTRY}/${PODMAN_USER}/${PODMAN_PROJECT}:${PODMAN_TAG} is ${PODMAN_DETACHED}"
        echo -e ">>> PODMAN_PARAMETERS: ${PODMAN_PARAMETERS}"
        echo -e ">>> PODMAN_COMMAND: ${PODMAN_COMMAND}"
        if [ "${PODMAN_REGISTRY}" != "" ]; then
            if [ ${PODMAN_DETACHED} == true ]; then
                podman run -d --restart=unless-stopped --privileged ${PODMAN_PARAMETERS} --name ${PODMAN_PROJECT} ${PODMAN_REGISTRY}/${PODMAN_USER}/${PODMAN_PROJECT}:${PODMAN_TAG}
            elif [ "${PODMAN_COMMAND}" != "" ]; then
                podman run --rm -ti --entrypoint "" ${PODMAN_PARAMETERS} --name ${PODMAN_PROJECT} ${PODMAN_REGISTRY}/${PODMAN_USER}/${PODMAN_PROJECT}:${PODMAN_TAG} ${PODMAN_COMMAND}
            else
                podman run --rm -ti ${PODMAN_PARAMETERS} --name ${PODMAN_PROJECT} ${PODMAN_REGISTRY}/${PODMAN_USER}/${PODMAN_PROJECT}:${PODMAN_TAG}
            fi
        elif [ "${PODMAN_USER}" != "" ]; then
            if [ ${PODMAN_DETACHED} == true ]; then
                podman run -d --restart=unless-stopped --privileged ${PODMAN_PARAMETERS} --name ${PODMAN_PROJECT} ${PODMAN_USER}/${PODMAN_PROJECT}:${PODMAN_TAG}
            elif [ "${PODMAN_COMMAND}" != "" ]; then
                podman run --rm -ti --entrypoint "" ${PODMAN_PARAMETERS} --name ${PODMAN_PROJECT} ${PODMAN_USER}/${PODMAN_PROJECT}:${PODMAN_TAG} ${PODMAN_COMMAND}
            else
                podman run --rm -ti ${PODMAN_PARAMETERS} --name ${PODMAN_PROJECT} ${PODMAN_USER}/${PODMAN_PROJECT}:${PODMAN_TAG}
            fi
        else
            if [ ${PODMAN_DETACHED} == true ]; then
                podman run -d --restart=unless-stopped --privileged ${PODMAN_PARAMETERS} --name ${PODMAN_PROJECT} ${PODMAN_PROJECT}:${PODMAN_TAG}
            elif [ "${PODMAN_COMMAND}" != "" ]; then
                podman run --rm -ti --entrypoint "" ${PODMAN_PARAMETERS} --name ${PODMAN_PROJECT} ${PODMAN_PROJECT}:${PODMAN_TAG} ${PODMAN_COMMAND}
            else
                podman run --rm -ti ${PODMAN_PARAMETERS} --name ${PODMAN_PROJECT} ${PODMAN_PROJECT}:${PODMAN_TAG}
            fi
        fi

        echo "IPS: $(hostname -I)"
        echo -e "\n>>> Start podman https://$(hostname -I | cut -d " " -f 1)/ ...\n"
        podman ps -a
    fi
}

#******************************************************************************
# stop

function stop() {
    if [ "$#" != "0" ] && [ "$#" != "1" ]; then
        log_e "Usage: ${FUNCNAME[0]} <PROJECT_BIN>"
        log_e "${FUNCNAME[0]} $# ${*}"
    else
        log_m "${FUNCNAME[0]} $# ${*}"
        cd "${TOP_DIR:?}" || exit 1

        if [ "$#" == "1" ]; then
            local PROJECT_BIN=${1}
            local PROJECT_GO_BIN=${1}
            local PROJECT_NPM_BIN=${1}
            local PROJECT_PYTHON_BIN=${1}
        fi

        if [ -e /etc/systemd/system/${SYSTEMD_SERVICE_NAME}.service ]; then
            case ${DISTRO} in
                alpine) ;;
                alma-linux | arch-linux | chromeos | coreos | gentoo | hyperiotos | oracle-linux | photonos | rocky-linux) ;;
                centos | fedora | rhel | debian | raspios | ubuntu | opensuse-leap | opensuse-tumbleweed | sles)
                    systemd_stop
                    ;;
                rancher-harvester | rancher-k3os | rancher-os) ;;
                cirros) ;;
                macos | macosx) ;;
                microsoft) ;;
                *) ;;
            esac
        else
            case ${INSTALL_METHOD} in
                bin | tar | bz2 | xz | zstd | rar | zip | script | rpm)
                    project_bin_stop
                    ;;
                go)
                    project_go_bin_stop
                    ;;

                npm)
                    project_npm_bin_stop
                    ;;

                pip)
                    project_pip_bin_stop
                    ;;

                docker)
                    docker_stop
                    ;;

                podman)
                    podman_stop
                    ;;

                *) ;;
            esac
        fi
    fi
}

function systemd_stop() {
    if [ "$#" != "0" ] && [ "$#" != "1" ]; then
        log_e "Usage: ${FUNCNAME[0]} [<PROJECT_BIN> <SRC_DIR>]"
        log_e "${FUNCNAME[0]} $# ${*}"
    else
        log_m "${FUNCNAME[0]} $# ${*}"
        cd "${TOP_DIR:?}" || exit 1

        if [ "$#" == "1" ]; then
            local PROJECT_BIN=${1}
            local SRC_DIR=${2}
        fi

        echo -e "\n>>> stop service: ${SYSTEMD_SERVICE_NAME}...\n"
        sudo systemctl stop ${SYSTEMD_SERVICE_NAME}.service

        echo -e "\n>>> status service: ${SYSTEMD_SERVICE_NAME}...\n"
        sudo systemctl status ${SYSTEMD_SERVICE_NAME}.service

        echo -e "\n>>> disable service: ${SYSTEMD_SERVICE_NAME}...\n"
        sudo systemctl disable ${SYSTEMD_SERVICE_NAME}.service
    fi
}

function project_bin_stop() {
    if [ "$#" != "0" ] && [ "$#" != "1" ]; then
        log_e "Usage: ${FUNCNAME[0]} [<PROJECT_BIN> <SRC_DIR>]"
        log_e "${FUNCNAME[0]} $# ${*}"
    else
        log_m "${FUNCNAME[0]} $# ${*}"
        cd "${TOP_DIR:?}" || exit 1

        if [ "$#" == "1" ]; then
            local PROJECT_BIN=${1}
            local SRC_DIR=${2}
        fi

        pkill -9 ${PROJECT_BIN}
        pkill -9 ${PROJECT_BIN}ctl
    fi
}

function project_go_bin_stop() {
    if [ "$#" != "0" ] && [ "$#" != "1" ]; then
        log_e "Usage: ${FUNCNAME[0]} [<PROJECT_BIN> <SRC_DIR>]"
        log_e "${FUNCNAME[0]} $# ${*}"
    else
        log_m "${FUNCNAME[0]} $# ${*}"
        cd "${TOP_DIR:?}" || exit 1

        if [ "$#" == "1" ]; then
            local PROJECT_BIN=${1}
            local SRC_DIR=${2}
        fi

        pkill -9 ${PROJECT_GO_BIN}
    fi
}

function project_npm_bin_stop() {
    if [ "$#" != "0" ] && [ "$#" != "1" ]; then
        log_e "Usage: ${FUNCNAME[0]} [<PROJECT_BIN> <SRC_DIR>]"
        log_e "${FUNCNAME[0]} $# ${*}"
    else
        log_m "${FUNCNAME[0]} $# ${*}"
        cd "${TOP_DIR:?}" || exit 1

        if [ "$#" == "1" ]; then
            local PROJECT_BIN=${1}
            local SRC_DIR=${2}
        fi

        pkill -9 ${PROJECT_NPM_BIN}
    fi
}

function project_pip_bin_stop() {
    if [ "$#" != "0" ] && [ "$#" != "1" ]; then
        log_e "Usage: ${FUNCNAME[0]} [<PROJECT_BIN> <SRC_DIR>]"
        log_e "${FUNCNAME[0]} $# ${*}"
    else
        log_m "${FUNCNAME[0]} $# ${*}"
        cd "${TOP_DIR:?}" || exit 1

        if [ "$#" == "1" ]; then
            local PROJECT_BIN=${1}
            local SRC_DIR=${2}
        fi

        pkill -9 ${PROJECT_PYTHON_BIN}
    fi
}

function docker_stop() {
    if [ "$#" != "0" ] && [ "$#" != "1" ] && [ "$#" != "2" ]; then
        log_e "Usage: ${FUNCNAME[0]} <DOCKER_PROJECT> [<REMOVE_CONTAINER>]"
        log_e "${FUNCNAME[0]} $# ${*}"
    else
        log_m "${FUNCNAME[0]} $# ${*}"

        if [ "$#" == "1" ]; then
            local DOCKER_PROJECT=${1} # ${GITHUB_PROJECT}
            local REMOVE_CONTAINER=true
        elif [ "$#" == "2" ]; then
            local DOCKER_PROJECT=${1} # ${GITHUB_PROJECT}
            local REMOVE_CONTAINER=${2}
        fi

        docker stop ${DOCKER_PROJECT}
        if [ ${REMOVE_CONTAINER} == true ]; then
            docker rm ${DOCKER_PROJECT}
        fi
    fi
}

function docker_stop_all() {
    if [ "$#" != "0" ]; then
        log_e "Usage: ${FUNCNAME[0]} <DOCKER_PROJECT>"
        log_e "${FUNCNAME[0]} $# ${*}"
    else
        log_m "${FUNCNAME[0]} $# ${*}"

        docker stop $(docker ps -a -q)
        docker_clean
    fi
}

function podman_stop() {
    if [ "$#" != "0" ] && [ "$#" != "1" ] && [ "$#" != "2" ]; then
        log_e "Usage: ${FUNCNAME[0]} <PODMAN_PROJECT> [<REMOVE_CONTAINER>]"
        log_e "${FUNCNAME[0]} $# ${*}"
    else
        log_m "${FUNCNAME[0]} $# ${*}"

        if [ "$#" == "1" ]; then
            local PODMAN_PROJECT=${1} # ${GITHUB_PROJECT}
            local REMOVE_CONTAINER=true
        elif [ "$#" == "2" ]; then
            local DOCKER_PROJECT=${1} # ${GITHUB_PROJECT}
            local REMOVE_CONTAINER=${2}
        fi

        podman stop ${PODMAN_PROJECT}
        if [ "${REMOVE_CONTAINER}" == true ]; then
            podman rm ${DOCKER_PROJECT}
        fi
    fi
}

#******************************************************************************
#******************************************************************************
# deploy_infrastructure

# function deploy_infrastructure() {
#     if [ "$#" != "2" ]; then
#         log_e "Usage: ${FUNCNAME[0]} <PLATFORM> <PLATFORM_DISTRO>"
#     else
#         log_m "${FUNCNAME[0]} $# ${*}"
#         cd "${DEPLOYMENT_PLATFORM_DISTRO_TOP_DIR}" || exit 1
# }

#******************************************************************************
# undeploy_infrastructure

# function undeploy_infrastructure() {
#     if [ "$#" != "2" ]; then
#         log_e "Usage: ${FUNCNAME[0]}  <PLATFORM> <PLATFORM_DISTRO>"
#     else
#         log_m "${FUNCNAME[0]} $# ${*}"
#         cd "${DEPLOYMENT_PLATFORM_DISTRO_TOP_DIR}" || exit 1
#     fi
# }

#******************************************************************************
#******************************************************************************
# deploy

# function deploy() {
#     if [ "$#" != "1" ]; then
#         log_e "Usage: ${FUNCNAME[0]} <ARGS>"
#         log_e "${FUNCNAME[0]} $# ${*}"
#     else
#         log_m "${FUNCNAME[0]} $# ${*}"
#         cd "${TOP_DIR:?}" || exit 1
#     fi
# }

function ansible_deploy() {
    if [ "$#" != "0" ] && [ "$#" != "1" ]; then
        log_e "Usage: ${FUNCNAME[0]} [<PROJECT_BIN> <SRC_DIR>]"
        log_e "${FUNCNAME[0]} $# ${*}"
    else
        log_m "${FUNCNAME[0]} $# ${*}"
        cd "${TOP_DIR:?}" || exit 1

        if [ "$#" == "1" ]; then
            local PROJECT_BIN=${1}
            local SRC_DIR=${2}
        fi

    fi
}

function k8s_helm_deploy() {
    if [ "$#" != "0" ] && [ "$#" != "1" ]; then
        log_e "Usage: ${FUNCNAME[0]} [<PROJECT_BIN> <SRC_DIR>]"
        log_e "${FUNCNAME[0]} $# ${*}"
    else
        log_m "${FUNCNAME[0]} $# ${*}"
        cd "${TOP_DIR:?}" || exit 1

        if [ "$#" == "1" ]; then
            local PROJECT_BIN=${1}
            local SRC_DIR=${2}
        fi

    fi
}

function k8s_manifest_deploy() {
    if [ "$#" != "0" ] && [ "$#" != "1" ]; then
        log_e "Usage: ${FUNCNAME[0]} [<PROJECT_BIN> <SRC_DIR>]"
        log_e "${FUNCNAME[0]} $# ${*}"
    else
        log_m "${FUNCNAME[0]} $# ${*}"
        cd "${TOP_DIR:?}" || exit 1

        if [ "$#" == "1" ]; then
            local PROJECT_BIN=${1}
            local SRC_DIR=${2}
        fi

    fi
}

function terraform_deploy() {
    if [ "$#" != "0" ] && [ "$#" != "3" ]; then
        log_e "Usage: ${FUNCNAME[0]} <DEPLOYMENT_PLATFORM_DISTRO_TOP_DIR> <PLATFORM> <PLATFORM_DISTRO>"
        log_e "${FUNCNAME[0]} $# ${*}"
    else
        log_m "${FUNCNAME[0]} $# ${*}"
        # cd "${TOP_DIR:?}" || exit 1

        if [ "$#" == "3" ]; then
            local DEPLOYMENT_PLATFORM_DISTRO_TOP_DIR=${1}
            local PLATFORM=${2}
            local PLATFORM_DISTRO=${3}
        fi

        case ${PLATFORM} in
            aws | azure | gcp) ;;
            libvirt) ;;
            openstack) ;;
            vmware | vsphere) ;;
            *) ;;
        esac

        case ${PLATFORM_DISTRO} in
            # alpine) ;;
            # centos | fedora | rhel | debian | raspios | ubuntu | opensuse-leap | opensuse-tumbleweed | sles) ;;
            # cirros) ;;
            # macos | macosx) ;;
            # microsoft) ;;
            *) ;;
        esac

        rm -rf "${HOME}/.ssh/known_hosts"
        cd "${DEPLOYMENT_PLATFORM_DISTRO_TOP_DIR}" || exit 1
        ${USER_BIN}/terraform init
        # ${USER_BIN}/terraform plan
        ${USER_BIN}/terraform apply -auto-approve
    fi
}

#******************************************************************************
# undeploy

# function undeploy() {
#     if [ "$#" != "1" ]; then
#         log_e "Usage: ${FUNCNAME[0]} <ARGS>"
#         log_e "${FUNCNAME[0]} $# ${*}"
#     else
#         log_m "${FUNCNAME[0]} $# ${*}"
#         cd "${TOP_DIR:?}" || exit 1
#     fi
# }

function ansible_undeploy() {
    if [ "$#" != "0" ] && [ "$#" != "1" ]; then
        log_e "Usage: ${FUNCNAME[0]} [<PROJECT_BIN> <SRC_DIR>]"
        log_e "${FUNCNAME[0]} $# ${*}"
    else
        log_m "${FUNCNAME[0]} $# ${*}"
        cd "${TOP_DIR:?}" || exit 1

        if [ "$#" == "1" ]; then
            local PROJECT_BIN=${1}
            local SRC_DIR=${2}
        fi

    fi
}

function k8s_helm_undeploy() {
    if [ "$#" != "0" ] && [ "$#" != "1" ]; then
        log_e "Usage: ${FUNCNAME[0]} [<PROJECT_BIN> <SRC_DIR>]"
        log_e "${FUNCNAME[0]} $# ${*}"
    else
        log_m "${FUNCNAME[0]} $# ${*}"
        cd "${TOP_DIR:?}" || exit 1

        if [ "$#" == "1" ]; then
            local PROJECT_BIN=${1}
            local SRC_DIR=${2}
        fi

    fi
}

function k8s_manifest_undeploy() {
    if [ "$#" != "0" ] && [ "$#" != "1" ]; then
        log_e "Usage: ${FUNCNAME[0]} [<PROJECT_BIN> <SRC_DIR>]"
        log_e "${FUNCNAME[0]} $# ${*}"
    else
        log_m "${FUNCNAME[0]} $# ${*}"
        cd "${TOP_DIR:?}" || exit 1

        if [ "$#" == "1" ]; then
            local PROJECT_BIN=${1}
            local SRC_DIR=${2}
        fi

    fi
}

function terraform_undeploy() {
    if [ "$#" != "0" ] && [ "$#" != "3" ]; then
        log_e "Usage: ${FUNCNAME[0]} <DEPLOYMENT_PLATFORM_DISTRO_TOP_DIR> <PLATFORM> <PLATFORM_DISTRO>"
        log_e "${FUNCNAME[0]} $# ${*}"
    else
        log_m "${FUNCNAME[0]} $# ${*}"
        # cd "${TOP_DIR:?}" || exit 1

        if [ "$#" == "3" ]; then
            local DEPLOYMENT_PLATFORM_DISTRO_TOP_DIR=${1}
            local PLATFORM=${2}
            local PLATFORM_DISTRO=${3}
        fi

        cd "${DEPLOYMENT_PLATFORM_DISTRO_TOP_DIR}" || exit 1
        ${USER_BIN}/terraform destroy -auto-approve -parallelism=1

        case ${PLATFORM} in
            aws | azure | gcp) ;;
            libvirt) ;;
            openstack) ;;
            vmware | vsphere) ;;
            *) ;;
        esac

        case ${PLATFORM_DISTRO} in
            # alpine) ;;
            # centos | fedora | rhel | debian | raspios | ubuntu | opensuse-leap | opensuse-tumbleweed | sles) ;;
            # cirros) ;;
            # macos | macosx) ;;
            # microsoft) ;;
            *) ;;
        esac
    fi
}

#******************************************************************************
# upgrade

# function upgrade() {
#     if [ "$#" != "1" ]; then
#         log_e "Usage: ${FUNCNAME[0]} <ARGS>"
#         log_e "${FUNCNAME[0]} $# ${*}"
#     else
#         log_m "${FUNCNAME[0]} $# ${*}"
#         cd "${TOP_DIR:?}" || exit 1
#     fi
# }

#******************************************************************************
# snapshot

# function snapshot() {
#     if [ "$#" != "1" ]; then
#         log_e "Usage: ${FUNCNAME[0]} <ARGS>"
#         log_e "${FUNCNAME[0]} $# ${*}"
#     else
#         log_m "${FUNCNAME[0]} $# ${*}"
#         cd "${TOP_DIR:?}" || exit 1
#

#******************************************************************************
# backup

# function backup() {
#     if [ "$#" != "1" ]; then
#         log_e "Usage: ${FUNCNAME[0]} <ARGS>"
#         log_e "${FUNCNAME[0]} $# ${*}"
#     else
#         log_m "${FUNCNAME[0]} $# ${*}"
#         cd "${TOP_DIR:?}" || exit 1
#     fi
# }

#******************************************************************************
# restore

# function restore() {
#     if [ "$#" != "1" ]; then
#         log_e "Usage: ${FUNCNAME[0]} <ARGS>"
#         log_e "${FUNCNAME[0]} $# ${*}"
#     else
#         log_m "${FUNCNAME[0]} $# ${*}"
#         cd "${TOP_DIR:?}" || exit 1
#     fi
# }

#******************************************************************************
#******************************************************************************
# status

function status() {
    if [ "$#" != "0" ] && [ "$#" != "2" ]; then
        log_e "Usage: ${FUNCNAME[0]} <PROJECT_BIN> <INSTALL_METHODD>"
        log_e "${FUNCNAME[0]} $# ${*}"
    else
        log_m "${FUNCNAME[0]} $# ${*}"
        cd "${TOP_DIR:?}" || exit 1

        # case ${PLATFORM} in
        #     aws | azure | gcp) ;;
        #     libvirt) ;;
        #     openstack) ;;
        #     vmware | vsphere) ;;
        #     *) ;;
        # esac

        # case ${DISTRO} in
        #     alpine) ;;
        #     centos | fedora | rhel | debian | raspios | ubuntu | opensuse-leap | opensuse-tumbleweed | sles) ;;
        #     cirros) ;;
        #     macos | macosx) ;;
        #     microsoft) ;;
        #     *) ;;
        # esac

        # case ${PROJECT_TYPE} in
        #     *) ;;
        # esac

        # case ${DEPLOYMENT_TYPE} in
        #     *) ;;
        # esac

        if [ "$#" == "2" ]; then
            local PROJECT_BIN=${1}
            local PROJECT_GO_BIN=${1}
            local PROJECT_NPM_BIN=${1}
            local PROJECT_PYTHON_BIN=${1}
            local INSTALL_METHOD=${2}
        fi

        if [ -e /etc/systemd/system/${SYSTEMD_SERVICE_NAME}.service ]; then
            case ${DISTRO} in
                alpine) ;;
                alma-linux | arch-linux | chromeos | coreos | gentoo | hyperiotos | oracle-linux | photonos | rocky-linux) ;;
                centos | fedora | rhel | debian | raspios | ubuntu | opensuse-leap | opensuse-tumbleweed | sles)
                    echo -e "\n>>> status service...\n"
                    sudo systemctl status ${SYSTEMD_SERVICE_NAME}.service
                    ;;
                rancher-harvester | rancher-k3os | rancher-os) ;;
                cirros) ;;
                macos | macosx) ;;
                microsoft) ;;
                *) ;;
            esac
        else
            case ${INSTALL_METHOD} in
                bin | tar | bz2 | xz | zstd | rar | zip | script | rpm)
                    if [ $(which ${PROJECT_BIN} 2>/dev/null | wc -l) == 1 ]; then
                        ${PROJECT_BIN} --status 2>/dev/null
                        ${PROJECT_BIN} status 2>/dev/null
                    fi
                    if [ $(which ${PROJECT_BIN}ctl 2>/dev/null | wc -l) == 1 ]; then
                        ${PROJECT_BIN}ctl --status 2>/dev/null
                        ${PROJECT_BIN}ctl status 2>/dev/null
                    fi
                    ;;
                go)
                    if [ $(which ${PROJECT_GO_BIN} 2>/dev/null | wc -l) == 1 ]; then
                        ${PROJECT_GO_BIN} --status 2>/dev/null
                        ${PROJECT_GO_BIN} status 2>/dev/null
                    fi
                    ;;
                npm)
                    if [ $(which ${PROJECT_NPM_BIN} 2>/dev/null | wc -l) == 1 ]; then
                        ${PROJECT_NPM_BIN} --status 2>/dev/null
                        ${PROJECT_NPM_BIN} status 2>/dev/null
                    fi
                    ;;
                pip)
                    if [ $(which ${PROJECT_PYTHON_BIN} 2>/dev/null | wc -l) == 1 ]; then
                        ${PROJECT_PYTHON_BIN} --status 2>/dev/null
                        ${PROJECT_PYTHON_BIN} status 2>/dev/null
                    fi
                    ;;
                docker) ;;
                podman) ;;

                *) ;;
            esac
        fi
    fi
}

# function show_infrastructure_status() {}

function show_k8s_status() {
    if [ "$#" != "0" ]; then
        log_e "Usage: ${FUNCNAME[0]} <NAMESPACES>"
        log_e "${FUNCNAME[0]} $# ${*}"
    else
        log_m "${FUNCNAME[0]} $# ${*}"
        cd "${TOP_DIR:?}" || exit 1

        if [ $(which ${minikube} 2>/dev/null | wc -l) == 1 ]; then
            echo -e "\n>>> Show Minikube status...\n"
            minikube status
            minikube ip
        fi

        echo -e "\n>>> kubectl version...\n"
        kubectl version

        # echo -e "\n>>> kubectl api-versions...\n"
        # kubectl api-versions

        # echo -e "\n>>> kubectl config view...\n"
        # kubectl config view

        # echo -e "\n>>> kubectl api-resources...\n"
        # kubectl api-resources

        echo -e "\n>>> Get k8s Cluster Info...\n"
        kubectl cluster-info

        echo -e "\n>>> Get Node Info...\n"
        kubectl get nodes -o wide

        echo -e "\n>>> Get k8s Top Node Status...\n"
        kubectl top nodes --use-protocol-buffers

        echo -e "\n>>> Get Helm Chart Releases...\n"
        helm status "${RELEASE}" --namespace=${NAMESPACE}
        helm list --all-namespaces

        echo -e "\n>>> Get Namespaces...\n"
        kubectl get namespace

        echo -e "\n>>> Get Images...\n"
        # kubectl get pods --all-namespaces -o jsonpath="{.items[*].spec.containers[*].image}"
        kubectl get pods --all-namespaces -o jsonpath="{..image}" | tr -s '[[:space:]]' '\n' | sort | uniq -c

        if [ "${NAMESPACES}" == "" ]; then
            # NAMESPACES="kube-system default"
            NAMESPACES="kube-system default cattle-system fleet-system cattle-monitoring-system ${NAMESPACE}"
            # NAMESPACES="${MINIO_NAMESPACE} ${ETCD_NAMESPACE} ${SERVER_NAMESPACE} ${SERVICE_NAMESPACE} ${APP_NAMESPACE}"
        fi

        echo -e "\n--------------------------------------------------------------------------------\n"

        for NAMESPACE in ${NAMESPACES[*]}; do
            echo -e "\n>>> Get k8s Cluster Status (${NAMESPACE})...\n"
            # kubectl get crd,ns,all,statefulset,endpoints --namespace=${NAMESPACE} -l "${LABEL}" -o wide
            # kubectl get crd,ns,all,statefulset,endpoints --namespace=${NAMESPACE} --show-labels -o wide
            kubectl get crd,ns,all,statefulset,endpoints --namespace=${NAMESPACE} -o wide

            # echo -e "\n>>> Get Pod (${NAMESPACE})...\n"
            # kubectl get pods --namespace=${NAMESPACE} --show-labels -o wide
            # kubectl get pods --namespace=${NAMESPACE} --sort-by='{.spec.nodeName}' -o wide

            echo -e "\n>>> Get k8s cm,secret,sc,pv,pvc (${NAMESPACE})...\n"
            kubectl get cm,secret,sc,pv,pvc --namespace=${NAMESPACE} --show-labels -o wide

            echo -e "\n>>> Get k8s Top Pod Status (${NAMESPACE})...\n"
            kubectl top pods --use-protocol-buffers --namespace=${NAMESPACE}

            # echo -e "\n>>> Get cronjobs (${NAMESPACE})...\n"
            # kubectl get cronjobs --namespace=${APP_NAMESPACE} -o wide

            echo -e "\n--------------------------------------------------------------------------------\n"
        done
    fi
}

function show_k8s_vm_status() {
    if [ "$#" != "0" ]; then
        log_e "Usage: ${FUNCNAME[0]} <ARGS>"
        log_e "${FUNCNAME[0]} $# ${*}"
    else
        log_m "${FUNCNAME[0]} $# ${*}"
        # cd "${TOP_DIR:?}" || exit 1

        for NAMESPACE in ${NAMESPACES[*]}; do

            echo -e "\n>>> Get k8s sc,pv,pvc (${NAMESPACE})...\n"
            kubectl get cm,sc,pv,pvc --namespace=${NAMESPACE} --show-labels -o wide

            echo -e "\n>>> Get k8s dv,vm,vmi,svc (${NAMESPACE})...\n"
            kubectl get dv,vm,vmi,svc --namespace=${NAMESPACE} --show-labels -o wide

            # echo -e "\n>>> Get k8s dv,vm,vmi,svc (${NAMESPACE})...\n"
            # kubectl get podsecuritypolicies,clusterrolebindings,clusterroles,rolebindings,roles --namespace=${NAMESPACE} --show-labels -o wide

            echo -e "\n--------------------------------------------------------------------------------\n"
        done
    fi
}

function show_docker_status() {
    if [ "$#" != "0" ]; then
        log_e "Usage: ${FUNCNAME[0]} <ARGS>"
        log_e "${FUNCNAME[0]} $# ${*}"
    else
        log_m "${FUNCNAME[0]} $# ${*}"
        # cd "${TOP_DIR:?}" || exit 1

        echo -e "\n>>> Show Docker Services...\n"
        docker ps -a
        echo -e "\n>>> Show Docker Volumes...\n"
        docker volume ls
        echo -e "\n>>> Show Docker Networks...\n"
        docker network ls
        echo -e "\n>>> Show Docker Images...\n"
        docker images
    fi
}

# function show_app_status() {}

#******************************************************************************
# bash

function docker_bash() {
    if [ "$#" != "0" ] && [ "$#" != "2" ]; then
        log_e "Usage: ${FUNCNAME[0]} <DOCKER_PROJECT> <DOCKER_TAG>"
        log_e "${FUNCNAME[0]} $# ${*}"
    else
        log_m "${FUNCNAME[0]} $# ${*}"

        if [ "$#" == "2" ]; then
            local DOCKER_PROJECT=${1} # ${GITHUB_PROJECT}
            local DOCKER_TAG=${2}
        fi

        bash -c "clear && docker run --rm -ti --network host --entrypoint "" --name ${DOCKER_PROJECT} ${DOCKER_PROJECT}:${DOCKER_TAG} /bin/bash"
        # bash -c "clear && docker run --rm -ti --network host --entrypoint "" --name ${DOCKER_PROJECT} ${DOCKER_PROJECT}:${DOCKER_TAG} /bin/sh"
    fi
}

function docker_bash_to_container() {
    if [ "$#" != "0" ] && [ "$#" != "1" ]; then
        log_e "Usage: ${FUNCNAME[0]} <DOCKER_PROJECT>"
        log_e "${FUNCNAME[0]} $# ${*}"
    else
        log_m "${FUNCNAME[0]} $# ${*}"

        if [ "$#" == "1" ]; then
            local DOCKER_PROJECT=${1} # ${GITHUB_PROJECT}
        fi

        bash -c "clear && docker exec -it ${DOCKER_PROJECT} /bin/bash"
        if [ $? != 0 ]; then
            bash -c "clear && docker exec -it ${DOCKER_PROJECT} /bin/sh"
        fi
    fi
}

function podman_bash() {
    if [ "$#" != "0" ] && [ "$#" != "2" ]; then
        log_e "Usage: ${FUNCNAME[0]} <PODMAN_PROJECT> <PODMAN_TAG>"
        log_e "${FUNCNAME[0]} $# ${*}"
    else
        log_m "${FUNCNAME[0]} $# ${*}"

        if [ "$#" == "2" ]; then
            local PODMAN_PROJECT=${1} # ${GITHUB_PROJECT}
            local DOCKER_TAG=${2}
        fi

        bash -c "clear && podman run --rm -ti --network host --entrypoint "" --name ${PODMAN_PROJECT} ${PODMAN_PROJECT}:${DOCKER_TAG} /bin/bash"
        # bash -c "clear && podman run --rm -ti --network host --entrypoint "" --name ${PODMAN_PROJECT} ${PODMAN_PROJECT}:${DOCKER_TAG} /bin/sh"
    fi
}

function podman_bash_to_container() {
    if [ "$#" != "0" ] && [ "$#" != "1" ]; then
        log_e "Usage: ${FUNCNAME[0]} <PODMAN_PROJECT>"
        log_e "${FUNCNAME[0]} $# ${*}"
    else
        log_m "${FUNCNAME[0]} $# ${*}"

        if [ "$#" == "1" ]; then
            local PODMAN_PROJECT=${1} # ${GITHUB_PROJECT}
        fi

        bash -c "clear && podman exec -it ${PODMAN_PROJECT} /bin/bash"
        # bash -c "clear && podman exec -it ${PODMAN_PROJECT} /bin/sh"
    fi
}

function kubectl_bash_to_container() {
    if [ "$#" != "0" ] && [ "$#" != "2" ]; then
        log_e "Usage: ${FUNCNAME[0]} <POD_NAME> <NAMESPACE>"
        log_e "${FUNCNAME[0]} $# ${*}"
    else
        log_m "${FUNCNAME[0]} $# ${*}"

        if [ "$#" == "2" ]; then
            local POD_NAME=${1} # ${GITHUB_PROJECT}
            local NAMESPACE=${2}
        fi

        bash -c "clear && kubectl exec -it ${POD_NAME} --namespace=${NAMESPACE} -- /bin/bash"
        # bash -c "clear && kubectl exec -it ${POD_NAME} --namespace=${NAMESPACE} -- /bin/sh"
    fi
}

#******************************************************************************
# service

# function access_service() {
#     if [ "$#" != "1" ]; then
#         log_e "Usage: ${FUNCNAME[0]} <ARGS>"
#         log_e "${FUNCNAME[0]} $# ${*}"
#     else
#         log_m "${FUNCNAME[0]} $# ${*}"
#         cd "${TOP_DIR:?}" || exit 1
#     fi
# }

# function ssh_to_node() {
#     if [ "$#" != "1" ]; then
#         log_e "Usage: ${FUNCNAME[0]} <ARGS>"
#         log_e "${FUNCNAME[0]} $# ${*}"
#     else
#         log_m "${FUNCNAME[0]} $# ${*}"
#         cd "${TOP_DIR:?}" || exit 1
#     fi
# }

#******************************************************************************
# version

function get_version() {
    if [ "$#" != "0" ] && [ "$#" != "2" ]; then
        log_e "Usage: ${FUNCNAME[0]} <PROJECT_BIN> <INSTALL_METHODD>"
        log_e "${FUNCNAME[0]} $# ${*}"
    else
        log_m "${FUNCNAME[0]} $# ${*}"
        cd "${TOP_DIR:?}" || exit 1

        # case ${PLATFORM} in
        #     aws | azure | gcp) ;;
        #     libvirt) ;;
        #     openstack) ;;
        #     vmware | vsphere) ;;
        #     *) ;;
        # esac

        # case ${DISTRO} in
        #     alpine) ;;
        #     centos | fedora | rhel | debian | raspios | ubuntu | opensuse-leap | opensuse-tumbleweed | sles) ;;
        #     cirros) ;;
        #     macos | macosx) ;;
        #     microsoft) ;;
        #     *) ;;
        # esac

        # case ${PROJECT_TYPE} in
        #     *) ;;
        # esac

        # case ${DEPLOYMENT_TYPE} in
        #     *) ;;
        # esac

        if [ "$#" == "2" ]; then
            local PROJECT_BIN=${1}
            local PROJECT_GO_BIN=${1}
            local PROJECT_NPM_BIN=${1}
            local PROJECT_PYTHON_BIN=${1}
            local INSTALL_METHOD=${2}
        fi

        case ${INSTALL_METHOD} in
            bin | tar | bz2 | xz | zstd | rar | zip | script | rpm)
                if [ $(which ${PROJECT_BIN} 2>/dev/null | wc -l) == 1 ]; then
                    ${PROJECT_BIN} --version 2>/dev/null
                    ${PROJECT_BIN} version 2>/dev/null
                fi
                if [ $(which ${PROJECT_BIN}ctl 2>/dev/null | wc -l) == 1 ]; then
                    ${PROJECT_BIN}ctl --version 2>/dev/null
                    ${PROJECT_BIN}ctl version 2>/dev/null
                fi
                ;;
            go)
                if [ $(which ${PROJECT_GO_BIN} 2>/dev/null | wc -l) == 1 ]; then
                    ${PROJECT_GO_BIN} --version 2>/dev/null
                    ${PROJECT_GO_BIN} version 2>/dev/null
                fi
                ;;
            npm)
                if [ $(which ${PROJECT_NPM_BIN} 2>/dev/null | wc -l) == 1 ]; then
                    ${PROJECT_NPM_BIN} --version 2>/dev/null
                    ${PROJECT_NPM_BIN} version 2>/dev/null
                fi
                ;;
            pip)
                if [ $(which ${PROJECT_PYTHON_BIN} 2>/dev/null | wc -l) == 1 ]; then
                    ${PROJECT_PYTHON_BIN} --version 2>/dev/null
                    ${PROJECT_PYTHON_BIN} version 2>/dev/null
                fi
                ;;
            docker) ;;
            podman) ;;

            *) ;;
        esac
    fi
}

#******************************************************************************
# lint

# function lint() {
#     if [ "$#" != "0" ]; then
#         log_e "Usage: ${FUNCNAME[0]} <PROJECT_BIN>"
#     else
#         log_m "${FUNCNAME[0]} $# ${*}"
#         cd "${SRC_DIR:?}" || exit 1

#         # local PROJECT_BIN= #
#         case ${INSTALL_METHOD} in
#             bin | tar | bz2 | xz | zstd | rar | zip | script | rpm)
#                 # local PROJECT_BIN= #
#                 if [ -e "${USER_BIN}/${PROJECT_BIN}" ]; then
#                     echo -e "\n>>> Run ${USER_BIN}/${PROJECT_BIN} for extension (${EXTENSION}) at ${SRC_DIR}...\n"
#                     # find ${SRC_DIR} -type f -name "*.${EXTENSION}" -exec ${PROJECT_BIN} "{}" \;
#                     ${PROJECT_BIN} } --recursive
#                 fi
#                 if [ -e "${USER_BIN}/${PROJECT_BIN}ctl" ]; then
#                     echo -e "\n>>> Run ${USER_BIN}/${PROJECT_BIN}ctl...\n"
#                     # find ${SRC_DIR} -type f -name "*.${EXTENSION}" -exec ${PROJECT_BIN}ctl "{}" \;
#                     ${PROJECT_BIN}ctl
#                 fi
#                 ;;
#             go)
#                 if [ -e "${HOME}/go/bin/${PROJECT_GO_BIN}" ]; then
#                     echo -e "\n>>> Run ${HOME}/go/bin/${PROJECT_GO_BIN} for extension (${EXTENSION}) at ${SRC_DIR}...\n"
#                     # find ${SRC_DIR} -type f -name "*.${EXTENSION}" -exec ${PROJECT_GO_BIN} "{}" \;
#                     ${PROJECT_GO_BIN}
#                 fi
#                 ;;
#             npm)
#                 if [ -e "${HOME}/.nvm/versions/node/$(node --version)/bin/${PROJECT_NPM_BIN}" ]; then
#                     echo -e "\n>>> Run ${HOME}/.nvm/versions/node/$(node --version)/bin/${PROJECT_NPM_BIN} for extension (${EXTENSION}) at ${SRC_DIR}...\n"
#                     # find ${SRC_DIR} -type f -name "*.${EXTENSION}" -exec ${PROJECT_NPM_BIN} "{}" \;
#                     ${PROJECT_NPM_BIN}
#                 fi
#                 ;;
#             pip)
#                 if [ -e "${USER_BIN}/${PROJECT_PYTHON_BIN}" ]; then
#                     echo -e "\n>>> Run ${USER_BIN}/${PROJECT_PYTHON_BIN} for extension (${EXTENSION}) at ${SRC_DIR}...\n"
#                     # find ${SRC_DIR} -type f -name "*.${EXTENSION}" -exec ${PROJECT_PYTHON_BIN} "{}" \;
#                     ${PROJECT_PYTHON_BIN}
#                 fi
#                 ;;
#             docker)
#                 docker_start
#                 ;;
#             podman)
#                 podman_start
#                 ;;
#             *) ;;
#         esac
#     fi
# }

#******************************************************************************
# build

function build_project() {
    if [ "$#" != "0" ] && [ "$#" != "1" ]; then
        log_e "Usage: ${FUNCNAME[0]} <PROJECT_TYPE>"
        log_e "${FUNCNAME[0]} $# ${*}"
    else
        log_m "${FUNCNAME[0]} $# ${*}"
        cd "${TOP_DIR:?}" || exit 1

        if [ "$#" == "1" ]; then
            local DISTPROJECT_TYPERO=${1}
        fi

        case ${PROJECT_TYPE} in
            helm3_app) build_helm3_app_project ;;
            golang_app) build_golang_app_project ;;
            typescript_app) build_typescript_app_project ;;
            python3_app) build_python3_app_project ;;
            rust_app) build_rust_app_project ;;
            *) ;;
        esac
    fi
}

# https://golang.org/doc/install/source
function build_golang_app_project() {
    if [ "$#" != "1" ] && [ "$#" != "2" ]; then
        echo "Usage: ${FUNCNAME[0]} <SRC_DIR> [<CROSS_BUILD>]"
    else
        echo "${FUNCNAME[0]} $# ${*}"
        # cd "${TOP_DIR:?}" || exit 1

        if [ "$#" == "1" ]; then
            local SRC_DIR=${1}
            local CROSS_BUILD=false
        elif [ "$#" == "2" ]; then
            local SRC_DIR=${1}
            local CROSS_BUILD=${2}
        fi

        cd "${SRC_DIR:?}" || exit 1

        # rm -rf build bin
        # mkdir -p bin

        if git rev-parse --git-dir >/dev/null 2>&1; then
            : # This is a valid git repository (but the current working
            # directory may not be the top level.
            # Check the output of the git rev-parse command if you care)
            local VERSION=$(git describe --match 'v[0-9]*' --dirty='-dirty' --always)
            local REVISION=$(git rev-parse HEAD)$(if ! git diff --no-ext-diff --quiet --exit-code; then echo "-dirty"; fi)
        else
            : # this is not a git repository
            local VERSION=unknown
            local REVISION=unknown
        fi
        local BUID_DATE=$(date -u '+%Y-%m-%dT%H:%M:%SZ')

        if [ "$(uname -m)" = "Linux" ]; then
            local OTHER_LINKFLAGS="-extldflags '-static -s'"
        fi
        local APP_NAME=$(basename ${SRC_DIR})
        # local GO_TAGS="-a -tags netgo -installsuffix netgo"
        local GO_LDFLAGS="-w -s -X version.VERSION=${VERSION} -X version.REVISION=${REVISION} -X version.BUILD_DATE=${BUID_DATE} ${OTHER_LINKFLAGS}"

        local CROSS_PLATFORMS=($(go tool dist list))
        if [ "${CROSS_BUILD}" == 1 ]; then
            CROSS_PLATFORMS=(linux/amd64 linux/arm64 darwin/amd64 darwin/arm64 windows/amd64)
        else
            CROSS_PLATFORMS=($(go env GOHOSTOS)/$(go env GOARCH))
        fi

        for CROSS_PLATFORM in ${CROSS_PLATFORMS[*]}; do
            local CROSS_PLATFORM_ARRAY=($(echo ${CROSS_PLATFORM} | sed -e 's/\// /g'))
            local OS=${CROSS_PLATFORM_ARRAY[0]}
            local ARCH=${CROSS_PLATFORM_ARRAY[1]}
            local OUTPUT_BIN="build/bin/${APP_NAME}-${OS}-${ARCH}"
            if test "${OS}" = "windows"; then
                OUTPUT_BIN="${OUTPUT_BIN}.exe"
            fi
            echo -e "\n>>> Building binary for ${OUTPUT_BIN}..."
            if [ -e "./main.go" ]; then
                CGO_ENABLED=0 GOARCH=${ARCH} GOOS=${OS} go build -ldflags "${GO_LDFLAGS}" -o ${OUTPUT_BIN} main.go
            else
                CGO_ENABLED=0 GOARCH=${ARCH} GOOS=${OS} go build -ldflags "${GO_LDFLAGS}" ./
            fi
        done
        cp ./bin/${APP_NAME}-$(uname -s | tr A-Z a-z)-$(uname -m | sed -e 's/x86_64/amd64/' -e 's/aarch64/arm64/') ./bin/${APP_NAME}
        file ./bin/${APP_NAME}*
    fi
}

function build_typescript_app_project() {
    if [ "$#" != "0" ]; then
        log_e "Usage: ${FUNCNAME[0]} <ROLE>"
        log_e "${FUNCNAME[0]} $# ${*}"
    else
        log_m "${FUNCNAME[0]} $# ${*}"
        # cd "${TOP_DIR:?}" || exit 1
    fi
}

function build_python3_app_project() {
    if [ "$#" != "0" ]; then
        log_e "Usage: ${FUNCNAME[0]} <ROLE>"
        log_e "${FUNCNAME[0]} $# ${*}"
    else
        log_m "${FUNCNAME[0]} $# ${*}"
        # cd "${TOP_DIR:?}" || exit 1
    fi
}

function build_rust_app_project() {
    if [ "$#" != "0" ]; then
        log_e "Usage: ${FUNCNAME[0]} <ROLE>"
        log_e "${FUNCNAME[0]} $# ${*}"
    else
        log_m "${FUNCNAME[0]} $# ${*}"
        # cd "${TOP_DIR:?}" || exit 1
    fi
}

#******************************************************************************
# log

function docker_logs() {
    if [ "$#" != "0" ] && [ "$#" != "1" ]; then
        log_e "Usage: ${FUNCNAME[0]} <DOCKER_PROJECT>"
        log_e "${FUNCNAME[0]} $# ${*}"
    else
        log_m "${FUNCNAME[0]} $# ${*}"

        if [ "$#" == "1" ]; then
            local DOCKER_PROJECT=${1} # ${GITHUB_PROJECT}
        fi

        docker logs $(DOCKER_PROJECT)
    fi
}

function podman_logs() {
    if [ "$#" != "0" ] && [ "$#" != "1" ]; then
        log_e "Usage: ${FUNCNAME[0]} <PODMAN_PROJECT>"
        log_e "${FUNCNAME[0]} $# ${*}"
    else
        log_m "${FUNCNAME[0]} $# ${*}"

        if [ "$#" == "1" ]; then
            local PODMAN_PROJECT=${1} # ${GITHUB_PROJECT}
        fi

        podman logs $(PODMAN_PROJECT)
    fi
}

function kubectl_logs() {
    if [ "$#" != "0" ] && [ "$#" != "2" ]; then
        log_e "Usage: ${FUNCNAME[0]} <POD_NAME> <NAMESPACE>"
        log_e "${FUNCNAME[0]} $# ${*}"
    else
        log_m "${FUNCNAME[0]} $# ${*}"

        if [ "$#" == "2" ]; then
            local POD_NAME=${1} # ${GITHUB_PROJECT}
            local NAMESPACE=${2}
        fi

        kubectl logs ${POD_NAME} --namespace=${NAMESPACE}
    fi
}

function remove_logs() {
    if [ "$#" != "4" ] && [ "$#" != "7" ]; then
        log_e "Usage: ${FUNCNAME[0]} <PLATFORM> <PLATFORM_DISTRO> <ROLE> <RUNTIME> [<CRI> <CNI> <CSI>]"
        log_e "${FUNCNAME[0]} $# ${*}"
    else
        log_m "${FUNCNAME[0]} $# ${*}"

        # if [ "$#" == "7" ]; then
        #     LOG_DIR="${TOP_DIR:?}/logs/providers/${PLATFORM}/${PLATFORM_DISTRO}/${CRI}_${CNI}_${CSI}"
        # else
        #     LOG_DIR="${TOP_DIR:?}/logs/providers/${PLATFORM}/${PLATFORM_DISTRO}"
        # fi
        # rm -rf ${LOG_DIR:?}
        rm -rf ${LOG_DIR:?} ${LOG_DIR:?}/logs.zip
    fi
}

function kubectl_get_logs() {
    if [ "$#" != "0" ] && [ "$#" != "1" ]; then
        log_e "Usage: ${FUNCNAME[0]} <NAMESPACES>"
        log_e "${FUNCNAME[0]} $# ${*}"
    else
        log_m "${FUNCNAME[0]} $# ${*}"
        # cd "${TOP_DIR:?}" || exit 1

        LOG_DIR=/tmp/logs
        rm -rf ${LOG_DIR:?} ${LOG_DIR:?}/logs.zip
        NAMESPACES="default kube-system longhorn-system"
        if [ "$#" == "1" ]; then
            local NAMESPACES=${1}
        fi

        for NAMESPACE in ${NAMESPACES[*]}; do

            LOG_TYPE=pods
            PODS=($(kubectl get pods --namespace=${NAMESPACE} -o jsonpath='{.items[*].metadata.name}'))
            mkdir -p ${LOG_DIR:?}/${LOG_TYPE}/${NAMESPACE}
            for POD in ${PODS[*]}; do
                echo -e "\n>>> Describe: ${POD} ...\n" >${LOG_DIR:?}/${LOG_TYPE}/${NAMESPACE}/${POD}-describe.log
                kubectl describe pod ${POD} --namespace=${NAMESPACE} >>${LOG_DIR:?}/${LOG_TYPE}/${NAMESPACE}/${POD}-describe.log
                echo -e "\n>>> Logs: ${POD} ...\n" >${LOG_DIR:?}/${LOG_TYPE}/${NAMESPACE}/${POD}-logs.log
                kubectl logs pod/${POD} --namespace=${NAMESPACE} >>${LOG_DIR:?}/${LOG_TYPE}/${NAMESPACE}/${POD}-logs.log
            done

            LOG_TYPE=manifests
            mkdir -p ${LOG_DIR:?}/${LOG_TYPE}/${NAMESPACE}
            API_RESOURCES=($(kubectl api-resources | awk '{print $1}' | tail -n +2 | tr '\n' ' '))
            for API_RESOURCE in ${API_RESOURCES[*]}; do
                kubectl get ${API_RESOURCE} --namespace ${NAMESPACE} -o yaml >>${LOG_DIR:?}/${LOG_TYPE}/${NAMESPACE}/${API_RESOURCE}.yaml
            done

            echo -e "\n>>> Storages ...\n" >${LOG_DIR:?}/storages_${NAMESPACE}.log
            kubectl get cm,secret,sc,pv,pvc --namespace=${NAMESPACE} --show-labels -o wide >>${LOG_DIR:?}/storages_${NAMESPACE}.log

            echo -e "\n>>> Events ...\n" >${LOG_DIR:?}/events_${NAMESPACE}.log
            kubectl get events --sort-by='{.lastTimestamp}' --namespace ${NAMESPACE} >>${LOG_DIR:?}/events_${NAMESPACE}.log
        done

        echo -e "\n>>> Get  cluster-info ...\n" >${LOG_DIR:?}/cluster-info.log
        kubectl cluster-info dump >>${LOG_DIR:?}/cluster-info.log

        echo -e "\n>>> Get Nodes ...\n" >${LOG_DIR:?}/nodes.log
        kubectl get nodes -o wide >>${LOG_DIR:?}/nodes.log

        echo -e "\n>>> Get Top Nodes ...\n" >${LOG_DIR:?}/top_nodes.log
        kubectl top nodes --use-protocol-buffers >>${LOG_DIR:?}/top_nodes.log

        echo -e "\n>>> Get Top Pods ...\n" >${LOG_DIR:?}/top_pods.log
        kubectl top pods --use-protocol-buffers --all-namespaces >>${LOG_DIR:?}/top_pods.log

        echo -e "\n>>> Get all ...\n" >${LOG_DIR:?}/get_all.log
        kubectl get crd,ns,all,statefulset,endpoints -o wide --all-namespaces >>${LOG_DIR:?}/get_all.log

        echo -e "\n>>> Get all job...\n" >${LOG_DIR:?}/get_all.log
        kubectl get cronjob,job -o wide --all-namespaces >>${LOG_DIR:?}/get_job.log

        echo -e "\n>>> Helm Charts ...\n" >${LOG_DIR:?}/helms_charts.log
        helm list --all-namespaces >>${LOG_DIR:?}/helms_charts.log

        get_terraform_ips ${DEPLOYMENT_PLATFORM_DISTRO_TOP_DIR} ${INFRASTRUCTURE_DEPLOYMENT_PROJECT}
        for IP in ${IPS[*]}; do
            echo -e "\n>>> ${IP}...\n"
            mkdir -p ${LOG_DIR:?}/nodes/${IP}/var/log
            case ${KUBERNETES_DISTRO} in
                k3s)
                    ssh ${SSH_USER}@${IP} -o StrictHostKeyChecking=no "sudo journalctl -xet k3s | cat" >${LOG_DIR:?}/nodes/${IP}/var/log/kubelet.log
                    ssh ${SSH_USER}@${IP} -o StrictHostKeyChecking=no "sudo cat /var/lib/rancher/k3s/agent/containerd/containerd.log" >${LOG_DIR:?}/nodes/${IP}/var/log/containerd.log
                    ;;
                rke2)
                    ssh ${SSH_USER}@${IP} -o StrictHostKeyChecking=no "sudo journalctl -xet rke2 | cat" >${LOG_DIR:?}/nodes/${IP}/var/log/kubelet.log
                    # ssh ${SSH_USER}@${IP} -o StrictHostKeyChecking=no "sudo cat /var/lib/rancher/rke2/agent/logs/kubelet.log" >${LOG_DIR:?}/nodes/${IP}/var/log/kubelet.log
                    ssh ${SSH_USER}@${IP} -o StrictHostKeyChecking=no "sudo cat /var/lib/rancher/rke2/agent/containerd/containerd.log" >${LOG_DIR:?}/nodes/${IP}/var/log/containerd.log
                    ;;
                rke)
                    # ssh ${SSH_USER}@${IP} -o StrictHostKeyChecking=no "sudo cat /var/lib/rancher/rke/log/etcd-rolling-*.log" >${LOG_DIR:?}/nodes/${IP}/var/log/etcd-rolling.log
                    # ssh ${SSH_USER}@${IP} -o StrictHostKeyChecking=no "sudo cat /var/lib/rancher/rke/log/kube-apiserver_*.log" >${LOG_DIR:?}/nodes/${IP}/var/log/kube-apiserver.log
                    # ssh ${SSH_USER}@${IP} -o StrictHostKeyChecking=no "sudo cat /var/lib/rancher/rke/log/kube-controller-manager_*.log" >${LOG_DIR:?}/nodes/${IP}/var/log/kube-controller-manager.log
                    # ssh ${SSH_USER}@${IP} -o StrictHostKeyChecking=no "sudo cat /var/lib/rancher/rke/log/kube-scheduler_*.log" >${LOG_DIR:?}/nodes/${IP}/var/log/kube-scheduler.log
                    # ssh ${SSH_USER}@${IP} -o StrictHostKeyChecking=no "sudo cat /var/lib/rancher/rke/log/kubelet_*.log" >${LOG_DIR:?}/nodes/${IP}/var/log/kubelet.log
                    # ssh ${SSH_USER}@${IP} -o StrictHostKeyChecking=no "sudo cat /var/lib/rancher/rke/log/kube-proxy_*.log" >${LOG_DIR:?}/nodes/${IP}/var/log/kube-proxy.log
                    ssh ${SSH_USER}@${IP} -o StrictHostKeyChecking=no "sudo journalctl -xet containerd | cat" >${LOG_DIR:?}/nodes/${IP}/var/log/containerd.log
                    ;;
                *) ;;
            esac
            # /var/lib/rancher/rke/logs/
        done
        code ${LOG_DIR:?}
        cd /tmp
        zip -r logs.zip logs
    fi
}

function copy_k8s_configuration_and_log_to_local() {
    if [ "$#" != "4" ] && [ "$#" != "7" ]; then
        log_e "Usage: ${FUNCNAME[0]} <PLATFORM> <PLATFORM_DISTRO> <ROLE> <RUNTIME> [<CRI> <CNI> <CSI>]"
        log_e "${FUNCNAME[0]} $# ${*}"
    else
        log_m "${FUNCNAME[0]} $# ${*}"

        if [ "$#" == "7" ]; then
            LOG_DIR="${TOP_DIR:?}/logs/providers/${PLATFORM}/${PLATFORM_DISTRO}/${CRI}_${CNI}_${CSI}"
            rm -rf ${LOG_DIR:?}
        else
            # LOG_DIR="${TOP_DIR:?}/logs/providers/${PLATFORM}/${PLATFORM_DISTRO}"
            LOG_DIR=/tmp/logs
            # rm -rf ${LOG_DIR:?}
        fi
        for IP in ${IPS[*]}; do
            echo -e "\n>>> ${IP}...\n"
            mkdir -p ${LOG_DIR:?}/${IP}/etc/{cloud,containerd,containers,crio,default,docker,iptables,kubernetes,modules-load.d,sysconfig,sysctl.d} \
                ${LOG_DIR:?}/${IP}/etc/kubernetes/{manifests,pki} \
                ${LOG_DIR:?}/${IP}/etc/cni/net.d \
                ${LOG_DIR:?}/${IP}/var/lib/{etcd,cni,kubelet} \
                ${LOG_DIR:?}/${IP}/usr/lib/{cloud-init,cni,crio,kubernetes,sysctl.d,systemd} \
                ${LOG_DIR:?}/${IP}/usr/lib/systemd/system/kubelet.service.d \
                ${LOG_DIR:?}/${IP}/lib/systemd/system/kubelet.service.d \
                ${LOG_DIR:?}/${IP}/var/lib/cloud/instance/scripts \
                ${LOG_DIR:?}/${IP}/var/log/{audit,containers}

            ssh ${SSH_USER}@${IP} -o StrictHostKeyChecking=no 'sudo cat /etc/cloud/cloud.cfg' >${LOG_DIR:?}/${IP}/etc/cloud/cloud.cfg
            ssh ${SSH_USER}@${IP} -o StrictHostKeyChecking=no 'sudo cat /etc/cni/net.d/10-cilium-cni.conf' >${LOG_DIR:?}/${IP}/etc/cni/net.d/10-cilium-cni.conf
            ssh ${SSH_USER}@${IP} -o StrictHostKeyChecking=no 'sudo cat /etc/cni/net.d/100-crio-bridge.conf' >${LOG_DIR:?}/${IP}/etc/cni/net.d/100-crio-bridge.conf
            ssh ${SSH_USER}@${IP} -o StrictHostKeyChecking=no 'sudo cat /etc/cni/net.d/200-loopback.conf' >${LOG_DIR:?}/${IP}/etc/cni/net.d/200-loopback.conf
            ssh ${SSH_USER}@${IP} -o StrictHostKeyChecking=no 'sudo cat /etc/containerd/config.toml' >${LOG_DIR:?}/${IP}/etc/containerd/config.toml
            ssh ${SSH_USER}@${IP} -o StrictHostKeyChecking=no 'sudo cat /etc/containers/mounts.conf' >${LOG_DIR:?}/${IP}/etc/containers/mounts.conf
            ssh ${SSH_USER}@${IP} -o StrictHostKeyChecking=no 'sudo cat /etc/containers/policy.json' >${LOG_DIR:?}/${IP}/etc/containers/policy.json
            ssh ${SSH_USER}@${IP} -o StrictHostKeyChecking=no 'sudo cat /etc/containers/registries.conf' >${LOG_DIR:?}/${IP}/etc/containers/registries.conf
            ssh ${SSH_USER}@${IP} -o StrictHostKeyChecking=no 'sudo cat /etc/containers/seccomp.json' >${LOG_DIR:?}/${IP}/etc/containers/seccomp.json
            ssh ${SSH_USER}@${IP} -o StrictHostKeyChecking=no 'sudo cat /etc/containers/storage.conf' >${LOG_DIR:?}/${IP}/etc/containers/storage.conf
            ssh ${SSH_USER}@${IP} -o StrictHostKeyChecking=no 'sudo cat /etc/crictl.yaml' >${LOG_DIR:?}/${IP}/etc/crictl.yaml
            ssh ${SSH_USER}@${IP} -o StrictHostKeyChecking=no 'sudo cat /etc/crio/crio.conf' >${LOG_DIR:?}/${IP}/etc/crio/crio.conf
            ssh ${SSH_USER}@${IP} -o StrictHostKeyChecking=no 'sudo cat /etc/docker/daemon.json' >${LOG_DIR:?}/${IP}/etc/docker/daemon.json
            ssh ${SSH_USER}@${IP} -o StrictHostKeyChecking=no 'sudo cat /etc/kubernetes/admin.conf' >${LOG_DIR:?}/${IP}/etc/kubernetes/admin.conf
            ssh ${SSH_USER}@${IP} -o StrictHostKeyChecking=no 'sudo cat /etc/kubernetes/controller-manager.conf' >${LOG_DIR:?}/${IP}/etc/kubernetes/controller-manager.conf
            ssh ${SSH_USER}@${IP} -o StrictHostKeyChecking=no 'sudo cat /etc/kubernetes/kubelet.conf' >${LOG_DIR:?}/${IP}/etc/kubernetes/kubelet.conf
            ssh ${SSH_USER}@${IP} -o StrictHostKeyChecking=no 'sudo cat /etc/kubernetes/scheduler.conf' >${LOG_DIR:?}/${IP}/etc/kubernetes/scheduler.conf
            ssh ${SSH_USER}@${IP} -o StrictHostKeyChecking=no 'sudo cat /etc/kubernetes/manifests/etcd.yaml' >${LOG_DIR:?}/${IP}/etc/kubernetes/manifests/etcd.yaml
            ssh ${SSH_USER}@${IP} -o StrictHostKeyChecking=no 'sudo cat /etc/kubernetes/manifests/kube-apiserver.yaml' >${LOG_DIR:?}/${IP}/etc/kubernetes/manifests/kube-apiserver.yaml
            ssh ${SSH_USER}@${IP} -o StrictHostKeyChecking=no 'sudo cat /etc/kubernetes/manifests/kube-controller-manager.yaml' >${LOG_DIR:?}/${IP}/etc/kubernetes/manifests/kube-controller-manager.yaml
            ssh ${SSH_USER}@${IP} -o StrictHostKeyChecking=no 'sudo cat /etc/kubernetes/manifests/kube-scheduler.yaml' >${LOG_DIR:?}/${IP}/etc/kubernetes/manifests/kube-scheduler.yaml
            ssh ${SSH_USER}@${IP} -o StrictHostKeyChecking=no 'sudo cat /etc/modules-load.d/skuba-br_netfilter.conf' >${LOG_DIR:?}/${IP}/etc/modules-load.d/skuba-br_netfilter.conf
            ssh ${SSH_USER}@${IP} -o StrictHostKeyChecking=no 'sudo cat /etc/modules-load.d/skuba-vxlan.conf' >${LOG_DIR:?}/${IP}/etc/modules-load.d/skuba-vxlan.conf
            ssh ${SSH_USER}@${IP} -o StrictHostKeyChecking=no 'sudo cat /etc/modules-load.d/br_netfilter.conf' >${LOG_DIR:?}/${IP}/etc/modules-load.d/br_netfilter.conf
            ssh ${SSH_USER}@${IP} -o StrictHostKeyChecking=no 'sudo cat /etc/default/crio' >${LOG_DIR:?}/${IP}/etc/default/crio
            ssh ${SSH_USER}@${IP} -o StrictHostKeyChecking=no 'sudo cat /etc/default/kubelet' >${LOG_DIR:?}/${IP}/etc/default/kubelet
            ssh ${SSH_USER}@${IP} -o StrictHostKeyChecking=no 'sudo cat /etc/sysconfig/crio' >${LOG_DIR:?}/${IP}/etc/sysconfig/crio
            ssh ${SSH_USER}@${IP} -o StrictHostKeyChecking=no 'sudo cat /etc/sysconfig/kubelet' >${LOG_DIR:?}/${IP}/etc/sysconfig/kubelet
            ssh ${SSH_USER}@${IP} -o StrictHostKeyChecking=no 'sudo cat /etc/sysctl.conf' >${LOG_DIR:?}/${IP}/etc/sysctl.conf
            ssh ${SSH_USER}@${IP} -o StrictHostKeyChecking=no 'sudo cat /etc/sysctl.d/99-kubernetes-cri.conf' >${LOG_DIR:?}/${IP}/etc/sysctl.d/99-kubernetes-cri.conf
            ssh ${SSH_USER}@${IP} -o StrictHostKeyChecking=no 'sudo cat /etc/sysctl.d/90-skuba-net-bridge-bridge-nf-call-iptables.conf' >${LOG_DIR:?}/${IP}/etc/sysctl.d/90-skuba-net-bridge-bridge-nf-call-iptables.conf
            ssh ${SSH_USER}@${IP} -o StrictHostKeyChecking=no 'sudo cat /etc/sysctl.d/90-skuba-net-ipv4-ip-forward.conf' >${LOG_DIR:?}/${IP}/etc/sysctl.d/90-skuba-net-ipv4-ip-forward.conf
            ssh ${SSH_USER}@${IP} -o StrictHostKeyChecking=no 'sudo cat /var/lib/kubelet/config.yaml' >${LOG_DIR:?}/${IP}/var/lib/kubelet/config.yaml
            ssh ${SSH_USER}@${IP} -o StrictHostKeyChecking=no 'sudo cat /var/lib/kubelet/kubeadm-flags.env' >${LOG_DIR:?}/${IP}/var/lib/kubelet/kubeadm-flags.env
            ssh ${SSH_USER}@${IP} -o StrictHostKeyChecking=no 'sudo cat /usr/lib/systemd/system/crio.service' >${LOG_DIR:?}/${IP}/usr/lib/systemd/system/crio.service
            ssh ${SSH_USER}@${IP} -o StrictHostKeyChecking=no 'sudo cat /usr/lib/systemd/system/docker.service' >${LOG_DIR:?}/${IP}/usr/lib/systemd/system/docker.service
            ssh ${SSH_USER}@${IP} -o StrictHostKeyChecking=no 'sudo cat /usr/lib/systemd/system/containerd.service' >${LOG_DIR:?}/${IP}/usr/lib/systemd/system/containerd.service
            ssh ${SSH_USER}@${IP} -o StrictHostKeyChecking=no 'sudo cat /usr/lib/systemd/system/kubelet.service' >${LOG_DIR:?}/${IP}/usr/lib/systemd/system/kubelet.service
            ssh ${SSH_USER}@${IP} -o StrictHostKeyChecking=no 'sudo cat /usr/lib/systemd/system/kubelet.service.d/10-kubeadm.conf' >${LOG_DIR:?}/${IP}/usr/lib/systemd/system/kubelet.service.d/10-kubeadm.conf
            ssh ${SSH_USER}@${IP} -o StrictHostKeyChecking=no 'sudo cat /lib/systemd/system/crio.service' >${LOG_DIR:?}/${IP}/lib/systemd/system/crio.service
            ssh ${SSH_USER}@${IP} -o StrictHostKeyChecking=no 'sudo cat /lib/systemd/system/docker.service' >${LOG_DIR:?}/${IP}/lib/systemd/system/docker.service
            ssh ${SSH_USER}@${IP} -o StrictHostKeyChecking=no 'sudo cat /lib/systemd/system/containerd.service' >${LOG_DIR:?}/${IP}/lib/systemd/system/containerd.service
            ssh ${SSH_USER}@${IP} -o StrictHostKeyChecking=no 'sudo cat /lib/systemd/system/kubelet.service' >${LOG_DIR:?}/${IP}/lib/systemd/system/kubelet.service
            ssh ${SSH_USER}@${IP} -o StrictHostKeyChecking=no 'sudo cat /lib/systemd/system/kubelet.service.d/10-kubeadm.conf' >${LOG_DIR:?}/${IP}/lib/systemd/system/kubelet.service.d/10-kubeadm.conf
            ssh ${SSH_USER}@${IP} -o StrictHostKeyChecking=no 'sudo cat /var/lib/cloud/instance/cloud-config.txt' >${LOG_DIR:?}/${IP}/var/lib/cloud/instance/cloud-config.txt
            ssh ${SSH_USER}@${IP} -o StrictHostKeyChecking=no 'sudo cat /var/lib/cloud/instance/user-data.txt' >${LOG_DIR:?}/${IP}/var/lib/cloud/instance/user-data.txt
            ssh ${SSH_USER}@${IP} -o StrictHostKeyChecking=no 'sudo cat /var/lib/cloud/instance/scripts/runcmd' >${LOG_DIR:?}/${IP}/var/lib/cloud/instance/scripts/runcmd
            ssh ${SSH_USER}@${IP} -o StrictHostKeyChecking=no 'sudo cat /var/log/alternatives.log' >${LOG_DIR:?}/${IP}/var/log/alternatives.log
            ssh ${SSH_USER}@${IP} -o StrictHostKeyChecking=no 'sudo cat /var/log/cloud-init.log' >${LOG_DIR:?}/${IP}/var/log/cloud-init.log
            ssh ${SSH_USER}@${IP} -o StrictHostKeyChecking=no 'sudo cat /var/log/cloud-init-output.log' >${LOG_DIR:?}/${IP}/var/log/cloud-init-output.log
            ssh ${SSH_USER}@${IP} -o StrictHostKeyChecking=no 'sudo cat /var/log/firewalld' >${LOG_DIR:?}/${IP}/var/log/firewalld
            ssh ${SSH_USER}@${IP} -o StrictHostKeyChecking=no 'sudo cat /var/log/messages' >${LOG_DIR:?}/${IP}/var/log/messages
            ssh ${SSH_USER}@${IP} -o StrictHostKeyChecking=no 'sudo cat /var/log/apt.log' >${LOG_DIR:?}/${IP}/var/log/apt.log
            ssh ${SSH_USER}@${IP} -o StrictHostKeyChecking=no 'sudo cat /var/log/dnf.log' >${LOG_DIR:?}/${IP}/var/log/dnf.log
            ssh ${SSH_USER}@${IP} -o StrictHostKeyChecking=no 'sudo cat /var/log/yum.log' >${LOG_DIR:?}/${IP}/var/log/yum.log
            ssh ${SSH_USER}@${IP} -o StrictHostKeyChecking=no 'sudo cat /var/log/zypper.log' >${LOG_DIR:?}/${IP}/var/log/zypper.log
            ssh ${SSH_USER}@${IP} -o StrictHostKeyChecking=no 'sudo cat /var/log/audit/audit.log' >${LOG_DIR:?}/${IP}/var/log/audit/audit.log
            ssh ${SSH_USER}@${IP} -o StrictHostKeyChecking=no 'sudo iptables-save' >${LOG_DIR:?}/${IP}/etc/iptables/rules.v4
            ssh ${SSH_USER}@${IP} -o StrictHostKeyChecking=no 'sudo ip6tables-save' >${LOG_DIR:?}/${IP}/etc/iptables/rules.v6
            ssh ${SSH_USER}@${IP} -o StrictHostKeyChecking=no 'sudo ps auxf' >${LOG_DIR:?}/${IP}/ps.log
            ssh ${SSH_USER}@${IP} -o StrictHostKeyChecking=no 'sudo mount' >${LOG_DIR:?}/${IP}/mount.log
            ssh ${SSH_USER}@${IP} -o StrictHostKeyChecking=no 'sudo iscsiadm -m session -P 3' >${LOG_DIR:?}/${IP}/iscsiadm.log
            ssh ${SSH_USER}@${IP} -o StrictHostKeyChecking=no 'sudo netstat -tulanp' >${LOG_DIR:?}/${IP}/ports.log
            # ssh ${SSH_USER}@${IP} -o StrictHostKeyChecking=no 'zypper repos -u' >${LOG_DIR:?}/${IP}/repos.log
            # ssh ${SSH_USER}@${IP} -o StrictHostKeyChecking=no 'zypper packages --installed-only' >${LOG_DIR:?}/${IP}/installed-packages.log

            FILES=$(ssh ${SSH_USER}@${IP} -o StrictHostKeyChecking=no 'sudo ls /var/log/containers')
            for FILE in ${FILES[*]}; do
                ssh ${SSH_USER}@${IP} -o StrictHostKeyChecking=no 'sudo cat /var/log/containers/${FILE}' >${LOG_DIR:?}/${IP}/var/log/containers/${FILE}.log
            done
        done
        echo -e "\n>>> Cleanup empty files and directories...\n"
        find "${LOG_DIR:?}" -type f -size 0 -print -exec rm -rf {} \;
        find "${LOG_DIR:?}" -type d -empty -delete

        # CLUSTER_NAME=$(ls ${HOME}/clusters)
        # cp -r ${HOME}/clusters/${CLUSTER_NAME} ${LOG_DIR:?}/
        # cp ${DEPLOYMENT_STATE_DIRECTORY}/terraform.tfstate ${LOG_DIR:?}/

        code ${LOG_DIR:?}
    fi
}

#******************************************************************************
# scp and run remote function

function scp_all_scripts_to_remote() {
    if [ "$#" != "2" ]; then
        log_e "Usage: ${FUNCNAME[0]} <SSH_USER> <IPS>"
        log_e "${FUNCNAME[0]} $# ${*}"
    else
        log_m "${FUNCNAME[0]} $# ${*}"
        # cd "${TOP_DIR:?}" || exit 1

        IPS=${2}
        for IP in ${IPS[*]}; do
            echo -e "\n>>> ${IP}...\n"
            LIBS=".myconfigs .mylib .myprojects"
            for LIB in ${LIBS[@]}; do
                ssh_cmd "${1}" "${IP}" "rm -rf /home/${SSH_USER}/${LIB}"
                scp_to "${HOME}/${LIB}" "${1}@${IP}:/home/${1}"
                ssh_cmd "${1}" "${IP}" "sudo cp /home/${1}/${LIB} /root"
            done
            ssh_cmd "${1}" "${IP}" "rm -rf /home/${SSH_USER}/inventories"
            scp_to "${TOP_DIR:?}/inventories" "${1}@${IP}:/home/${1}"
            ssh_cmd "${1}" "${IP}" "ls -alh /home/${SSH_USER}; sudo ls -alh /root;"
        done
    fi
}
# scp_all_scripts_to_remote "${SSH_USER}" "${IPS}"

function update_remote_script() {
    if [[ $# < 7 ]]; then
        log_e "Usage: ${FUNCNAME[0]} <SSH_USER> <IPS> <CONFIGURATION_MANAGEMENT_TOP_DIR> <REMOTE_CONFIGURATION_MANAGEMENT_TOP_DIR> <ROLE> <RUNTIME> <SCRIPT>"
        log_e "${FUNCNAME[0]} $# ${*}"
    else
        log_m "${FUNCNAME[0]} $# ${*}"
        # cd "${TOP_DIR:?}" || exit 1

        IPS=${2}
        for IP in ${IPS[*]}; do
            echo -e "\n>>> ${IP}...\n"
            ssh_cmd "${1}" "${IP}" "mkdir -p ${4}/${5}/${6};"
            scp_to "${3}/${5}/${6}/${7}" "${1}@${IP}:${4}/${5}/${6}"
        done
    fi
}
# update_remote_script "${SSH_USER}" "${IPS}" "${CONFIGURATION_MANAGEMENT_TOP_DIR}" "${REMOTE_CONFIGURATION_MANAGEMENT_TOP_DIR}" "${ROLE}" "${RUNTIME}" "${SCRIPT}"

function run_remote_script() {
    if [[ $# < 7 ]]; then
        log_e "Usage: ${FUNCNAME[0]} <SSH_USER> <IPS> <CONFIGURATION_MANAGEMENT_TOP_DIR> <REMOTE_CONFIGURATION_MANAGEMENT_TOP_DIR> <ROLE> <RUNTIME> <SCRIPT> <ARGS>"
        log_e "${FUNCNAME[0]} $# ${*}"
    else
        log_m "${FUNCNAME[0]} $# ${*}"
        # cd "${TOP_DIR:?}" || exit 1

        IPS=${2}
        ARGS=${8}
        for IP in ${IPS[*]}; do
            echo -e "\n>>> ${IP}...\n"
            ssh_cmd "${1}" "${IP}" "chmod +x ${4}/${5}/${6}/${7}; sudo ${4}/${5}/${6}/${7} ${ARGS[*]};"
        done
    fi
}
# run_remote_script "${SSH_USER}" "${IPS}" "${CONFIGURATION_MANAGEMENT_TOP_DIR}" "${REMOTE_CONFIGURATION_MANAGEMENT_TOP_DIR}" "${ROLE}" "${RUNTIME}" "${SCRIPT}"
# run_remote_script "${SSH_USER}" "${IPS}" "${CONFIGURATION_MANAGEMENT_TOP_DIR}" "${REMOTE_CONFIGURATION_MANAGEMENT_TOP_DIR}" "${ROLE}" "${RUNTIME}" "${SCRIPT}" "${ARGS}"

function run_local_script() {
    if [ "$#" != "4" ] && [ "$#" != "5" ]; then
        log_e "Usage: ${FUNCNAME[0]} <CONFIGURATION_MANAGEMENT_TOP_DIR> <ROLE> <RUNTIME> <SCRIPT> <ARGS>"
        log_e "${FUNCNAME[0]} $# ${*}"
    else
        log_m "${FUNCNAME[0]} $# ${*}"
        # cd "${TOP_DIR:?}" || exit 1

        chmod +x "${1}/${2}/${3}/${4}"
        if [ "$#" == "5" ]; then
            ARGS="${5}"
            ${1}/${2}/${3}/${4} ${ARGS[*]}
        else
            ${1}/${2}/${3}/${4}
        fi
    fi
}
# run_local_script "${CONFIGURATION_MANAGEMENT_TOP_DIR}" "${ROLE}" "${RUNTIME}" "${SCRIPT}"
# run_local_script "${CONFIGURATION_MANAGEMENT_TOP_DIR}" "${ROLE}" "${RUNTIME}" "${SCRIPT}" "${ARGS}"

#******************************************************************************
# git

# https://docs.github.com/en/github/using-git/setting-your-username-in-git
function set_github_user_name_and_email() {
    if [ "$#" != "0" ] && [ "$#" != "2" ]; then
        log_e "Usage: ${FUNCNAME[0]} [<GITHUB_USER>] <GITHUB_USER_NAME> <GITHUB_USER_EMAIL>"
        log_e "${FUNCNAME[0]} $# ${*}"
    else
        log_m "${FUNCNAME[0]} $# ${*}"
        # cd "${TOP_DIR:?}" || exit 1

        if [ "$#" == "2" ]; then
            # local GITHUB_USER="${1}"
            local GITHUB_USER_NAME="${1}"
            local GITHUB_USER_EMAIL="${2}"
        fi

        # git config --global user.user "${GITHUB_USER}"
        git config --global user.name "${GITHUB_USER_NAME}"
        git config --global user.email "${GITHUB_USER_EMAIL}"
        git config --list
        # cat "${HOME}/.gitconfig"
    fi
}

function add_ssh_id_to_ssh_agent() {
    if [ "$#" != "0" ]; then
        log_e "Usage: ${FUNCNAME[0]} <ARGS>"
        log_e "${FUNCNAME[0]} $# ${*}"
    else
        # log_m "${FUNCNAME[0]} $# ${*}"
        # cd "${TOP_DIR:?}" || exit 1

        echo -e "\n>>> Add SSH Identity to ssh-agent...\n"
        rm -rf "${HOME}/.ssh/known_hosts"
        # https://www.ssh.com/ssh/agent
        # ssh-agent bash
        ssh-add "${HOME}/.ssh/id_rsa"
    fi
}

function git_use_git_instead_of_http() {
    if [ "$#" != "0" ]; then
        log_e "Usage: ${FUNCNAME[0]} <ARGS>"
        log_e "${FUNCNAME[0]} $# ${*}"
    else
        # log_m "${FUNCNAME[0]} $# ${*}"
        # cd "${TOP_DIR:?}" || exit 1

        # Install through build code
        # NOTE: need to make sure that git use sshkey as in: https://gist.github.com/dmitshur/6927554
        # https://gist.github.com/rubencaro/5ce32fb30bbfa70e7db6be14cf42a35c
        git config --global url."git@github.com:".insteadOf "https://github.com/"
        # cat "${HOME}/.gitconfig"

        # GITHUB_HOST=
        # ssh-keyscan ${GITHUB_HOST} >> "${HOME}/.ssh/known_hosts"
    fi
}

function disable_strict_host_key_checking() {
    if [ "$#" != "0" ]; then
        log_e "Usage: ${FUNCNAME[0]} <ARGS>"
        log_e "${FUNCNAME[0]} $# ${*}"
    else
        log_m "${FUNCNAME[0]} $# ${*}"
        # cd "${TOP_DIR:?}" || exit 1

        rm -rf ${HOME}/.ssh/config
        echo -e "Host bitbucket.com\n\tStrictHostKeyChecking no\n" >>${HOME}/.ssh/config
        echo -e "Host github.com\n\tStrictHostKeyChecking no\n" >>${HOME}/.ssh/config
        echo -e "Host gitlab.com\n\tStrictHostKeyChecking no\n" >>${HOME}/.ssh/config
        echo -e "Host gitlab.suse.de\n\tStrictHostKeyChecking no\n" >>${HOME}/.ssh/config
        cat ${HOME}/.ssh/config
    fi
}

function git_set_signing_key() {
    if [ "$#" != "5" ]; then
        log_e "Usage: ${FUNCNAME[0]} <SRC_ROOT> <GIT_PROVIDER : bitbucket.com | github.com | gitlab.com> <PROJECT_UPSTREAM_USER> [<PROJECT_DOWNSTREAM_USER>] <PROJECT_NAME>"
        log_e "${FUNCNAME[0]} $# ${*}"
    else
        log_m "${FUNCNAME[0]} $# ${*}"
        # cd "${TOP_DIR:?}" || exit 1

        if [ "$#" == "5" ]; then
            local SRC_ROOT=${1}
            local GIT_PROVIDER=${2}
            local PROJECT_UPSTREAM_USER=${3}
            local PROJECT_DOWNSTREAM_USER=${4}
            local PROJECT_NAME=${5}
            if [ -e "${SRC_ROOT}/${GIT_PROVIDER}/${PROJECT_DOWNSTREAM_USER}_${PROJECT_UPSTREAM_USER}/${PROJECT_NAME}" ]; then
                local PROJECT_DIR="${SRC_ROOT}/${GIT_PROVIDER}/${PROJECT_DOWNSTREAM_USER}_${PROJECT_UPSTREAM_USER}/${PROJECT_NAME}"
            elif [ -e "${SRC_ROOT}/${GIT_PROVIDER}/${PROJECT_DOWNSTREAM_USER}_${PROJECT_UPSTREAM_USER}/${PROJECT_NAME}-1" ]; then
                local PROJECT_DIR="${SRC_ROOT}/${GIT_PROVIDER}/${PROJECT_DOWNSTREAM_USER}_${PROJECT_UPSTREAM_USER}/${PROJECT_NAME}-1"
            elif [ -e "${SRC_ROOT}/${GIT_PROVIDER}/${PROJECT_DOWNSTREAM_USER}/${PROJECT_NAME}" ]; then
                local PROJECT_DIR="${SRC_ROOT}/${GIT_PROVIDER}/${PROJECT_DOWNSTREAM_USER}/${PROJECT_NAME}"
            else
                local PROJECT_DIR="${SRC_ROOT}/${GIT_PROVIDER}/${PROJECT_DOWNSTREAM_USER}/${PROJECT_NAME}-1"
            fi
        fi

        cd "${PROJECT_DIR}" || exit 1
        # ls -alh "${PROJECT_DIR}"

        # gpg --list-secret-keys --keyid-format LONG
        SIGNING_KEY=$(gpg --list-secret-keys --keyid-format LONG | grep sec | sed 's/  */ /g' | cut -d ' ' -f 2 | cut -d '/' -f 2)
        git config --global user.signingkey ${SIGNING_KEY}
        git config --list

        if [ $(grep -i 'export GPG_TTY=$(tty)' ~/.profile | wc -l) == 0 ]; then
            # test -r ~/.bash_profile && echo 'export GPG_TTY=$(tty)' >> ~/.bash_profile
            echo 'export GPG_TTY=$(tty)' >>~/.profile
        fi
    fi
}

function browser_open_github_project() {
    if [ "$#" != "2" ] && [ "$#" != "3" ]; then
        log_e "Usage: ${FUNCNAME[0]} <GIT_PROVIDER : bitbucket.com | github.com | gitlab.com> <PROJECT_USER> [<PROJECT_NAME>]"
        log_e "${FUNCNAME[0]} $# ${*}"
    else
        log_m "${FUNCNAME[0]} $# ${*}"
        # cd "${TOP_DIR:?}" || exit 1

        if [ "$#" == "2" ]; then
            local GIT_PROVIDER=${1}
            local PROJECT_USER=${2}
        elif [ "$#" == "3" ]; then
            local GIT_PROVIDER=${1}
            local PROJECT_USER=${2}
            local PROJECT_NAME=${3}
        fi

        if [ "$#" == "2" ]; then
            # open https://${GIT_PROVIDER}/${PROJECT_USER}
            google-chrome-stable https://${GIT_PROVIDER}/${PROJECT_USER}
        else
            # open https://${GIT_PROVIDER}/${PROJECT_USER}/${PROJECT_NAME}
            google-chrome-stable https://${GIT_PROVIDER}/${PROJECT_USER}/${PROJECT_NAME}
        fi
    fi
}

function code_git_project() {
    if [ "$#" != "4" ] && [ "$#" != "5" ]; then
        log_e "Usage: ${FUNCNAME[0]} <SRC_ROOT> <GIT_PROVIDER : bitbucket.com | github.com | gitlab.com> <PROJECT_UPSTREAM_USER> [<PROJECT_DOWNSTREAM_USER>] <PROJECT_NAME>"
        log_e "${FUNCNAME[0]} $# ${*}"
    else
        log_m "${FUNCNAME[0]} $# ${*}"
        # cd "${TOP_DIR:?}" || exit 1

        if [ "$#" == "4" ]; then
            local SRC_ROOT=${1}
            local GIT_PROVIDER=${2}
            local PROJECT_UPSTREAM_USER=${3}
            local PROJECT_NAME=${4}
            local PROJECT_DIR="${SRC_ROOT}/${GIT_PROVIDER}/${PROJECT_UPSTREAM_USER}/${PROJECT_NAME}"
        elif [ "$#" == "5" ]; then
            local SRC_ROOT=${1}
            local GIT_PROVIDER=${2}
            local PROJECT_UPSTREAM_USER=${3}
            local PROJECT_DOWNSTREAM_USER=${4}
            local PROJECT_NAME=${5}
            local PROJECT_DIR="${SRC_ROOT}/${GIT_PROVIDER}/${PROJECT_DOWNSTREAM_USER}_${PROJECT_UPSTREAM_USER}/${PROJECT_NAME}"
        fi

        cd "${PROJECT_DIR}" || exit 1

        code .
    fi
}

function git_remove_local_repo() {
    if [ "$#" != "4" ] && [ "$#" != "5" ]; then
        log_e "Usage: ${FUNCNAME[0]} <SRC_ROOT> <GIT_PROVIDER : bitbucket.com | github.com | gitlab.com> <PROJECT_UPSTREAM_USER> [<PROJECT_DOWNSTREAM_USER>] <PROJECT_NAME>"
        log_e "${FUNCNAME[0]} $# ${*}"
    else
        log_m "${FUNCNAME[0]} $# ${*}"
        # cd "${TOP_DIR:?}" || exit 1

        if [ "$#" == "4" ]; then
            local SRC_ROOT=${1}
            local GIT_PROVIDER=${2}
            local PROJECT_UPSTREAM_USER=${3}
            local PROJECT_NAME=${4}
            local PROJECT_DIR="${SRC_ROOT}/${GIT_PROVIDER}/${PROJECT_UPSTREAM_USER}/${PROJECT_NAME}"
        elif [ "$#" == "5" ]; then
            local SRC_ROOT=${1}
            local GIT_PROVIDER=${2}
            local PROJECT_UPSTREAM_USER=${3}
            local PROJECT_DOWNSTREAM_USER=${4}
            local PROJECT_NAME=${5}
            local PROJECT_DIR="${SRC_ROOT}/${GIT_PROVIDER}/${PROJECT_DOWNSTREAM_USER}_${PROJECT_UPSTREAM_USER}/${PROJECT_NAME}"
        fi

        echo -e "\n>>> Removing Local Source Repository ${PROJECT_DIR}...\n"
        rm -rf "${PROJECT_DIR}"
    fi
}

function git_clone_repo_to_local() {
    if [ "$#" != "4" ] && [ "$#" != "5" ]; then
        log_e "Usage: ${FUNCNAME[0]} <SRC_ROOT> <GIT_PROVIDER : bitbucket.com | github.com | gitlab.com> <PROJECT_UPSTREAM_USER> [<PROJECT_DOWNSTREAM_USER>] <PROJECT_NAME>"
        log_e "${FUNCNAME[0]} $# ${*}"
    else
        log_m "${FUNCNAME[0]} $# ${*}"
        # cd "${TOP_DIR:?}" || exit 1

        if [ "$#" == "4" ]; then
            local SRC_ROOT=${1}
            local GIT_PROVIDER=${2}
            local PROJECT_UPSTREAM_USER=${3}
            local PROJECT_NAME=${4}
            local PROJECT_DIR="${SRC_ROOT}/${GIT_PROVIDER}/${PROJECT_UPSTREAM_USER}"
            local GIT_CLONE_TYPE=git # git | https | cli
        elif [ "$#" == "5" ]; then
            local SRC_ROOT=${1}
            local GIT_PROVIDER=${2}
            local PROJECT_UPSTREAM_USER=${3}
            local PROJECT_DOWNSTREAM_USER=${4}
            local PROJECT_NAME=${5}
            local PROJECT_DIR="${SRC_ROOT}/${GIT_PROVIDER}/${PROJECT_DOWNSTREAM_USER}_${PROJECT_UPSTREAM_USER}"
            local GIT_CLONE_TYPE=git # git | https | cli
        fi

        cd "${PROJECT_DIR}" || exit 1

        echo -e "\n>>> Clone Remote Source Repository ${GIT_PROVIDER}/${PROJECT_UPSTREAM_USER}/${PROJECT_NAME}...\n"

        if [ ! -e "${PROJECT_DIR}/${PROJECT_NAME}" ]; then
            if [ "${GIT_CLONE_TYPE}" == "git " ]; then
                git clone "git@${GIT_PROVIDER}:${PROJECT_UPSTREAM_USER}/${PROJECT_NAME}.git"
            else
                git clone "https://${GIT_PROVIDER}/${PROJECT_UPSTREAM_USER}/${PROJECT_NAME}"
            fi
        fi
        ls -al
    fi
}

function git_show() {
    if [ "$#" != "5" ]; then
        log_e "Usage: ${FUNCNAME[0]} <SRC_ROOT> <GIT_PROVIDER : bitbucket.com | github.com | gitlab.com> <PROJECT_UPSTREAM_USER> [<PROJECT_DOWNSTREAM_USER>] <PROJECT_NAME>"
        log_e "${FUNCNAME[0]} $# ${*}"
    else
        log_m "${FUNCNAME[0]} $# ${*}"
        # cd "${TOP_DIR:?}" || exit 1

        if [ "$#" == "5" ]; then
            local SRC_ROOT=${1}
            local GIT_PROVIDER=${2}
            local PROJECT_UPSTREAM_USER=${3}
            local PROJECT_DOWNSTREAM_USER=${4}
            local PROJECT_NAME=${5}
            if [ -e "${SRC_ROOT}/${GIT_PROVIDER}/${PROJECT_DOWNSTREAM_USER}_${PROJECT_UPSTREAM_USER}/${PROJECT_NAME}" ]; then
                local PROJECT_DIR="${SRC_ROOT}/${GIT_PROVIDER}/${PROJECT_DOWNSTREAM_USER}_${PROJECT_UPSTREAM_USER}/${PROJECT_NAME}"
            elif [ -e "${SRC_ROOT}/${GIT_PROVIDER}/${PROJECT_DOWNSTREAM_USER}_${PROJECT_UPSTREAM_USER}/${PROJECT_NAME}-1" ]; then
                local PROJECT_DIR="${SRC_ROOT}/${GIT_PROVIDER}/${PROJECT_DOWNSTREAM_USER}_${PROJECT_UPSTREAM_USER}/${PROJECT_NAME}-1"
            elif [ -e "${SRC_ROOT}/${GIT_PROVIDER}/${PROJECT_DOWNSTREAM_USER}/${PROJECT_NAME}" ]; then
                local PROJECT_DIR="${SRC_ROOT}/${GIT_PROVIDER}/${PROJECT_DOWNSTREAM_USER}/${PROJECT_NAME}"
            else
                local PROJECT_DIR="${SRC_ROOT}/${GIT_PROVIDER}/${PROJECT_DOWNSTREAM_USER}/${PROJECT_NAME}-1"
            fi
        fi

        cd "${PROJECT_DIR}" || exit 1
        # ls -alh "${PROJECT_DIR}"

        git show
    fi
}

function git_status() {
    if [ "$#" != "5" ]; then
        log_e "Usage: ${FUNCNAME[0]} <SRC_ROOT> <GIT_PROVIDER : bitbucket.com | github.com | gitlab.com> <PROJECT_UPSTREAM_USER> [<PROJECT_DOWNSTREAM_USER>] <PROJECT_NAME>"
        log_e "${FUNCNAME[0]} $# ${*}"
    else
        log_m "${FUNCNAME[0]} $# ${*}"
        # cd "${TOP_DIR:?}" || exit 1

        if [ "$#" == "5" ]; then
            local SRC_ROOT=${1}
            local GIT_PROVIDER=${2}
            local PROJECT_UPSTREAM_USER=${3}
            local PROJECT_DOWNSTREAM_USER=${4}
            local PROJECT_NAME=${5}
            if [ -e "${SRC_ROOT}/${GIT_PROVIDER}/${PROJECT_DOWNSTREAM_USER}_${PROJECT_UPSTREAM_USER}/${PROJECT_NAME}" ]; then
                local PROJECT_DIR="${SRC_ROOT}/${GIT_PROVIDER}/${PROJECT_DOWNSTREAM_USER}_${PROJECT_UPSTREAM_USER}/${PROJECT_NAME}"
            elif [ -e "${SRC_ROOT}/${GIT_PROVIDER}/${PROJECT_DOWNSTREAM_USER}_${PROJECT_UPSTREAM_USER}/${PROJECT_NAME}-1" ]; then
                local PROJECT_DIR="${SRC_ROOT}/${GIT_PROVIDER}/${PROJECT_DOWNSTREAM_USER}_${PROJECT_UPSTREAM_USER}/${PROJECT_NAME}-1"
            elif [ -e "${SRC_ROOT}/${GIT_PROVIDER}/${PROJECT_DOWNSTREAM_USER}/${PROJECT_NAME}" ]; then
                local PROJECT_DIR="${SRC_ROOT}/${GIT_PROVIDER}/${PROJECT_DOWNSTREAM_USER}/${PROJECT_NAME}"
            else
                local PROJECT_DIR="${SRC_ROOT}/${GIT_PROVIDER}/${PROJECT_DOWNSTREAM_USER}/${PROJECT_NAME}-1"
            fi
        fi

        cd "${PROJECT_DIR}" || exit 1
        # ls -alh "${PROJECT_DIR}"

        git branch
        git status
        git log | head -9
    fi
}

function git_diff() {
    if [ "$#" != "5" ]; then
        log_e "Usage: ${FUNCNAME[0]} <SRC_ROOT> <GIT_PROVIDER : bitbucket.com | github.com | gitlab.com> <PROJECT_UPSTREAM_USER> [<PROJECT_DOWNSTREAM_USER>] <PROJECT_NAME>"
        log_e "${FUNCNAME[0]} $# ${*}"
    else
        log_m "${FUNCNAME[0]} $# ${*}"
        # cd "${TOP_DIR:?}" || exit 1

        if [ "$#" == "5" ]; then
            local SRC_ROOT=${1}
            local GIT_PROVIDER=${2}
            local PROJECT_UPSTREAM_USER=${3}
            local PROJECT_DOWNSTREAM_USER=${4}
            local PROJECT_NAME=${5}
            if [ -e "${SRC_ROOT}/${GIT_PROVIDER}/${PROJECT_DOWNSTREAM_USER}_${PROJECT_UPSTREAM_USER}/${PROJECT_NAME}" ]; then
                local PROJECT_DIR="${SRC_ROOT}/${GIT_PROVIDER}/${PROJECT_DOWNSTREAM_USER}_${PROJECT_UPSTREAM_USER}/${PROJECT_NAME}"
            elif [ -e "${SRC_ROOT}/${GIT_PROVIDER}/${PROJECT_DOWNSTREAM_USER}_${PROJECT_UPSTREAM_USER}/${PROJECT_NAME}-1" ]; then
                local PROJECT_DIR="${SRC_ROOT}/${GIT_PROVIDER}/${PROJECT_DOWNSTREAM_USER}_${PROJECT_UPSTREAM_USER}/${PROJECT_NAME}-1"
            elif [ -e "${SRC_ROOT}/${GIT_PROVIDER}/${PROJECT_DOWNSTREAM_USER}/${PROJECT_NAME}" ]; then
                local PROJECT_DIR="${SRC_ROOT}/${GIT_PROVIDER}/${PROJECT_DOWNSTREAM_USER}/${PROJECT_NAME}"
            else
                local PROJECT_DIR="${SRC_ROOT}/${GIT_PROVIDER}/${PROJECT_DOWNSTREAM_USER}/${PROJECT_NAME}-1"
            fi
            # local START_COMMIT_HASH=
            # local END_COMMIT_HASH=
        fi

        cd "${PROJECT_DIR}" || exit 1
        # ls -alh "${PROJECT_DIR}"

        git diff
        # git diff ${START_COMMIT_HASH}..${END_COMMIT_HASH}
    fi
}

# https://git-scm.com/download/gui/linux
function git_show_graph() {
    if [ "$#" != "5" ]; then
        log_e "Usage: ${FUNCNAME[0]} <SRC_ROOT> <GIT_PROVIDER : bitbucket.com | github.com | gitlab.com> <PROJECT_UPSTREAM_USER> [<PROJECT_DOWNSTREAM_USER>] <PROJECT_NAME>"
        log_e "${FUNCNAME[0]} $# ${*}"
    else
        log_m "${FUNCNAME[0]} $# ${*}"
        # cd "${TOP_DIR:?}" || exit 1

        if [ "$#" == "5" ]; then
            local SRC_ROOT=${1}
            local GIT_PROVIDER=${2}
            local PROJECT_UPSTREAM_USER=${3}
            local PROJECT_DOWNSTREAM_USER=${4}
            local PROJECT_NAME=${5}
            if [ -e "${SRC_ROOT}/${GIT_PROVIDER}/${PROJECT_DOWNSTREAM_USER}_${PROJECT_UPSTREAM_USER}/${PROJECT_NAME}" ]; then
                local PROJECT_DIR="${SRC_ROOT}/${GIT_PROVIDER}/${PROJECT_DOWNSTREAM_USER}_${PROJECT_UPSTREAM_USER}/${PROJECT_NAME}"
            elif [ -e "${SRC_ROOT}/${GIT_PROVIDER}/${PROJECT_DOWNSTREAM_USER}_${PROJECT_UPSTREAM_USER}/${PROJECT_NAME}-1" ]; then
                local PROJECT_DIR="${SRC_ROOT}/${GIT_PROVIDER}/${PROJECT_DOWNSTREAM_USER}_${PROJECT_UPSTREAM_USER}/${PROJECT_NAME}-1"
            elif [ -e "${SRC_ROOT}/${GIT_PROVIDER}/${PROJECT_DOWNSTREAM_USER}/${PROJECT_NAME}" ]; then
                local PROJECT_DIR="${SRC_ROOT}/${GIT_PROVIDER}/${PROJECT_DOWNSTREAM_USER}/${PROJECT_NAME}"
            else
                local PROJECT_DIR="${SRC_ROOT}/${GIT_PROVIDER}/${PROJECT_DOWNSTREAM_USER}/${PROJECT_NAME}-1"
            fi
        fi

        cd "${PROJECT_DIR}" || exit 1
        # ls -alh "${PROJECT_DIR}"

        # gitk

        # git log --pretty=format:"%h %s" --graph
        git log --all --decorate --oneline --graph
        # git log --all --decorate --abbrev-commit --date=relative --graph

        # git log --graph --abbrev-commit --decorate --format=format:'%C(bold blue)%h%C(reset) - %C(bold green)(%ar)%C(reset) %C(white)%s%C(reset) %C(dim white)- %an%C(reset)%C(bold yellow)%d%C(reset)' --all
        # git log --graph --abbrev-commit --decorate --format=format:'%C(bold blue)%h%C(reset) - %C(bold cyan)%aD%C(reset) %C(bold green)(%ar)%C(reset)%C(bold yellow)%d%C(reset)%n''          %C(white)%s%C(reset) %C(dim white)- %an%C(reset)' --all

        # git log --graph --abbrev-commit --decorate --format=format:'%C(bold blue)%h%C(reset) - %C(bold green)(%ar)%C(reset) %C(white)%s%C(reset) %C(dim white)- %an%C(reset)%C(auto)%d%C(reset)'
        # git log --graph --abbrev-commit --decorate --format=format:'%C(bold blue)%h%C(reset) - %C(bold cyan)%aD%C(reset) %C(bold green)(%ar)%C(reset)%C(auto)%d%C(reset)%n''          %C(white)%s%C(reset) %C(dim white)- %an%C(reset)'
        # git log --graph --abbrev-commit --decorate --format=format:'%C(bold blue)%h%C(reset) - %C(bold cyan)%aD%C(reset) %C(bold green)(%ar)%C(reset) %C(bold cyan)(committed: %cD)%C(reset) %C(auto)%d%C(reset)%n''          %C(white)%s%C(reset)%n''          %C(dim white)- %an <%ae> %C(reset) %C(dim white)(committer: %cn <%ce>)%C(reset)'

    fi
}

function git_show_all() {
    if [ "$#" != "7" ]; then
        log_e "Usage: ${FUNCNAME[0]} <SRC_ROOT> <GIT_PROVIDER : bitbucket.com | github.com | gitlab.com> <PROJECT_UPSTREAM_USER> [<PROJECT_DOWNSTREAM_USER>] <PROJECT_NAME> <PROJECT_MAIN_BRANCH> <WORKING_BRANCH>"
        log_e "${FUNCNAME[0]} $# ${*}"
    else
        log_m "${FUNCNAME[0]} $# ${*}"
        # cd "${TOP_DIR:?}" || exit 1

        if [ "$#" == "7" ]; then
            local SRC_ROOT=${1}
            local GIT_PROVIDER=${2}
            local PROJECT_UPSTREAM_USER=${3}
            local PROJECT_DOWNSTREAM_USER=${4}
            local PROJECT_NAME=${5}
            if [ -e "${SRC_ROOT}/${GIT_PROVIDER}/${PROJECT_DOWNSTREAM_USER}_${PROJECT_UPSTREAM_USER}/${PROJECT_NAME}" ]; then
                local PROJECT_DIR="${SRC_ROOT}/${GIT_PROVIDER}/${PROJECT_DOWNSTREAM_USER}_${PROJECT_UPSTREAM_USER}/${PROJECT_NAME}"
            elif [ -e "${SRC_ROOT}/${GIT_PROVIDER}/${PROJECT_DOWNSTREAM_USER}_${PROJECT_UPSTREAM_USER}/${PROJECT_NAME}-1" ]; then
                local PROJECT_DIR="${SRC_ROOT}/${GIT_PROVIDER}/${PROJECT_DOWNSTREAM_USER}_${PROJECT_UPSTREAM_USER}/${PROJECT_NAME}-1"
            elif [ -e "${SRC_ROOT}/${GIT_PROVIDER}/${PROJECT_DOWNSTREAM_USER}/${PROJECT_NAME}" ]; then
                local PROJECT_DIR="${SRC_ROOT}/${GIT_PROVIDER}/${PROJECT_DOWNSTREAM_USER}/${PROJECT_NAME}"
            else
                local PROJECT_DIR="${SRC_ROOT}/${GIT_PROVIDER}/${PROJECT_DOWNSTREAM_USER}/${PROJECT_NAME}-1"
            fi
            local PROJECT_MAIN_BRANCH=${6} # master | main | develop
            local WORKING_BRANCH=${7}
        fi

        cd "${PROJECT_DIR}" || exit 1
        # ls -alh "${PROJECT_DIR}"

        # git log --oneline --graph --all --decorate ${PROJECT_MAIN_BRANCH} ${WORKING_BRANCH}
        # git log --oneline --graph --decorate --abbrev-commit ${PROJECT_MAIN_BRANCH} ${WORKING_BRANCH}
        # git log --oneline --graph --all --decorate --abbrev-commit  ${PROJECT_MAIN_BRANCH2} ${WORKING_BRANCH}
        # git log --graph --pretty=format:'%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr)%Creset' --abbrev-commit --date=relative ${PROJECT_MAIN_BRANCH} ${WORKING_BRANCH}
        git log --left-right --graph --cherry-pick --oneline ${PROJECT_MAIN_BRANCH} ${WORKING_BRANCH}
        # gitk ${PROJECT_MAIN_BRANCH} ${WORKING_BRANCH}
    fi
}

function git_show_different_between() {
    if [ "$#" != "7" ]; then
        log_e "Usage: ${FUNCNAME[0]} <SRC_ROOT> <GIT_PROVIDER : bitbucket.com | github.com | gitlab.com> <PROJECT_UPSTREAM_USER> [<PROJECT_DOWNSTREAM_USER>] <PROJECT_NAME> <PROJECT_MAIN_BRANCH> <WORKING_BRANCH>"
        log_e "${FUNCNAME[0]} $# ${*}"
    else
        log_m "${FUNCNAME[0]} $# ${*}"
        # cd "${TOP_DIR:?}" || exit 1

        if [ "$#" == "7" ]; then
            local SRC_ROOT=${1}
            local GIT_PROVIDER=${2}
            local PROJECT_UPSTREAM_USER=${3}
            local PROJECT_DOWNSTREAM_USER=${4}
            local PROJECT_NAME=${5}
            if [ -e "${SRC_ROOT}/${GIT_PROVIDER}/${PROJECT_DOWNSTREAM_USER}_${PROJECT_UPSTREAM_USER}/${PROJECT_NAME}" ]; then
                local PROJECT_DIR="${SRC_ROOT}/${GIT_PROVIDER}/${PROJECT_DOWNSTREAM_USER}_${PROJECT_UPSTREAM_USER}/${PROJECT_NAME}"
            elif [ -e "${SRC_ROOT}/${GIT_PROVIDER}/${PROJECT_DOWNSTREAM_USER}_${PROJECT_UPSTREAM_USER}/${PROJECT_NAME}-1" ]; then
                local PROJECT_DIR="${SRC_ROOT}/${GIT_PROVIDER}/${PROJECT_DOWNSTREAM_USER}_${PROJECT_UPSTREAM_USER}/${PROJECT_NAME}-1"
            elif [ -e "${SRC_ROOT}/${GIT_PROVIDER}/${PROJECT_DOWNSTREAM_USER}/${PROJECT_NAME}" ]; then
                local PROJECT_DIR="${SRC_ROOT}/${GIT_PROVIDER}/${PROJECT_DOWNSTREAM_USER}/${PROJECT_NAME}"
            else
                local PROJECT_DIR="${SRC_ROOT}/${GIT_PROVIDER}/${PROJECT_DOWNSTREAM_USER}/${PROJECT_NAME}-1"
            fi
            local PROJECT_MAIN_BRANCH=${6} # master | main | develop
            local WORKING_BRANCH=${7}
        fi

        cd "${PROJECT_DIR}" || exit 1
        # ls -alh "${PROJECT_DIR}"

        # git log --oneline --graph --all --decorate ${PROJECT_MAIN_BRANCH}..${WORKING_BRANCH}
        # git log --oneline --graph --decorate --abbrev-commit ${PROJECT_MAIN_BRANCH}..${WORKING_BRANCH}
        # git log --oneline --graph --all --decorate --abbrev-commit  ${PROJECT_MAIN_BRANCH}..${WORKING_BRANCH}
        # git log --graph --pretty=format:'%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr)%Creset' --abbrev-commit --date=relative ${PROJECT_MAIN_BRANCH}..${WORKING_BRANCH}
        git log --left-right --graph --cherry-pick --oneline ${PROJECT_MAIN_BRANCH}..${WORKING_BRANCH}
        # gitk ${PROJECT_MAIN_BRANCH}..${WORKING_BRANCH}
    fi
}

function git_add_remote() {
    if [ "$#" != "7" ]; then
        log_e "Usage: ${FUNCNAME[0]} <SRC_ROOT> <GIT_PROVIDER : bitbucket.com | github.com | gitlab.com> <PROJECT_UPSTREAM_USER> [<PROJECT_DOWNSTREAM_USER>] <PROJECT_NAME> <UPSTREAM> <DOWNSTREAM>"
        log_e "${FUNCNAME[0]} $# ${*}"
    else
        log_m "${FUNCNAME[0]} $# ${*}"
        # cd "${TOP_DIR:?}" || exit 1

        if [ "$#" == "7" ]; then
            local SRC_ROOT=${1}
            local GIT_PROVIDER=${2}
            local PROJECT_UPSTREAM_USER=${3}
            local PROJECT_DOWNSTREAM_USER=${4}
            local PROJECT_NAME=${5}
            if [ -e "${SRC_ROOT}/${GIT_PROVIDER}/${PROJECT_DOWNSTREAM_USER}_${PROJECT_UPSTREAM_USER}/${PROJECT_NAME}" ]; then
                local PROJECT_DIR="${SRC_ROOT}/${GIT_PROVIDER}/${PROJECT_DOWNSTREAM_USER}_${PROJECT_UPSTREAM_USER}/${PROJECT_NAME}"
            elif [ -e "${SRC_ROOT}/${GIT_PROVIDER}/${PROJECT_DOWNSTREAM_USER}_${PROJECT_UPSTREAM_USER}/${PROJECT_NAME}-1" ]; then
                local PROJECT_DIR="${SRC_ROOT}/${GIT_PROVIDER}/${PROJECT_DOWNSTREAM_USER}_${PROJECT_UPSTREAM_USER}/${PROJECT_NAME}-1"
            elif [ -e "${SRC_ROOT}/${GIT_PROVIDER}/${PROJECT_DOWNSTREAM_USER}/${PROJECT_NAME}" ]; then
                local PROJECT_DIR="${SRC_ROOT}/${GIT_PROVIDER}/${PROJECT_DOWNSTREAM_USER}/${PROJECT_NAME}"
            else
                local PROJECT_DIR="${SRC_ROOT}/${GIT_PROVIDER}/${PROJECT_DOWNSTREAM_USER}/${PROJECT_NAME}-1"
            fi
            local UPSTREAM=${6}   # upstream | ${PROJECT_UPSTREAM_USER}_${PROJECT_NAME}
            local DOWNSTREAM=${7} # origin
        fi

        cd "${PROJECT_DIR}" || exit 1
        # ls -alh "${PROJECT_DIR}"

        git remote add "${UPSTREAM}" "git@${GIT_PROVIDER}:${PROJECT_UPSTREAM_USER}/${PROJECT_NAME}.git"
        # git remote add --fetch --track ${WORKING_BRANCH} "${UPSTREAM}" "git@${GIT_PROVIDER}:${PROJECT_UPSTREAM_USER}/${PROJECT_NAME}.git"
        git remote -v
        git fetch "${UPSTREAM}" --prune
        git pull --all
    fi
}

function git_remove_remote() {
    if [ "$#" != "6" ]; then
        log_e "Usage: ${FUNCNAME[0]} <SRC_ROOT> <GIT_PROVIDER : bitbucket.com | github.com | gitlab.com> <PROJECT_UPSTREAM_USER> [<PROJECT_DOWNSTREAM_USER>] <PROJECT_NAME> <UPSTREAM>"
        log_e "${FUNCNAME[0]} $# ${*}"
    else
        log_m "${FUNCNAME[0]} $# ${*}"
        # cd "${TOP_DIR:?}" || exit 1

        if [ "$#" == "6" ]; then
            local SRC_ROOT=${1}
            local GIT_PROVIDER=${2}
            local PROJECT_UPSTREAM_USER=${3}
            local PROJECT_DOWNSTREAM_USER=${4}
            local PROJECT_NAME=${5}
            if [ -e "${SRC_ROOT}/${GIT_PROVIDER}/${PROJECT_DOWNSTREAM_USER}_${PROJECT_UPSTREAM_USER}/${PROJECT_NAME}" ]; then
                local PROJECT_DIR="${SRC_ROOT}/${GIT_PROVIDER}/${PROJECT_DOWNSTREAM_USER}_${PROJECT_UPSTREAM_USER}/${PROJECT_NAME}"
            elif [ -e "${SRC_ROOT}/${GIT_PROVIDER}/${PROJECT_DOWNSTREAM_USER}_${PROJECT_UPSTREAM_USER}/${PROJECT_NAME}-1" ]; then
                local PROJECT_DIR="${SRC_ROOT}/${GIT_PROVIDER}/${PROJECT_DOWNSTREAM_USER}_${PROJECT_UPSTREAM_USER}/${PROJECT_NAME}-1"
            elif [ -e "${SRC_ROOT}/${GIT_PROVIDER}/${PROJECT_DOWNSTREAM_USER}/${PROJECT_NAME}" ]; then
                local PROJECT_DIR="${SRC_ROOT}/${GIT_PROVIDER}/${PROJECT_DOWNSTREAM_USER}/${PROJECT_NAME}"
            else
                local PROJECT_DIR="${SRC_ROOT}/${GIT_PROVIDER}/${PROJECT_DOWNSTREAM_USER}/${PROJECT_NAME}-1"
            fi
            local UPSTREAM=${6} # upstream | ${PROJECT_UPSTREAM_USER}_${PROJECT_NAME}
        fi

        cd "${PROJECT_DIR}" || exit 1
        # ls -alh "${PROJECT_DIR}"

        git remote remove "${UPSTREAM}"
        git remote -v
    fi
}

function git_checkout_remote_branch() {
    if [ "$#" != "7" ] && [ "$#" != "8" ]; then
        log_e "Usage: ${FUNCNAME[0]} <SRC_ROOT> <GIT_PROVIDER : bitbucket.com | github.com | gitlab.com> <PROJECT_UPSTREAM_USER> [<PROJECT_DOWNSTREAM_USER>] <PROJECT_NAME> <UPSTREAM> <DOWNSTREAM> <WORKING_BRANCH>"
        log_e "${FUNCNAME[0]} $# ${*}"
    else
        log_m "${FUNCNAME[0]} $# ${*}"
        # cd "${TOP_DIR:?}" || exit 1

        if [ "$#" == "7" ]; then
            local SRC_ROOT=${1}
            local GIT_PROVIDER=${2}
            local PROJECT_UPSTREAM_USER=${3}
            local PROJECT_NAME=${4}
            local PROJECT_DIR="${SRC_ROOT}/${GIT_PROVIDER}/${PROJECT_UPSTREAM_USER}/${PROJECT_NAME}"
            local UPSTREAM=${5}   # origin
            local DOWNSTREAM=${6} # origin
            local WORKING_BRANCH=${7}
        elif [ "$#" == "8" ]; then
            local SRC_ROOT=${1}
            local GIT_PROVIDER=${2}
            local PROJECT_UPSTREAM_USER=${3}
            local PROJECT_DOWNSTREAM_USER=${4}
            local PROJECT_NAME=${5}
            local PROJECT_DIR="${SRC_ROOT}/${GIT_PROVIDER}/${PROJECT_DOWNSTREAM_USER}_${PROJECT_UPSTREAM_USER}/${PROJECT_NAME}"
            local UPSTREAM=${6}   # origin
            local DOWNSTREAM=${7} # origin
            local WORKING_BRANCH=${8}
        fi

        cd "${PROJECT_DIR}" || exit 1
        # ls -alh "${PROJECT_DIR}"

        git remote -v
        git fetch "${UPSTREAM}" --prune
        git pull --all
        git checkout -b "${WORKING_BRANCH}" "remotes/${UPSTREAM}/${WORKING_BRANCH}"
        git push "${DOWNSTREAM}"
        git branch --set-upstream-to "${DOWNSTREAM}/${WORKING_BRANCH}" "${WORKING_BRANCH}"
        git branch -avv
    fi
}

function git_checkout_remote_branch_as_working_branch() {
    if [ "$#" != "9" ]; then
        log_e "Usage: ${FUNCNAME[0]} <SRC_ROOT> <GIT_PROVIDER : bitbucket.com | github.com | gitlab.com> <PROJECT_UPSTREAM_USER> [<PROJECT_DOWNSTREAM_USER>] <PROJECT_NAME> <UPSTREAM> <DOWNSTREAM> <PROJECT_UPSTREAM_BRANCH> <WORKING_BRANCH>"
        log_e "${FUNCNAME[0]} $# ${*}"
    else
        log_m "${FUNCNAME[0]} $# ${*}"
        # cd "${TOP_DIR:?}" || exit 1

        if [ "$#" == "9" ]; then
            local SRC_ROOT=${1}
            local GIT_PROVIDER=${2}
            local PROJECT_UPSTREAM_USER=${3}
            local PROJECT_DOWNSTREAM_USER=${4}
            local PROJECT_NAME=${5}
            if [ -e "${SRC_ROOT}/${GIT_PROVIDER}/${PROJECT_DOWNSTREAM_USER}_${PROJECT_UPSTREAM_USER}/${PROJECT_NAME}" ]; then
                local PROJECT_DIR="${SRC_ROOT}/${GIT_PROVIDER}/${PROJECT_DOWNSTREAM_USER}_${PROJECT_UPSTREAM_USER}/${PROJECT_NAME}"
            elif [ -e "${SRC_ROOT}/${GIT_PROVIDER}/${PROJECT_DOWNSTREAM_USER}_${PROJECT_UPSTREAM_USER}/${PROJECT_NAME}-1" ]; then
                local PROJECT_DIR="${SRC_ROOT}/${GIT_PROVIDER}/${PROJECT_DOWNSTREAM_USER}_${PROJECT_UPSTREAM_USER}/${PROJECT_NAME}-1"
            elif [ -e "${SRC_ROOT}/${GIT_PROVIDER}/${PROJECT_DOWNSTREAM_USER}/${PROJECT_NAME}" ]; then
                local PROJECT_DIR="${SRC_ROOT}/${GIT_PROVIDER}/${PROJECT_DOWNSTREAM_USER}/${PROJECT_NAME}"
            else
                local PROJECT_DIR="${SRC_ROOT}/${GIT_PROVIDER}/${PROJECT_DOWNSTREAM_USER}/${PROJECT_NAME}-1"
            fi
            local UPSTREAM=${6}   # upstream | ${PROJECT_UPSTREAM_USER}_${PROJECT_NAME}
            local DOWNSTREAM=${7} # origin
            local PROJECT_UPSTREAM_BRANCH=${8}
            local WORKING_BRANCH=${9}
        fi

        cd "${PROJECT_DIR}" || exit 1
        # ls -alh "${PROJECT_DIR}"

        git remote -v
        git fetch "${UPSTREAM}" --prune
        git pull --all
        git checkout -b "${WORKING_BRANCH}" "remotes/${UPSTREAM}/${PROJECT_UPSTREAM_BRANCH}"
        git push --set-upstream ${DOWNSTREAM} "${WORKING_BRANCH}"
        git branch -avv
    fi
}

function git_checkout_pull_request_as_working_branch() {
    if [ "$#" != "9" ]; then
        log_e "Usage: ${FUNCNAME[0]} <SRC_ROOT> <GIT_PROVIDER : bitbucket.com | github.com | gitlab.com> <PROJECT_UPSTREAM_USER> [<PROJECT_DOWNSTREAM_USER>] <PROJECT_NAME> <UPSTREAM> <DOWNSTREAM> <WORKING_BRANCH> <PULL_REQUEST_ID>"
        log_e "${FUNCNAME[0]} $# ${*}"
    else
        log_m "${FUNCNAME[0]} $# ${*}"
        # cd "${TOP_DIR:?}" || exit 1

        if [ "$#" == "9" ]; then
            local SRC_ROOT=${1}
            local GIT_PROVIDER=${2}
            local PROJECT_UPSTREAM_USER=${3}
            local PROJECT_DOWNSTREAM_USER=${4}
            local PROJECT_NAME=${5}
            if [ -e "${SRC_ROOT}/${GIT_PROVIDER}/${PROJECT_DOWNSTREAM_USER}_${PROJECT_UPSTREAM_USER}/${PROJECT_NAME}" ]; then
                local PROJECT_DIR="${SRC_ROOT}/${GIT_PROVIDER}/${PROJECT_DOWNSTREAM_USER}_${PROJECT_UPSTREAM_USER}/${PROJECT_NAME}"
            elif [ -e "${SRC_ROOT}/${GIT_PROVIDER}/${PROJECT_DOWNSTREAM_USER}_${PROJECT_UPSTREAM_USER}/${PROJECT_NAME}-1" ]; then
                local PROJECT_DIR="${SRC_ROOT}/${GIT_PROVIDER}/${PROJECT_DOWNSTREAM_USER}_${PROJECT_UPSTREAM_USER}/${PROJECT_NAME}-1"
            elif [ -e "${SRC_ROOT}/${GIT_PROVIDER}/${PROJECT_DOWNSTREAM_USER}/${PROJECT_NAME}" ]; then
                local PROJECT_DIR="${SRC_ROOT}/${GIT_PROVIDER}/${PROJECT_DOWNSTREAM_USER}/${PROJECT_NAME}"
            else
                local PROJECT_DIR="${SRC_ROOT}/${GIT_PROVIDER}/${PROJECT_DOWNSTREAM_USER}/${PROJECT_NAME}-1"
            fi
            local UPSTREAM=${6}   # upstream | ${PROJECT_UPSTREAM_USER}_${PROJECT_NAME}
            local DOWNSTREAM=${7} # origin
            local WORKING_BRANCH=${8}
            local PULL_REQUEST_ID=${9}
        fi

        cd "${PROJECT_DIR}" || exit 1
        # ls -alh "${PROJECT_DIR}"

        git remote -v
        git fetch "${UPSTREAM}" --prune
        git pull --all
        git fetch "${UPSTREAM}" "pull/${PULL_REQUEST_ID}/head:${WORKING_BRANCH}"
        git checkout "${WORKING_BRANCH}"
        git branch -avv
    fi
}

function git_pull_remote_branch() {
    if [ "$#" != "5" ] && [ "$#" != "6" ]; then
        log_e "Usage: ${FUNCNAME[0]} <SRC_ROOT> <GIT_PROVIDER : bitbucket.com | github.com | gitlab.com> <PROJECT_UPSTREAM_USER> [<PROJECT_DOWNSTREAM_USER>] <PROJECT_NAME> <WORKING_BRANCH>"
        log_e "${FUNCNAME[0]} $# ${*}"
    else
        log_m "${FUNCNAME[0]} $# ${*}"
        # cd "${TOP_DIR:?}" || exit 1

        if [ "$#" == "5" ]; then
            local SRC_ROOT=${1}
            local GIT_PROVIDER=${2}
            local PROJECT_UPSTREAM_USER=${3}
            local PROJECT_NAME=${4}
            local PROJECT_DIR="${SRC_ROOT}/${GIT_PROVIDER}/${PROJECT_UPSTREAM_USER}/${PROJECT_NAME}"
            local WORKING_BRANCH=${5}
        elif [ "$#" == "6" ]; then
            local SRC_ROOT=${1}
            local GIT_PROVIDER=${2}
            local PROJECT_UPSTREAM_USER=${3}
            local PROJECT_DOWNSTREAM_USER=${4}
            local PROJECT_NAME=${5}
            local PROJECT_DIR="${SRC_ROOT}/${GIT_PROVIDER}/${PROJECT_DOWNSTREAM_USER}_${PROJECT_UPSTREAM_USER}/${PROJECT_NAME}"
            local WORKING_BRANCH=${6}
        fi

        cd "${PROJECT_DIR}" || exit 1
        # ls -alh "${PROJECT_DIR}"

        git checkout "${WORKING_BRANCH}"
        git pull --all
    fi
}

function git_fetch_and_merge() {
    if [ "$#" != "10" ]; then
        log_e "Usage: ${FUNCNAME[0]} <SRC_ROOT> <GIT_PROVIDER : bitbucket.com | github.com | gitlab.com> <PROJECT_UPSTREAM_USER> [<PROJECT_DOWNSTREAM_USER>] <PROJECT_NAME> <UPSTREAM> <DOWNSTREAM> <PROJECT_MAIN_BRANCH> <WORKING_BRANCH> <REBASE_METHOD>"
        log_e "${FUNCNAME[0]} $# ${*}"
    else
        log_m "${FUNCNAME[0]} $# ${*}"
        # cd "${TOP_DIR:?}" || exit 1

        if [ "$#" == "10" ]; then
            local SRC_ROOT=${1}
            local GIT_PROVIDER=${2}
            local PROJECT_UPSTREAM_USER=${3}
            local PROJECT_DOWNSTREAM_USER=${4}
            local PROJECT_NAME=${5}
            if [ -e "${SRC_ROOT}/${GIT_PROVIDER}/${PROJECT_DOWNSTREAM_USER}_${PROJECT_UPSTREAM_USER}/${PROJECT_NAME}" ]; then
                local PROJECT_DIR="${SRC_ROOT}/${GIT_PROVIDER}/${PROJECT_DOWNSTREAM_USER}_${PROJECT_UPSTREAM_USER}/${PROJECT_NAME}"
            elif [ -e "${SRC_ROOT}/${GIT_PROVIDER}/${PROJECT_DOWNSTREAM_USER}_${PROJECT_UPSTREAM_USER}/${PROJECT_NAME}-1" ]; then
                local PROJECT_DIR="${SRC_ROOT}/${GIT_PROVIDER}/${PROJECT_DOWNSTREAM_USER}_${PROJECT_UPSTREAM_USER}/${PROJECT_NAME}-1"
            elif [ -e "${SRC_ROOT}/${GIT_PROVIDER}/${PROJECT_DOWNSTREAM_USER}/${PROJECT_NAME}" ]; then
                local PROJECT_DIR="${SRC_ROOT}/${GIT_PROVIDER}/${PROJECT_DOWNSTREAM_USER}/${PROJECT_NAME}"
            else
                local PROJECT_DIR="${SRC_ROOT}/${GIT_PROVIDER}/${PROJECT_DOWNSTREAM_USER}/${PROJECT_NAME}-1"
            fi
            local UPSTREAM=${6}            # upstream | ${PROJECT_UPSTREAM_USER}_${PROJECT_NAME}
            local DOWNSTREAM=${7}          # origin
            local PROJECT_MAIN_BRANCH=${8} # master | main | develop
            local WORKING_BRANCH=${9}
            local REBASE_METHOD=${10} # rebase | merge
        fi

        cd "${PROJECT_DIR}" || exit 1
        # ls -alh "${PROJECT_DIR}"

        git checkout ${PROJECT_MAIN_BRANCH}
        git remote -v
        git fetch "${UPSTREAM}" --prune
        if [ "${REBASE_METHOD}" == "rebase" ]; then
            git pull --rebase --all
            git checkout "${WORKING_BRANCH}"
            git rebase ${PROJECT_MAIN_BRANCH}
        else
            git pull --all
            # git fetch --prune
            # git prune
            git checkout "${WORKING_BRANCH}"
            git merge "remotes/${UPSTREAM}/${WORKING_BRANCH}"
        fi
        git push "${DOWNSTREAM}" "${WORKING_BRANCH}"
        # git remote prune ${DOWNSTREAM}
        git branch -avv
    fi
}

function git_rebase_fork() {
    if [ "$#" != "9" ]; then
        log_e "Usage: ${FUNCNAME[0]} <SRC_ROOT> <GIT_PROVIDER : bitbucket.com | github.com | gitlab.com> <PROJECT_UPSTREAM_USER> [<PROJECT_DOWNSTREAM_USER>] <PROJECT_NAME> <DOWNSTREAM> <PROJECT_MAIN_BRANCH> <WORKING_BRANCH> <REBASE_BRANCH>"
        log_e "${FUNCNAME[0]} $# ${*}"
    else
        log_m "${FUNCNAME[0]} $# ${*}"
        # cd "${TOP_DIR:?}" || exit 1

        if [ "$#" == "9" ]; then
            local SRC_ROOT=${1}
            local GIT_PROVIDER=${2}
            local PROJECT_UPSTREAM_USER=${3}
            local PROJECT_DOWNSTREAM_USER=${4}
            local PROJECT_NAME=${5}
            if [ -e "${SRC_ROOT}/${GIT_PROVIDER}/${PROJECT_DOWNSTREAM_USER}_${PROJECT_UPSTREAM_USER}/${PROJECT_NAME}" ]; then
                local PROJECT_DIR="${SRC_ROOT}/${GIT_PROVIDER}/${PROJECT_DOWNSTREAM_USER}_${PROJECT_UPSTREAM_USER}/${PROJECT_NAME}"
            elif [ -e "${SRC_ROOT}/${GIT_PROVIDER}/${PROJECT_DOWNSTREAM_USER}_${PROJECT_UPSTREAM_USER}/${PROJECT_NAME}-1" ]; then
                local PROJECT_DIR="${SRC_ROOT}/${GIT_PROVIDER}/${PROJECT_DOWNSTREAM_USER}_${PROJECT_UPSTREAM_USER}/${PROJECT_NAME}-1"
            elif [ -e "${SRC_ROOT}/${GIT_PROVIDER}/${PROJECT_DOWNSTREAM_USER}/${PROJECT_NAME}" ]; then
                local PROJECT_DIR="${SRC_ROOT}/${GIT_PROVIDER}/${PROJECT_DOWNSTREAM_USER}/${PROJECT_NAME}"
            else
                local PROJECT_DIR="${SRC_ROOT}/${GIT_PROVIDER}/${PROJECT_DOWNSTREAM_USER}/${PROJECT_NAME}-1"
            fi
            local DOWNSTREAM=${6}          # origin
            local PROJECT_MAIN_BRANCH=${7} # master | main | develop
            local WORKING_BRANCH=${8}
            local REBASE_BRANCH=${9}
            # local SQUASH= # true | false
        fi

        cd "${PROJECT_DIR}" || exit 1
        # ls -alh "${PROJECT_DIR}"

        git checkout "${WORKING_BRANCH}"
        # git pull # --rebase --autostash
        # https://git-scm.com/docs/git-rebase
        if [ "${SQUASH}" == true ]; then
            git rebase --interactive --autosquash "${REBASE_BRANCH}"
        else
            git rebase "${REBASE_BRANCH}"
        fi
        # git reset --hard "${REBASE_BRANCH}"
    fi
}

function git_rebase_continue() {
    if [ "$#" != "5" ]; then
        log_e "Usage: ${FUNCNAME[0]} <SRC_ROOT> <GIT_PROVIDER : bitbucket.com | github.com | gitlab.com> <PROJECT_UPSTREAM_USER> [<PROJECT_DOWNSTREAM_USER>] <PROJECT_NAME>"
        log_e "${FUNCNAME[0]} $# ${*}"
    else
        log_m "${FUNCNAME[0]} $# ${*}"
        # cd "${TOP_DIR:?}" || exit 1

        if [ "$#" == "5" ]; then
            local SRC_ROOT=${1}
            local GIT_PROVIDER=${2}
            local PROJECT_UPSTREAM_USER=${3}
            local PROJECT_DOWNSTREAM_USER=${4}
            local PROJECT_NAME=${5}
            if [ -e "${SRC_ROOT}/${GIT_PROVIDER}/${PROJECT_DOWNSTREAM_USER}_${PROJECT_UPSTREAM_USER}/${PROJECT_NAME}" ]; then
                local PROJECT_DIR="${SRC_ROOT}/${GIT_PROVIDER}/${PROJECT_DOWNSTREAM_USER}_${PROJECT_UPSTREAM_USER}/${PROJECT_NAME}"
            elif [ -e "${SRC_ROOT}/${GIT_PROVIDER}/${PROJECT_DOWNSTREAM_USER}_${PROJECT_UPSTREAM_USER}/${PROJECT_NAME}-1" ]; then
                local PROJECT_DIR="${SRC_ROOT}/${GIT_PROVIDER}/${PROJECT_DOWNSTREAM_USER}_${PROJECT_UPSTREAM_USER}/${PROJECT_NAME}-1"
            elif [ -e "${SRC_ROOT}/${GIT_PROVIDER}/${PROJECT_DOWNSTREAM_USER}/${PROJECT_NAME}" ]; then
                local PROJECT_DIR="${SRC_ROOT}/${GIT_PROVIDER}/${PROJECT_DOWNSTREAM_USER}/${PROJECT_NAME}"
            else
                local PROJECT_DIR="${SRC_ROOT}/${GIT_PROVIDER}/${PROJECT_DOWNSTREAM_USER}/${PROJECT_NAME}-1"
            fi
        fi

        cd "${PROJECT_DIR}" || exit 1
        # ls -alh "${PROJECT_DIR}"

        git add *
        git rebase --continue
    fi
}

function git_rebase_abort() {
    if [ "$#" != "5" ]; then
        log_e "Usage: ${FUNCNAME[0]} <SRC_ROOT> <GIT_PROVIDER : bitbucket.com | github.com | gitlab.com> <PROJECT_UPSTREAM_USER> [<PROJECT_DOWNSTREAM_USER>] <PROJECT_NAME>"
        log_e "${FUNCNAME[0]} $# ${*}"
    else
        log_m "${FUNCNAME[0]} $# ${*}"
        # cd "${TOP_DIR:?}" || exit 1

        if [ "$#" == "5" ]; then
            local SRC_ROOT=${1}
            local GIT_PROVIDER=${2}
            local PROJECT_UPSTREAM_USER=${3}
            local PROJECT_DOWNSTREAM_USER=${4}
            local PROJECT_NAME=${5}
            if [ -e "${SRC_ROOT}/${GIT_PROVIDER}/${PROJECT_DOWNSTREAM_USER}_${PROJECT_UPSTREAM_USER}/${PROJECT_NAME}" ]; then
                local PROJECT_DIR="${SRC_ROOT}/${GIT_PROVIDER}/${PROJECT_DOWNSTREAM_USER}_${PROJECT_UPSTREAM_USER}/${PROJECT_NAME}"
            elif [ -e "${SRC_ROOT}/${GIT_PROVIDER}/${PROJECT_DOWNSTREAM_USER}_${PROJECT_UPSTREAM_USER}/${PROJECT_NAME}-1" ]; then
                local PROJECT_DIR="${SRC_ROOT}/${GIT_PROVIDER}/${PROJECT_DOWNSTREAM_USER}_${PROJECT_UPSTREAM_USER}/${PROJECT_NAME}-1"
            elif [ -e "${SRC_ROOT}/${GIT_PROVIDER}/${PROJECT_DOWNSTREAM_USER}/${PROJECT_NAME}" ]; then
                local PROJECT_DIR="${SRC_ROOT}/${GIT_PROVIDER}/${PROJECT_DOWNSTREAM_USER}/${PROJECT_NAME}"
            else
                local PROJECT_DIR="${SRC_ROOT}/${GIT_PROVIDER}/${PROJECT_DOWNSTREAM_USER}/${PROJECT_NAME}-1"
            fi
        fi

        cd "${PROJECT_DIR}" || exit 1
        # ls -alh "${PROJECT_DIR}"

        git rebase --abort
    fi
}

function git_push_fork() {
    if [ "$#" != "7" ]; then
        log_e "Usage: ${FUNCNAME[0]} <SRC_ROOT> <GIT_PROVIDER : bitbucket.com | github.com | gitlab.com> <PROJECT_UPSTREAM_USER> [<PROJECT_DOWNSTREAM_USER>] <PROJECT_NAME> <DOWNSTREAM> <GIT_PUSH_FORCE>"
        log_e "${FUNCNAME[0]} $# ${*}"
    else
        log_m "${FUNCNAME[0]} $# ${*}"
        # cd "${TOP_DIR:?}" || exit 1

        if [ "$#" == "7" ]; then
            local SRC_ROOT=${1}
            local GIT_PROVIDER=${2}
            local PROJECT_UPSTREAM_USER=${3}
            local PROJECT_DOWNSTREAM_USER=${4}
            local PROJECT_NAME=${5}
            if [ -e "${SRC_ROOT}/${GIT_PROVIDER}/${PROJECT_DOWNSTREAM_USER}_${PROJECT_UPSTREAM_USER}/${PROJECT_NAME}" ]; then
                local PROJECT_DIR="${SRC_ROOT}/${GIT_PROVIDER}/${PROJECT_DOWNSTREAM_USER}_${PROJECT_UPSTREAM_USER}/${PROJECT_NAME}"
            elif [ -e "${SRC_ROOT}/${GIT_PROVIDER}/${PROJECT_DOWNSTREAM_USER}_${PROJECT_UPSTREAM_USER}/${PROJECT_NAME}-1" ]; then
                local PROJECT_DIR="${SRC_ROOT}/${GIT_PROVIDER}/${PROJECT_DOWNSTREAM_USER}_${PROJECT_UPSTREAM_USER}/${PROJECT_NAME}-1"
            elif [ -e "${SRC_ROOT}/${GIT_PROVIDER}/${PROJECT_DOWNSTREAM_USER}/${PROJECT_NAME}" ]; then
                local PROJECT_DIR="${SRC_ROOT}/${GIT_PROVIDER}/${PROJECT_DOWNSTREAM_USER}/${PROJECT_NAME}"
            else
                local PROJECT_DIR="${SRC_ROOT}/${GIT_PROVIDER}/${PROJECT_DOWNSTREAM_USER}/${PROJECT_NAME}-1"
            fi
            local DOWNSTREAM=${6}     # origin
            local GIT_PUSH_FORCE=${7} # true | false
        fi

        cd "${PROJECT_DIR}" || exit 1
        # ls -alh "${PROJECT_DIR}"

        # git pull --rebase --autostash
        if [ "${GIT_PUSH_FORCE}" == true ]; then
            git push -f ${DOWNSTREAM}
        else
            git push ${DOWNSTREAM}
        fi
    fi
}

function git_select_branch() {
    if [ "$#" != "5" ]; then
        log_e "Usage: ${FUNCNAME[0]} <SRC_ROOT> <GIT_PROVIDER : bitbucket.com | github.com | gitlab.com> <PROJECT_UPSTREAM_USER> [<PROJECT_DOWNSTREAM_USER>] <PROJECT_NAME>"
        log_e "${FUNCNAME[0]} $# ${*}"
    else
        log_m "${FUNCNAME[0]} $# ${*}"
        # cd "${TOP_DIR:?}" || exit 1

        if [ "$#" == "5" ]; then
            local SRC_ROOT=${1}
            local GIT_PROVIDER=${2}
            local PROJECT_UPSTREAM_USER=${3}
            local PROJECT_DOWNSTREAM_USER=${4}
            local PROJECT_NAME=${5}
            if [ -e "${SRC_ROOT}/${GIT_PROVIDER}/${PROJECT_DOWNSTREAM_USER}_${PROJECT_UPSTREAM_USER}/${PROJECT_NAME}" ]; then
                local PROJECT_DIR="${SRC_ROOT}/${GIT_PROVIDER}/${PROJECT_DOWNSTREAM_USER}_${PROJECT_UPSTREAM_USER}/${PROJECT_NAME}"
            elif [ -e "${SRC_ROOT}/${GIT_PROVIDER}/${PROJECT_DOWNSTREAM_USER}_${PROJECT_UPSTREAM_USER}/${PROJECT_NAME}-1" ]; then
                local PROJECT_DIR="${SRC_ROOT}/${GIT_PROVIDER}/${PROJECT_DOWNSTREAM_USER}_${PROJECT_UPSTREAM_USER}/${PROJECT_NAME}-1"
            elif [ -e "${SRC_ROOT}/${GIT_PROVIDER}/${PROJECT_DOWNSTREAM_USER}/${PROJECT_NAME}" ]; then
                local PROJECT_DIR="${SRC_ROOT}/${GIT_PROVIDER}/${PROJECT_DOWNSTREAM_USER}/${PROJECT_NAME}"
            else
                local PROJECT_DIR="${SRC_ROOT}/${GIT_PROVIDER}/${PROJECT_DOWNSTREAM_USER}/${PROJECT_NAME}-1"
            fi
        fi

        cd "${PROJECT_DIR}" || exit 1
        # ls -alh "${PROJECT_DIR}"

        BRANCHES=$(git branch | tr -d '\n' | sed 's/*//g' | sed 's/  */ /g' | sed -e 's/^[ \t]*//' | sed 's/[[:space:]]\{1,\}$//')
        select_x_from_array "${BRANCHES}" "SELECTED_BRANCH" SELECTED_BRANCH
        git checkout ${SELECTED_BRANCH}
        git log | head -9
    fi
}

function git_checkout() {
    if [ "$#" != "6" ] && [ "$#" != "7" ]; then
        log_e "Usage: ${FUNCNAME[0]} <SRC_ROOT> <GIT_PROVIDER : bitbucket.com | github.com | gitlab.com> <PROJECT_UPSTREAM_USER> [<PROJECT_DOWNSTREAM_USER>] <PROJECT_NAME> <WORKING_BRANCH> [<TAG>]"
        log_e "${FUNCNAME[0]} $# ${*}"
    else
        log_m "${FUNCNAME[0]} $# ${*}"
        # cd "${TOP_DIR:?}" || exit 1

        if [ "$#" == "6" ]; then
            local SRC_ROOT=${1}
            local GIT_PROVIDER=${2}
            local PROJECT_UPSTREAM_USER=${3}
            local PROJECT_DOWNSTREAM_USER=${4}
            local PROJECT_NAME=${5}
            if [ -e "${SRC_ROOT}/${GIT_PROVIDER}/${PROJECT_DOWNSTREAM_USER}_${PROJECT_UPSTREAM_USER}/${PROJECT_NAME}" ]; then
                local PROJECT_DIR="${SRC_ROOT}/${GIT_PROVIDER}/${PROJECT_DOWNSTREAM_USER}_${PROJECT_UPSTREAM_USER}/${PROJECT_NAME}"
            elif [ -e "${SRC_ROOT}/${GIT_PROVIDER}/${PROJECT_DOWNSTREAM_USER}_${PROJECT_UPSTREAM_USER}/${PROJECT_NAME}-1" ]; then
                local PROJECT_DIR="${SRC_ROOT}/${GIT_PROVIDER}/${PROJECT_DOWNSTREAM_USER}_${PROJECT_UPSTREAM_USER}/${PROJECT_NAME}-1"
            elif [ -e "${SRC_ROOT}/${GIT_PROVIDER}/${PROJECT_DOWNSTREAM_USER}/${PROJECT_NAME}" ]; then
                local PROJECT_DIR="${SRC_ROOT}/${GIT_PROVIDER}/${PROJECT_DOWNSTREAM_USER}/${PROJECT_NAME}"
            else
                local PROJECT_DIR="${SRC_ROOT}/${GIT_PROVIDER}/${PROJECT_DOWNSTREAM_USER}/${PROJECT_NAME}-1"
            fi
            local WORKING_BRANCH=${6}
        elif [ "$#" == "7" ]; then
            local SRC_ROOT=${1}
            local GIT_PROVIDER=${2}
            local PROJECT_UPSTREAM_USER=${3}
            local PROJECT_DOWNSTREAM_USER=${4}
            local PROJECT_NAME=${5}
            if [ -e "${SRC_ROOT}/${GIT_PROVIDER}/${PROJECT_DOWNSTREAM_USER}_${PROJECT_UPSTREAM_USER}/${PROJECT_NAME}" ]; then
                local PROJECT_DIR="${SRC_ROOT}/${GIT_PROVIDER}/${PROJECT_DOWNSTREAM_USER}_${PROJECT_UPSTREAM_USER}/${PROJECT_NAME}"
            elif [ -e "${SRC_ROOT}/${GIT_PROVIDER}/${PROJECT_DOWNSTREAM_USER}_${PROJECT_UPSTREAM_USER}/${PROJECT_NAME}-1" ]; then
                local PROJECT_DIR="${SRC_ROOT}/${GIT_PROVIDER}/${PROJECT_DOWNSTREAM_USER}_${PROJECT_UPSTREAM_USER}/${PROJECT_NAME}-1"
            elif [ -e "${SRC_ROOT}/${GIT_PROVIDER}/${PROJECT_DOWNSTREAM_USER}/${PROJECT_NAME}" ]; then
                local PROJECT_DIR="${SRC_ROOT}/${GIT_PROVIDER}/${PROJECT_DOWNSTREAM_USER}/${PROJECT_NAME}"
            else
                local PROJECT_DIR="${SRC_ROOT}/${GIT_PROVIDER}/${PROJECT_DOWNSTREAM_USER}/${PROJECT_NAME}-1"
            fi
            local WORKING_BRANCH=${6}
            local TAG=${7}
        fi

        cd "${PROJECT_DIR}" || exit 1
        # ls -alh "${PROJECT_DIR}"

        if [ "$#" == "6" ]; then
            git checkout ${WORKING_BRANCH}
        else
            git checkout -b ${TAG} ${TAG}
            # git checkout -b tags/${TAG} ${TAG}
        fi
        git log | head -9
        git branch -avv
    fi
}

function git_create_working_branch() {
    if [ "$#" != "8" ]; then
        log_e "Usage: ${FUNCNAME[0]} <SRC_ROOT> <GIT_PROVIDER : bitbucket.com | github.com | gitlab.com> <PROJECT_UPSTREAM_USER> [<PROJECT_DOWNSTREAM_USER>] <PROJECT_NAME> <ORIGINAL_BRANCH:master> <WORKING_BRANCH> <DOWNSTREAM>"
        log_e "${FUNCNAME[0]} $# ${*}"
    else
        log_m "${FUNCNAME[0]} $# ${*}"
        # cd "${TOP_DIR:?}" || exit 1

        if [ "$#" == "8" ]; then
            local SRC_ROOT=${1}
            local GIT_PROVIDER=${2}
            local PROJECT_UPSTREAM_USER=${3}
            local PROJECT_DOWNSTREAM_USER=${4}
            local PROJECT_NAME=${5}
            if [ -e "${SRC_ROOT}/${GIT_PROVIDER}/${PROJECT_DOWNSTREAM_USER}_${PROJECT_UPSTREAM_USER}/${PROJECT_NAME}" ]; then
                local PROJECT_DIR="${SRC_ROOT}/${GIT_PROVIDER}/${PROJECT_DOWNSTREAM_USER}_${PROJECT_UPSTREAM_USER}/${PROJECT_NAME}"
            elif [ -e "${SRC_ROOT}/${GIT_PROVIDER}/${PROJECT_DOWNSTREAM_USER}_${PROJECT_UPSTREAM_USER}/${PROJECT_NAME}-1" ]; then
                local PROJECT_DIR="${SRC_ROOT}/${GIT_PROVIDER}/${PROJECT_DOWNSTREAM_USER}_${PROJECT_UPSTREAM_USER}/${PROJECT_NAME}-1"
            elif [ -e "${SRC_ROOT}/${GIT_PROVIDER}/${PROJECT_DOWNSTREAM_USER}/${PROJECT_NAME}" ]; then
                local PROJECT_DIR="${SRC_ROOT}/${GIT_PROVIDER}/${PROJECT_DOWNSTREAM_USER}/${PROJECT_NAME}"
            else
                local PROJECT_DIR="${SRC_ROOT}/${GIT_PROVIDER}/${PROJECT_DOWNSTREAM_USER}/${PROJECT_NAME}-1"
            fi
            local ORIGINAL_BRANCH=${6}
            local WORKING_BRANCH=${7}
            local DOWNSTREAM=${8} # origin
        fi

        cd "${PROJECT_DIR}" || exit 1
        # ls -alh "${PROJECT_DIR}"

        git checkout ${ORIGINAL_BRANCH}
        git fetch --prune
        git pull --all
        git checkout -b ${WORKING_BRANCH}
        git push --set-upstream ${DOWNSTREAM} ${WORKING_BRANCH}
        git branch -avv
    fi
}

function git_create_working_branch_from_commit() {
    if [ "$#" != "9" ]; then
        log_e "Usage: ${FUNCNAME[0]} <SRC_ROOT> <GIT_PROVIDER : bitbucket.com | github.com | gitlab.com> <PROJECT_UPSTREAM_USER> [<PROJECT_DOWNSTREAM_USER>] <PROJECT_NAME> <ORIGINAL_BRANCH:master> <WORKING_BRANCH> <COMMIT_HASH> <DOWNSTREAM>"
        log_e "${FUNCNAME[0]} $# ${*}"
    else
        log_m "${FUNCNAME[0]} $# ${*}"
        # cd "${TOP_DIR:?}" || exit 1

        if [ "$#" == "9" ]; then
            local SRC_ROOT=${1}
            local GIT_PROVIDER=${2}
            local PROJECT_UPSTREAM_USER=${3}
            local PROJECT_DOWNSTREAM_USER=${4}
            local PROJECT_NAME=${5}
            if [ -e "${SRC_ROOT}/${GIT_PROVIDER}/${PROJECT_DOWNSTREAM_USER}_${PROJECT_UPSTREAM_USER}/${PROJECT_NAME}" ]; then
                local PROJECT_DIR="${SRC_ROOT}/${GIT_PROVIDER}/${PROJECT_DOWNSTREAM_USER}_${PROJECT_UPSTREAM_USER}/${PROJECT_NAME}"
            elif [ -e "${SRC_ROOT}/${GIT_PROVIDER}/${PROJECT_DOWNSTREAM_USER}_${PROJECT_UPSTREAM_USER}/${PROJECT_NAME}-1" ]; then
                local PROJECT_DIR="${SRC_ROOT}/${GIT_PROVIDER}/${PROJECT_DOWNSTREAM_USER}_${PROJECT_UPSTREAM_USER}/${PROJECT_NAME}-1"
            elif [ -e "${SRC_ROOT}/${GIT_PROVIDER}/${PROJECT_DOWNSTREAM_USER}/${PROJECT_NAME}" ]; then
                local PROJECT_DIR="${SRC_ROOT}/${GIT_PROVIDER}/${PROJECT_DOWNSTREAM_USER}/${PROJECT_NAME}"
            else
                local PROJECT_DIR="${SRC_ROOT}/${GIT_PROVIDER}/${PROJECT_DOWNSTREAM_USER}/${PROJECT_NAME}-1"
            fi
            local ORIGINAL_BRANCH=${6}
            local WORKING_BRANCH=${7}
            local COMMIT_HASH=${8}
            local DOWNSTREAM=${9} # origin
        fi

        cd "${PROJECT_DIR}" || exit 1
        # ls -alh "${PROJECT_DIR}"

        git checkout ${ORIGINAL_BRANCH} ${COMMIT_HASH}
        git fetch --prune
        git pull --all
        git checkout -b ${WORKING_BRANCH}
        git push --set-upstream ${DOWNSTREAM} ${WORKING_BRANCH}
        git branch -avv
    fi
}

function git_pull() {
    if [ "$#" != "5" ]; then
        log_e "Usage: ${FUNCNAME[0]} <SRC_ROOT> <GIT_PROVIDER : bitbucket.com | github.com | gitlab.com> <PROJECT_UPSTREAM_USER> [<PROJECT_DOWNSTREAM_USER>] <PROJECT_NAME>"
        log_e "${FUNCNAME[0]} $# ${*}"
    else
        log_m "${FUNCNAME[0]} $# ${*}"
        # cd "${TOP_DIR:?}" || exit 1

        if [ "$#" == "5" ]; then
            local SRC_ROOT=${1}
            local GIT_PROVIDER=${2}
            local PROJECT_UPSTREAM_USER=${3}
            local PROJECT_DOWNSTREAM_USER=${4}
            local PROJECT_NAME=${5}
            if [ -e "${SRC_ROOT}/${GIT_PROVIDER}/${PROJECT_DOWNSTREAM_USER}_${PROJECT_UPSTREAM_USER}/${PROJECT_NAME}" ]; then
                local PROJECT_DIR="${SRC_ROOT}/${GIT_PROVIDER}/${PROJECT_DOWNSTREAM_USER}_${PROJECT_UPSTREAM_USER}/${PROJECT_NAME}"
            elif [ -e "${SRC_ROOT}/${GIT_PROVIDER}/${PROJECT_DOWNSTREAM_USER}_${PROJECT_UPSTREAM_USER}/${PROJECT_NAME}-1" ]; then
                local PROJECT_DIR="${SRC_ROOT}/${GIT_PROVIDER}/${PROJECT_DOWNSTREAM_USER}_${PROJECT_UPSTREAM_USER}/${PROJECT_NAME}-1"
            elif [ -e "${SRC_ROOT}/${GIT_PROVIDER}/${PROJECT_DOWNSTREAM_USER}/${PROJECT_NAME}" ]; then
                local PROJECT_DIR="${SRC_ROOT}/${GIT_PROVIDER}/${PROJECT_DOWNSTREAM_USER}/${PROJECT_NAME}"
            else
                local PROJECT_DIR="${SRC_ROOT}/${GIT_PROVIDER}/${PROJECT_DOWNSTREAM_USER}/${PROJECT_NAME}-1"
            fi
        fi

        cd "${PROJECT_DIR}" || exit 1
        # ls -alh "${PROJECT_DIR}"

        git fetch --prune
        git pull --all
    fi
}

function git_commit() {
    if [ "$#" != "15" ]; then
        log_e "Usage: ${FUNCNAME[0]} <SRC_ROOT> <GIT_PROVIDER : bitbucket.com | github.com | gitlab.com> <PROJECT_UPSTREAM_USER> [<PROJECT_DOWNSTREAM_USER>] <PROJECT_NAME> <GIT_RESET_TO_HEAD> <SIGNING_COMMIT> <SIGNED_OFF_BY> <GIT_PUSH_FORCE> <DOWNSTREAM> <PROJECT_MAIN_BRANCH> <WORKING_BRANCH> <COMMIT_DESCRIPTION> <COMMIT_BODY> [<ISSUE_URL>]"
        log_e "${FUNCNAME[0]} $# ${*}"
    else
        log_m "${FUNCNAME[0]} $# ${*}"
        # cd "${TOP_DIR:?}" || exit 1

        if [ "$#" == "15" ]; then
            local SRC_ROOT=${1}
            local GIT_PROVIDER=${2}
            local PROJECT_UPSTREAM_USER=${3}
            local PROJECT_DOWNSTREAM_USER=${4}
            local PROJECT_NAME=${5}
            if [ -e "${SRC_ROOT}/${GIT_PROVIDER}/${PROJECT_DOWNSTREAM_USER}_${PROJECT_UPSTREAM_USER}/${PROJECT_NAME}" ]; then
                local PROJECT_DIR="${SRC_ROOT}/${GIT_PROVIDER}/${PROJECT_DOWNSTREAM_USER}_${PROJECT_UPSTREAM_USER}/${PROJECT_NAME}"
            elif [ -e "${SRC_ROOT}/${GIT_PROVIDER}/${PROJECT_DOWNSTREAM_USER}_${PROJECT_UPSTREAM_USER}/${PROJECT_NAME}-1" ]; then
                local PROJECT_DIR="${SRC_ROOT}/${GIT_PROVIDER}/${PROJECT_DOWNSTREAM_USER}_${PROJECT_UPSTREAM_USER}/${PROJECT_NAME}-1"
            elif [ -e "${SRC_ROOT}/${GIT_PROVIDER}/${PROJECT_DOWNSTREAM_USER}/${PROJECT_NAME}" ]; then
                local PROJECT_DIR="${SRC_ROOT}/${GIT_PROVIDER}/${PROJECT_DOWNSTREAM_USER}/${PROJECT_NAME}"
            else
                local PROJECT_DIR="${SRC_ROOT}/${GIT_PROVIDER}/${PROJECT_DOWNSTREAM_USER}/${PROJECT_NAME}-1"
            fi
            local GIT_RESET_TO_HEAD=${6}    # true | false
            local SIGNING_COMMIT=${7}       # true | false
            local SIGNED_OFF_BY=${8}        # true | false
            local GIT_PUSH_FORCE=${9}       # true | false
            local DOWNSTREAM=${10}          # origin
            local PROJECT_MAIN_BRANCH=${11} # master | main | develop
            local WORKING_BRANCH=${12}
            local COMMIT_DESCRIPTION=${13}
            local COMMIT_BODY=${14}
            local ISSUE_URL=${15}
        fi

        cd "${PROJECT_DIR}" || exit 1
        # ls -alh "${PROJECT_DIR}"

        if [ $(git branch --show-current) != "${WORKING_BRANCH}" ]; then
            log_e "Please manually confirm working WORKING_BRANCH before continue."
        fi

        if [ "${GIT_RESET_TO_HEAD}" == true ]; then
            git reset $(git rev-parse ${DOWNSTREAM}/${PROJECT_MAIN_BRANCH})
        fi

        git add *

        if [ "${SIGNING_COMMIT}" == true ]; then
            git commit -s -S -m "${COMMIT_DESCRIPTION}" -m "${COMMIT_BODY}" -m "${ISSUE_URL}"
        elif [ "${SIGNED_OFF_BY}" == true ]; then
            git commit -s -m "${COMMIT_DESCRIPTION}" -m "${COMMIT_BODY}" -m "${ISSUE_URL}"
        else
            git commit -m "${COMMIT_DESCRIPTION}" -m "${COMMIT_BODY}" -m "${ISSUE_URL}"
        fi

        git log | head -9

        if [ "${GIT_PUSH_FORCE}" == true ]; then
            git push -f ${DOWNSTREAM}
        else
            git push ${DOWNSTREAM}
        fi
    fi
}

function git_cherry_pick() {
    if [ "$#" != "9" ]; then
        log_e "Usage: ${FUNCNAME[0]} <SRC_ROOT> <GIT_PROVIDER : bitbucket.com | github.com | gitlab.com> <PROJECT_UPSTREAM_USER> [<PROJECT_DOWNSTREAM_USER>] <PROJECT_NAME> <WORKING_BRANCH> <COMMIT_HASH> <GIT_PUSH_FORCE> <DOWNSTREAM>"
        log_e "${FUNCNAME[0]} $# ${*}"
    else
        log_m "${FUNCNAME[0]} $# ${*}"
        # cd "${TOP_DIR:?}" || exit 1

        if [ "$#" == "9" ]; then
            local SRC_ROOT=${1}
            local GIT_PROVIDER=${2}
            local PROJECT_UPSTREAM_USER=${3}
            local PROJECT_DOWNSTREAM_USER=${4}
            local PROJECT_NAME=${5}
            if [ -e "${SRC_ROOT}/${GIT_PROVIDER}/${PROJECT_DOWNSTREAM_USER}_${PROJECT_UPSTREAM_USER}/${PROJECT_NAME}" ]; then
                local PROJECT_DIR="${SRC_ROOT}/${GIT_PROVIDER}/${PROJECT_DOWNSTREAM_USER}_${PROJECT_UPSTREAM_USER}/${PROJECT_NAME}"
            elif [ -e "${SRC_ROOT}/${GIT_PROVIDER}/${PROJECT_DOWNSTREAM_USER}_${PROJECT_UPSTREAM_USER}/${PROJECT_NAME}-1" ]; then
                local PROJECT_DIR="${SRC_ROOT}/${GIT_PROVIDER}/${PROJECT_DOWNSTREAM_USER}_${PROJECT_UPSTREAM_USER}/${PROJECT_NAME}-1"
            elif [ -e "${SRC_ROOT}/${GIT_PROVIDER}/${PROJECT_DOWNSTREAM_USER}/${PROJECT_NAME}" ]; then
                local PROJECT_DIR="${SRC_ROOT}/${GIT_PROVIDER}/${PROJECT_DOWNSTREAM_USER}/${PROJECT_NAME}"
            else
                local PROJECT_DIR="${SRC_ROOT}/${GIT_PROVIDER}/${PROJECT_DOWNSTREAM_USER}/${PROJECT_NAME}-1"
            fi
            local WORKING_BRANCH=${6}
            local COMMIT_HASH=${7}
            local GIT_PUSH_FORCE=${8}
            local DOWNSTREAM=${9} # origin
        fi

        cd "${PROJECT_DIR}" || exit 1
        # ls -alh "${PROJECT_DIR}"

        git checkout ${WORKING_BRANCH}
        git log | head -9
        git cherry-pick -x ${COMMIT_HASH}
        git log | head -9

        if [ "${GIT_PUSH_FORCE}" == true ]; then
            git push -f ${DOWNSTREAM}
        else
            git push ${DOWNSTREAM}
        fi
    fi
}

function git_amend() {
    if [ "$#" != "9" ]; then
        log_e "Usage: ${FUNCNAME[0]} <SRC_ROOT> <GIT_PROVIDER : bitbucket.com | github.com | gitlab.com> <PROJECT_UPSTREAM_USER> [<PROJECT_DOWNSTREAM_USER>] <PROJECT_NAME> <SIGNING_COMMIT> <SIGNED_OFF_BY> <GIT_PUSH_FORCE> <DOWNSTREAM>"
        log_e "${FUNCNAME[0]} $# ${*}"
    else
        log_m "${FUNCNAME[0]} $# ${*}"
        # cd "${TOP_DIR:?}" || exit 1

        if [ "$#" == "9" ]; then
            local SRC_ROOT=${1}
            local GIT_PROVIDER=${2}
            local PROJECT_UPSTREAM_USER=${3}
            local PROJECT_DOWNSTREAM_USER=${4}
            local PROJECT_NAME=${5}
            if [ -e "${SRC_ROOT}/${GIT_PROVIDER}/${PROJECT_DOWNSTREAM_USER}_${PROJECT_UPSTREAM_USER}/${PROJECT_NAME}" ]; then
                local PROJECT_DIR="${SRC_ROOT}/${GIT_PROVIDER}/${PROJECT_DOWNSTREAM_USER}_${PROJECT_UPSTREAM_USER}/${PROJECT_NAME}"
            elif [ -e "${SRC_ROOT}/${GIT_PROVIDER}/${PROJECT_DOWNSTREAM_USER}_${PROJECT_UPSTREAM_USER}/${PROJECT_NAME}-1" ]; then
                local PROJECT_DIR="${SRC_ROOT}/${GIT_PROVIDER}/${PROJECT_DOWNSTREAM_USER}_${PROJECT_UPSTREAM_USER}/${PROJECT_NAME}-1"
            elif [ -e "${SRC_ROOT}/${GIT_PROVIDER}/${PROJECT_DOWNSTREAM_USER}/${PROJECT_NAME}" ]; then
                local PROJECT_DIR="${SRC_ROOT}/${GIT_PROVIDER}/${PROJECT_DOWNSTREAM_USER}/${PROJECT_NAME}"
            else
                local PROJECT_DIR="${SRC_ROOT}/${GIT_PROVIDER}/${PROJECT_DOWNSTREAM_USER}/${PROJECT_NAME}-1"
            fi
            local SIGNING_COMMIT=${6}
            local SIGNED_OFF_BY=${7}
            local GIT_PUSH_FORCE=${8}
            local DOWNSTREAM=${9} # origin
        fi

        cd "${PROJECT_DIR}" || exit 1
        # ls -alh "${PROJECT_DIR}"

        if [ "${SIGNING_COMMIT}" == true ]; then
            git commit --amend -s -S
        elif [ "${SIGNED_OFF_BY}" == true ]; then
            git commit --amend -s
        else
            git commit --amend
        fi

        git log | head -9

        if [ "${GIT_PUSH_FORCE}" == true ]; then
            git push -f ${DOWNSTREAM}
        else
            git push ${DOWNSTREAM}
        fi
    fi
}

function git_push() {
    if [ "$#" != "7" ]; then
        log_e "Usage: ${FUNCNAME[0]} <SRC_ROOT> <GIT_PROVIDER : bitbucket.com | github.com | gitlab.com> <PROJECT_UPSTREAM_USER> [<PROJECT_DOWNSTREAM_USER>] <PROJECT_NAME> <GIT_PUSH_FORCE> <DOWNSTREAM>"
        log_e "${FUNCNAME[0]} $# ${*}"
    else
        log_m "${FUNCNAME[0]} $# ${*}"
        # cd "${TOP_DIR:?}" || exit 1

        if [ "$#" == "7" ]; then
            local SRC_ROOT=${1}
            local GIT_PROVIDER=${2}
            local PROJECT_UPSTREAM_USER=${3}
            local PROJECT_DOWNSTREAM_USER=${4}
            local PROJECT_NAME=${5}
            if [ -e "${SRC_ROOT}/${GIT_PROVIDER}/${PROJECT_DOWNSTREAM_USER}_${PROJECT_UPSTREAM_USER}/${PROJECT_NAME}" ]; then
                local PROJECT_DIR="${SRC_ROOT}/${GIT_PROVIDER}/${PROJECT_DOWNSTREAM_USER}_${PROJECT_UPSTREAM_USER}/${PROJECT_NAME}"
            elif [ -e "${SRC_ROOT}/${GIT_PROVIDER}/${PROJECT_DOWNSTREAM_USER}_${PROJECT_UPSTREAM_USER}/${PROJECT_NAME}-1" ]; then
                local PROJECT_DIR="${SRC_ROOT}/${GIT_PROVIDER}/${PROJECT_DOWNSTREAM_USER}_${PROJECT_UPSTREAM_USER}/${PROJECT_NAME}-1"
            elif [ -e "${SRC_ROOT}/${GIT_PROVIDER}/${PROJECT_DOWNSTREAM_USER}/${PROJECT_NAME}" ]; then
                local PROJECT_DIR="${SRC_ROOT}/${GIT_PROVIDER}/${PROJECT_DOWNSTREAM_USER}/${PROJECT_NAME}"
            else
                local PROJECT_DIR="${SRC_ROOT}/${GIT_PROVIDER}/${PROJECT_DOWNSTREAM_USER}/${PROJECT_NAME}-1"
            fi
            local GIT_PUSH_FORCE=${6}
            local DOWNSTREAM=${7} # origin
        fi

        cd "${PROJECT_DIR}" || exit 1
        # ls -alh "${PROJECT_DIR}"

        git log | head -9

        if [ "${GIT_PUSH_FORCE}" == true ]; then
            git push -f ${DOWNSTREAM}
        else
            git push ${DOWNSTREAM}
        fi
    fi
}

function git_tag_branch() {
    if [ "$#" != "7" ]; then
        log_e "Usage: ${FUNCNAME[0]} <SRC_ROOT> <GIT_PROVIDER : bitbucket.com | github.com | gitlab.com> <PROJECT_UPSTREAM_USER> [<PROJECT_DOWNSTREAM_USER>] <PROJECT_NAME> <DOWNSTREAM> <TAG>"
        log_e "${FUNCNAME[0]} $# ${*}"
    else
        log_m "${FUNCNAME[0]} $# ${*}"
        # cd "${TOP_DIR:?}" || exit 1

        if [ "$#" == "7" ]; then
            local SRC_ROOT=${1}
            local GIT_PROVIDER=${2}
            local PROJECT_UPSTREAM_USER=${3}
            local PROJECT_DOWNSTREAM_USER=${4}
            local PROJECT_NAME=${5}
            if [ -e "${SRC_ROOT}/${GIT_PROVIDER}/${PROJECT_DOWNSTREAM_USER}_${PROJECT_UPSTREAM_USER}/${PROJECT_NAME}" ]; then
                local PROJECT_DIR="${SRC_ROOT}/${GIT_PROVIDER}/${PROJECT_DOWNSTREAM_USER}_${PROJECT_UPSTREAM_USER}/${PROJECT_NAME}"
            elif [ -e "${SRC_ROOT}/${GIT_PROVIDER}/${PROJECT_DOWNSTREAM_USER}_${PROJECT_UPSTREAM_USER}/${PROJECT_NAME}-1" ]; then
                local PROJECT_DIR="${SRC_ROOT}/${GIT_PROVIDER}/${PROJECT_DOWNSTREAM_USER}_${PROJECT_UPSTREAM_USER}/${PROJECT_NAME}-1"
            elif [ -e "${SRC_ROOT}/${GIT_PROVIDER}/${PROJECT_DOWNSTREAM_USER}/${PROJECT_NAME}" ]; then
                local PROJECT_DIR="${SRC_ROOT}/${GIT_PROVIDER}/${PROJECT_DOWNSTREAM_USER}/${PROJECT_NAME}"
            else
                local PROJECT_DIR="${SRC_ROOT}/${GIT_PROVIDER}/${PROJECT_DOWNSTREAM_USER}/${PROJECT_NAME}-1"
            fi
            local DOWNSTREAM=${6}
            local TAG=${7}
        fi

        cd "${PROJECT_DIR}" || exit 1
        # ls -alh "${PROJECT_DIR}"
        git tag ${TAG}
        # git tag -l
        git push ${DOWNSTREAM} "${TAG}" -f
        git ls-remote --tags
    fi
}

function git_tag_commit() {
    if [ "$#" != "8" ]; then
        log_e "Usage: ${FUNCNAME[0]} <SRC_ROOT> <GIT_PROVIDER : bitbucket.com | github.com | gitlab.com> <PROJECT_UPSTREAM_USER> [<PROJECT_DOWNSTREAM_USER>] <PROJECT_NAME <DOWNSTREAM> <TAG> <COMMIT_HASH>"
        log_e "${FUNCNAME[0]} $# ${*}"
    else
        log_m "${FUNCNAME[0]} $# ${*}"
        # cd "${TOP_DIR:?}" || exit 1

        if [ "$#" == "8" ]; then
            local SRC_ROOT=${1}
            local GIT_PROVIDER=${2}
            local PROJECT_UPSTREAM_USER=${3}
            local PROJECT_DOWNSTREAM_USER=${4}
            local PROJECT_NAME=${5}
            if [ -e "${SRC_ROOT}/${GIT_PROVIDER}/${PROJECT_DOWNSTREAM_USER}_${PROJECT_UPSTREAM_USER}/${PROJECT_NAME}" ]; then
                local PROJECT_DIR="${SRC_ROOT}/${GIT_PROVIDER}/${PROJECT_DOWNSTREAM_USER}_${PROJECT_UPSTREAM_USER}/${PROJECT_NAME}"
            elif [ -e "${SRC_ROOT}/${GIT_PROVIDER}/${PROJECT_DOWNSTREAM_USER}_${PROJECT_UPSTREAM_USER}/${PROJECT_NAME}-1" ]; then
                local PROJECT_DIR="${SRC_ROOT}/${GIT_PROVIDER}/${PROJECT_DOWNSTREAM_USER}_${PROJECT_UPSTREAM_USER}/${PROJECT_NAME}-1"
            elif [ -e "${SRC_ROOT}/${GIT_PROVIDER}/${PROJECT_DOWNSTREAM_USER}/${PROJECT_NAME}" ]; then
                local PROJECT_DIR="${SRC_ROOT}/${GIT_PROVIDER}/${PROJECT_DOWNSTREAM_USER}/${PROJECT_NAME}"
            else
                local PROJECT_DIR="${SRC_ROOT}/${GIT_PROVIDER}/${PROJECT_DOWNSTREAM_USER}/${PROJECT_NAME}-1"
            fi
            local DOWNSTREAM=${6}
            local TAG=${7}
            local COMMIT_HASH=${8}
        fi

        cd "${PROJECT_DIR}" || exit 1
        # ls -alh "${PROJECT_DIR}"

        git tag ${TAG} "${COMMIT_HASH}"
        # git tag -l
        git push ${DOWNSTREAM} "${TAG}" -f
        git ls-remote --tags
    fi
}

function git_tag_delete() {
    if [ "$#" != "7" ]; then
        log_e "Usage: ${FUNCNAME[0]} <SRC_ROOT> <GIT_PROVIDER : bitbucket.com | github.com | gitlab.com> <PROJECT_UPSTREAM_USER> [<PROJECT_DOWNSTREAM_USER>] <PROJECT_NAME> <DOWNSTREAM> <TAG>"
        log_e "${FUNCNAME[0]} $# ${*}"
    else
        log_m "${FUNCNAME[0]} $# ${*}"
        # cd "${TOP_DIR:?}" || exit 1

        if [ "$#" == "7" ]; then
            local SRC_ROOT=${1}
            local GIT_PROVIDER=${2}
            local PROJECT_UPSTREAM_USER=${3}
            local PROJECT_DOWNSTREAM_USER=${4}
            local PROJECT_NAME=${5}
            if [ -e "${SRC_ROOT}/${GIT_PROVIDER}/${PROJECT_DOWNSTREAM_USER}_${PROJECT_UPSTREAM_USER}/${PROJECT_NAME}" ]; then
                local PROJECT_DIR="${SRC_ROOT}/${GIT_PROVIDER}/${PROJECT_DOWNSTREAM_USER}_${PROJECT_UPSTREAM_USER}/${PROJECT_NAME}"
            elif [ -e "${SRC_ROOT}/${GIT_PROVIDER}/${PROJECT_DOWNSTREAM_USER}_${PROJECT_UPSTREAM_USER}/${PROJECT_NAME}-1" ]; then
                local PROJECT_DIR="${SRC_ROOT}/${GIT_PROVIDER}/${PROJECT_DOWNSTREAM_USER}_${PROJECT_UPSTREAM_USER}/${PROJECT_NAME}-1"
            elif [ -e "${SRC_ROOT}/${GIT_PROVIDER}/${PROJECT_DOWNSTREAM_USER}/${PROJECT_NAME}" ]; then
                local PROJECT_DIR="${SRC_ROOT}/${GIT_PROVIDER}/${PROJECT_DOWNSTREAM_USER}/${PROJECT_NAME}"
            else
                local PROJECT_DIR="${SRC_ROOT}/${GIT_PROVIDER}/${PROJECT_DOWNSTREAM_USER}/${PROJECT_NAME}-1"
            fi
            local DOWNSTREAM=${6}
            local TAG=${7}
        fi

        cd "${PROJECT_DIR}" || exit 1
        # ls -alh "${PROJECT_DIR}"

        # git push ${DOWNSTREAM} ":refs/tags/${TAG}"
        git push --delete ${DOWNSTREAM} "${TAG}"
        # git ls-remote --tags
        git tag --delete "${TAG}"
        # git tag -l
    fi
}

function git_format_patch() {
    if [ "$#" != "5" ]; then
        log_e "Usage: ${FUNCNAME[0]} <SRC_ROOT> <GIT_PROVIDER : bitbucket.com | github.com | gitlab.com> <PROJECT_UPSTREAM_USER> [<PROJECT_DOWNSTREAM_USER>] <PROJECT_NAME> <HASH: HEAD | mster>"
        log_e "${FUNCNAME[0]} $# ${*}"
    else
        log_m "${FUNCNAME[0]} $# ${*}"
        # cd "${TOP_DIR:?}" || exit 1

        if [ "$#" == "5" ]; then
            local SRC_ROOT=${1}
            local GIT_PROVIDER=${2}
            local PROJECT_UPSTREAM_USER=${3}
            local PROJECT_DOWNSTREAM_USER=${4}
            local PROJECT_NAME=${5}
            if [ -e "${SRC_ROOT}/${GIT_PROVIDER}/${PROJECT_DOWNSTREAM_USER}_${PROJECT_UPSTREAM_USER}/${PROJECT_NAME}" ]; then
                local PROJECT_DIR="${SRC_ROOT}/${GIT_PROVIDER}/${PROJECT_DOWNSTREAM_USER}_${PROJECT_UPSTREAM_USER}/${PROJECT_NAME}"
            elif [ -e "${SRC_ROOT}/${GIT_PROVIDER}/${PROJECT_DOWNSTREAM_USER}_${PROJECT_UPSTREAM_USER}/${PROJECT_NAME}-1" ]; then
                local PROJECT_DIR="${SRC_ROOT}/${GIT_PROVIDER}/${PROJECT_DOWNSTREAM_USER}_${PROJECT_UPSTREAM_USER}/${PROJECT_NAME}-1"
            elif [ -e "${SRC_ROOT}/${GIT_PROVIDER}/${PROJECT_DOWNSTREAM_USER}/${PROJECT_NAME}" ]; then
                local PROJECT_DIR="${SRC_ROOT}/${GIT_PROVIDER}/${PROJECT_DOWNSTREAM_USER}/${PROJECT_NAME}"
            else
                local PROJECT_DIR="${SRC_ROOT}/${GIT_PROVIDER}/${PROJECT_DOWNSTREAM_USER}/${PROJECT_NAME}-1"
            fi
            # local WORKING_BRANCH=${2}
            local HASH=HEAD # ${3} | HEAD | Master
        fi

        cd "${PROJECT_DIR}" || exit 1
        # ls -alh "${PROJECT_DIR}"

        # git checkout ${WORKING_BRANCH}
        git format-patch -l ${HASH}
    fi
}

function git_reset_to_upstream_branch() {
    if [ "$#" != "7" ]; then
        log_e "Usage: ${FUNCNAME[0]} <SRC_ROOT> <GIT_PROVIDER : bitbucket.com | github.com | gitlab.com> <PROJECT_UPSTREAM_USER> [<PROJECT_DOWNSTREAM_USER>] <PROJECT_NAME> <DOWNSTREAM> <WORKING_BRANCH>"
        log_e "${FUNCNAME[0]} $# ${*}"
    else
        log_m "${FUNCNAME[0]} $# ${*}"
        # cd "${TOP_DIR:?}" || exit 1

        if [ "$#" == "7" ]; then
            local SRC_ROOT=${1}
            local GIT_PROVIDER=${2}
            local PROJECT_UPSTREAM_USER=${3}
            local PROJECT_DOWNSTREAM_USER=${4}
            local PROJECT_NAME=${5}
            if [ -e "${SRC_ROOT}/${GIT_PROVIDER}/${PROJECT_DOWNSTREAM_USER}_${PROJECT_UPSTREAM_USER}/${PROJECT_NAME}" ]; then
                local PROJECT_DIR="${SRC_ROOT}/${GIT_PROVIDER}/${PROJECT_DOWNSTREAM_USER}_${PROJECT_UPSTREAM_USER}/${PROJECT_NAME}"
            elif [ -e "${SRC_ROOT}/${GIT_PROVIDER}/${PROJECT_DOWNSTREAM_USER}_${PROJECT_UPSTREAM_USER}/${PROJECT_NAME}-1" ]; then
                local PROJECT_DIR="${SRC_ROOT}/${GIT_PROVIDER}/${PROJECT_DOWNSTREAM_USER}_${PROJECT_UPSTREAM_USER}/${PROJECT_NAME}-1"
            elif [ -e "${SRC_ROOT}/${GIT_PROVIDER}/${PROJECT_DOWNSTREAM_USER}/${PROJECT_NAME}" ]; then
                local PROJECT_DIR="${SRC_ROOT}/${GIT_PROVIDER}/${PROJECT_DOWNSTREAM_USER}/${PROJECT_NAME}"
            else
                local PROJECT_DIR="${SRC_ROOT}/${GIT_PROVIDER}/${PROJECT_DOWNSTREAM_USER}/${PROJECT_NAME}-1"
            fi
            local DOWNSTREAM=${6}     # origin
            local WORKING_BRANCH=${7} # master | ${3}
        fi

        cd "${PROJECT_DIR}" || exit 1
        # ls -alh "${PROJECT_DIR}"

        git reset $(git rev-parse ${DOWNSTREAM}/${WORKING_BRANCH})
    fi
}

function git_reset_hard() {
    if [ "$#" != "5" ]; then
        log_e "Usage: ${FUNCNAME[0]} <SRC_ROOT> <GIT_PROVIDER : bitbucket.com | github.com | gitlab.com> <PROJECT_UPSTREAM_USER> [<PROJECT_DOWNSTREAM_USER>] <PROJECT_NAME>"
        log_e "${FUNCNAME[0]} $# ${*}"
    else
        log_m "${FUNCNAME[0]} $# ${*}"
        # cd "${TOP_DIR:?}" || exit 1

        if [ "$#" == "5" ]; then
            local SRC_ROOT=${1}
            local GIT_PROVIDER=${2}
            local PROJECT_UPSTREAM_USER=${3}
            local PROJECT_DOWNSTREAM_USER=${4}
            local PROJECT_NAME=${5}
            if [ -e "${SRC_ROOT}/${GIT_PROVIDER}/${PROJECT_DOWNSTREAM_USER}_${PROJECT_UPSTREAM_USER}/${PROJECT_NAME}" ]; then
                local PROJECT_DIR="${SRC_ROOT}/${GIT_PROVIDER}/${PROJECT_DOWNSTREAM_USER}_${PROJECT_UPSTREAM_USER}/${PROJECT_NAME}"
            elif [ -e "${SRC_ROOT}/${GIT_PROVIDER}/${PROJECT_DOWNSTREAM_USER}_${PROJECT_UPSTREAM_USER}/${PROJECT_NAME}-1" ]; then
                local PROJECT_DIR="${SRC_ROOT}/${GIT_PROVIDER}/${PROJECT_DOWNSTREAM_USER}_${PROJECT_UPSTREAM_USER}/${PROJECT_NAME}-1"
            elif [ -e "${SRC_ROOT}/${GIT_PROVIDER}/${PROJECT_DOWNSTREAM_USER}/${PROJECT_NAME}" ]; then
                local PROJECT_DIR="${SRC_ROOT}/${GIT_PROVIDER}/${PROJECT_DOWNSTREAM_USER}/${PROJECT_NAME}"
            else
                local PROJECT_DIR="${SRC_ROOT}/${GIT_PROVIDER}/${PROJECT_DOWNSTREAM_USER}/${PROJECT_NAME}-1"
            fi
        fi
        cd "${PROJECT_DIR}" || exit 1
        # ls -alh "${PROJECT_DIR}"

        git reset --hard
        git clean -fdx
    fi
}

function git_branch_delete() {
    if [ "$#" != "8" ] && [ "$#" != "9" ]; then
        log_e "Usage: ${FUNCNAME[0]} <SRC_ROOT> <GIT_PROVIDER : bitbucket.com | github.com | gitlab.com> <PROJECT_UPSTREAM_USER> [<PROJECT_DOWNSTREAM_USER>] <PROJECT_NAME> <PROJECT_MAIN_BRANCH> <DOWNSTREAM> <WORKING_BRANCH> [<TAG>]"
        log_e "${FUNCNAME[0]} $# ${*}"
    else
        log_m "${FUNCNAME[0]} $# ${*}"
        # cd "${TOP_DIR:?}" || exit 1

        if [ "$#" == "8" ]; then
            local SRC_ROOT=${1}
            local GIT_PROVIDER=${2}
            local PROJECT_UPSTREAM_USER=${3}
            local PROJECT_DOWNSTREAM_USER=${4}
            local PROJECT_NAME=${5}
            if [ -e "${SRC_ROOT}/${GIT_PROVIDER}/${PROJECT_DOWNSTREAM_USER}_${PROJECT_UPSTREAM_USER}/${PROJECT_NAME}" ]; then
                local PROJECT_DIR="${SRC_ROOT}/${GIT_PROVIDER}/${PROJECT_DOWNSTREAM_USER}_${PROJECT_UPSTREAM_USER}/${PROJECT_NAME}"
            elif [ -e "${SRC_ROOT}/${GIT_PROVIDER}/${PROJECT_DOWNSTREAM_USER}_${PROJECT_UPSTREAM_USER}/${PROJECT_NAME}-1" ]; then
                local PROJECT_DIR="${SRC_ROOT}/${GIT_PROVIDER}/${PROJECT_DOWNSTREAM_USER}_${PROJECT_UPSTREAM_USER}/${PROJECT_NAME}-1"
            elif [ -e "${SRC_ROOT}/${GIT_PROVIDER}/${PROJECT_DOWNSTREAM_USER}/${PROJECT_NAME}" ]; then
                local PROJECT_DIR="${SRC_ROOT}/${GIT_PROVIDER}/${PROJECT_DOWNSTREAM_USER}/${PROJECT_NAME}"
            else
                local PROJECT_DIR="${SRC_ROOT}/${GIT_PROVIDER}/${PROJECT_DOWNSTREAM_USER}/${PROJECT_NAME}-1"
            fi
            local PROJECT_MAIN_BRANCH=${6} # master | main | develop
            local DOWNSTREAM=${7}          # orgin
            local WORKING_BRANCH=${8}
        elif [ "$#" == "9" ]; then
            local SRC_ROOT=${1}
            local GIT_PROVIDER=${2}
            local PROJECT_UPSTREAM_USER=${3}
            local PROJECT_DOWNSTREAM_USER=${4}
            local PROJECT_NAME=${5}
            if [ -e "${SRC_ROOT}/${GIT_PROVIDER}/${PROJECT_DOWNSTREAM_USER}_${PROJECT_UPSTREAM_USER}/${PROJECT_NAME}" ]; then
                local PROJECT_DIR="${SRC_ROOT}/${GIT_PROVIDER}/${PROJECT_DOWNSTREAM_USER}_${PROJECT_UPSTREAM_USER}/${PROJECT_NAME}"
            elif [ -e "${SRC_ROOT}/${GIT_PROVIDER}/${PROJECT_DOWNSTREAM_USER}_${PROJECT_UPSTREAM_USER}/${PROJECT_NAME}-1" ]; then
                local PROJECT_DIR="${SRC_ROOT}/${GIT_PROVIDER}/${PROJECT_DOWNSTREAM_USER}_${PROJECT_UPSTREAM_USER}/${PROJECT_NAME}-1"
            elif [ -e "${SRC_ROOT}/${GIT_PROVIDER}/${PROJECT_DOWNSTREAM_USER}/${PROJECT_NAME}" ]; then
                local PROJECT_DIR="${SRC_ROOT}/${GIT_PROVIDER}/${PROJECT_DOWNSTREAM_USER}/${PROJECT_NAME}"
            else
                local PROJECT_DIR="${SRC_ROOT}/${GIT_PROVIDER}/${PROJECT_DOWNSTREAM_USER}/${PROJECT_NAME}-1"
            fi
            local PROJECT_MAIN_BRANCH=${6} # master | main | develop
            local DOWNSTREAM=${7}          # orgin
            local WORKING_BRANCH=${8}
            local TAG=${9}
        fi

        cd "${PROJECT_DIR}" || exit 1
        # ls -alh "${PROJECT_DIR}"

        if [ "$#" == "8" ]; then
            git checkout ${PROJECT_MAIN_BRANCH}
            git push ${DOWNSTREAM} --delete ${WORKING_BRANCH}
            git branch -D ${WORKING_BRANCH}
            git fetch --prune
            git pull --all
            git branch -avv
        elif [ "$#" == "9" ]; then
            git checkout ${PROJECT_MAIN_BRANCH}
            git branch -D ${TAG}
            git branch -avv
        fi
    fi
}

#******************************************************************************
# golang

function cmd_golang_reinit_project() {
    if [ "$#" != "0" ] && [ "$#" != "2" ]; then
        log_e "Usage: ${FUNCNAME[0]} <SRC_DIR> <DIRS_FILES>"
    else
        log_m "${FUNCNAME[0]}" # ${*}

        if [ "$#" == "2" ]; then
            local SRC_DIR="${1}"
            local DIRS_FILES="${2}"
        else
            local SRC_DIR="${HOME}/Documents/myProject"
            local DIRS_FILES="bin go.mod go.sum vendor"
        fi
        find ${SRC_DIR} -name go.mod -exec bash -c 'echo -e "\n>>> {}...\n"; cd $(dirname {}); cd $(dirname {}); rm -rf bin go.mod go.sum vendor; go mod init github.com/cclhsu/$(echo $(basename $(dirname {}))); ls' {} \;
    fi
}

function cmd_golang_tidy_project() {
    if [ "$#" != "0" ] && [ "$#" != "1" ]; then
        log_e "Usage: ${FUNCNAME[0]} <SRC_DIRS> <DIRS_FILES>"
    else
        log_m "${FUNCNAME[0]}" # ${*}

        if [ "$#" == "2" ]; then
            local SRC_DIR="${1}"
            local DIRS_FILES="${2}"
        else
            local SRC_DIR="${HOME}/Documents/myProject"
            local DIRS_FILES="bin go.sum vendor"
        fi
        find ${SRC_DIR} -name go.mod -exec bash -c 'echo -e "\n>>> {}...\n"; cd $(dirname {}); go mod tidy; go mod vendor; go mod verify; go generate ./...; rm -rf bin go.sum vendor' {} \;
    fi
}

#******************************************************************************
# python3
# https://www.pypa.io/en/latest/
# https://pypi.org/project/virtualenv/
# https://pypi.org/project/virtualenvwrapper/
# https://github.com/pyenv/pyenv#installation

function install_setuptools() {
    if [ "$#" != "0" ]; then
        log_e "Usage: ${FUNCNAME[0]} <ARGS>"
        log_e "${FUNCNAME[0]} $# ${*}"
    else
        log_m "${FUNCNAME[0]} $# ${*}"
        # cd "${TOP_DIR:?}" || exit 1

        # if [ ! -e "/usr/lib/python2.7/site-packages/setuptools" ] && [ ! -e "/System/Library/Frameworks/Python.framework/Versions/2.7/Extras/lib/python/setuptools" ]; then
        #     curl https://bootstrap.pypa.io/ez_setup.py -o - | sudo python
        # fi

        # if [ ! -e "/usr/lib/python3.6/site-packages/setuptools" ] && [ ! -e "/System/Library/Frameworks/Python.framework/Versions/3.6/Extras/lib/python/setuptools" ]; then
        #     curl https://bootstrap.pypa.io/ez_setup.py -o - | sudo python3
        # fi

        if [ ! -e "/usr/bin/easy_install" ]; then
            curl https://bootstrap.pypa.io/ez_setup.py -o - | sudo python3
        fi
        which easy_install
        easy_install --version
    fi
}

function install_pip() {
    if [ "$#" != "0" ]; then
        log_e "Usage: ${FUNCNAME[0]} <ARGS>"
        log_e "${FUNCNAME[0]} $# ${*}"
    else
        log_m "${FUNCNAME[0]} $# ${*}"
        # cd "${TOP_DIR:?}" || exit 1

        # if [ ! -e "/usr/bin/pip" ] && [ ! -e "/usr/local/bin/pip" ]; then
        #     curl https://bootstrap.pypa.io/get-pip.py -o - | sudo python
        # else
        #     # sudo easy_install pip
        #     sudo pip install --upgrade pip
        # fi

        if [ ! -e "/usr/bin/pip3" ] && [ ! -e "/usr/local/bin/pip3" ]; then
            curl https://bootstrap.pypa.io/get-pip.py -o - | sudo python3
        else
            # sudo easy_install pip3
            sudo pip3 install --upgrade pip3
        fi
        which pip
    fi
}

# https://github.com/pyenv/pyenv-installer
function install_virtualenv() {
    if [ "$#" != "0" ]; then
        log_e "Usage: ${FUNCNAME[0]} <ARGS>"
        log_e "${FUNCNAME[0]} $# ${*}"
    else
        log_m "${FUNCNAME[0]} $# ${*}"
        # cd "${TOP_DIR:?}" || exit 1

        # https://urllib3.readthedocs.org/en/latest/security.html#insecureplatformwarning
        #sudo pip3 install pyopenssl ndg-httpsclient pyasn1

        sudo pip3 install cython virtualenv virtualenvwrapper
        # sudo pip3 install --upgrade pip3 setuptools pipenv pytest pytest-cov
    fi
}

function install_pyenv() {
    if [ "$#" != "0" ]; then
        log_e "Usage: ${FUNCNAME[0]} <ARGS>"
        log_e "${FUNCNAME[0]} $# ${*}"
    else
        log_m "${FUNCNAME[0]} $# ${*}"
        # cd "${TOP_DIR:?}" || exit 1

        curl -L https://github.com/pyenv/pyenv-installer/raw/master/bin/pyenv-installer | bash
        pyenv update
        git clone https://github.com/pyenv/pyenv-virtualenvwrapper.git $(pyenv root)/plugins/pyenv-virtualenvwrapper
        # rm -r ${HOME}/.pyenv
    fi
}

function pip_export_requirements() {
    if [ "$#" != "1" ]; then
        log_e "Usage: ${FUNCNAME[0]} <PATH>"
        log_e "${FUNCNAME[0]} $# ${*}"
    else
        log_m "${FUNCNAME[0]} $# ${*}"
        # cd "${TOP_DIR:?}" || exit 1

        sudo pip3 freeze >"${1}"
        # sudo pip3 freeze > "${1}/requirements.txt"
        # sudo pip3 freeze -r devel-req.txt > stable-req.txt
    fi
}

function pip_install_from_requirements() {
    if [ "$#" != "1" ]; then
        log_e "Usage: ${FUNCNAME[0]} <PATH>"
        log_e "${FUNCNAME[0]} $# ${*}"
    else
        log_m "${FUNCNAME[0]} $# ${*}"
        # cd "${TOP_DIR:?}" || exit 1

        sudo pip3 install -r "${1}"
        # sudo pip3 install -r "${1}/requirements.txt"
    fi
}

function pip_uninstall_from_requirements() {
    if [ "$#" != "1" ]; then
        log_e "Usage: ${FUNCNAME[0]} <PATH>"
        log_e "${FUNCNAME[0]} $# ${*}"
    else
        log_m "${FUNCNAME[0]} $# ${*}"
        # cd "${TOP_DIR:?}" || exit 1

        sudo pip3 uninstall -y -r "${1}"
        # sudo pip3 uninstall -y -r "${1}/requirements.txt"
    fi
}

function pip_upgrade_all() {
    if [ "$#" != "0" ]; then
        log_e "Usage: ${FUNCNAME[0]} <ARGS>"
        log_e "${FUNCNAME[0]} $# ${*}"
    else
        log_m "${FUNCNAME[0]} $# ${*}"
        # cd "${TOP_DIR:?}" || exit 1

        sudo pip3 freeze --local | grep -v '^\-e' | cut -d = -f 1 | xargs -n1 sudo pip3 install -U
    fi
}

function python_git_install() {
    if [ "$#" != "2" ]; then
        log_e "Usage: ${FUNCNAME[0]} <PATH> <URL>"
        log_e "${FUNCNAME[0]} $# ${*}"
    else
        log_m "${FUNCNAME[0]} $# ${*}"
        # cd "${TOP_DIR:?}" || exit 1

        cd "${1}" || exit 1
        git clone ${2}
        python3 setup.py install
    fi
}

function python_curl_install() {
    if [ "$#" != "2" ]; then
        log_e "Usage: ${FUNCNAME[0]} <PATH> <URL>"
        log_e "${FUNCNAME[0]} $# ${*}"
    else
        log_m "${FUNCNAME[0]} $# ${*}"
        # cd "${TOP_DIR:?}" || exit 1

        cd "${1}" || exit 1
        curl -OL ${2}
        python3 setup.py install
    fi
}

function python_print_version() {
    if [ "$#" != "1" ]; then
        log_e "Usage: ${FUNCNAME[0]} <PATH>"
        log_e "${FUNCNAME[0]} $# ${*}"
    else
        log_m "${FUNCNAME[0]} $# ${*}"
        # cd "${TOP_DIR:?}" || exit 1

        #python3 -c "import ${1}; print ${1}.__version__"
        sudo pip3 show "${1}"
    fi
}

function python_run_idle() {
    if [ "$#" != "0" ]; then
        log_e "Usage: ${FUNCNAME[0]} <ARGS>"
        log_e "${FUNCNAME[0]} $# ${*}"
    else
        log_m "${FUNCNAME[0]} $# ${*}"
        # cd "${TOP_DIR:?}" || exit 1

        python3 -m idlelib.idle
    fi
}

function python_show_system_module_keys() {
    if [ "$#" != "0" ]; then
        log_e "Usage: ${FUNCNAME[0]} <ARGS>"
        log_e "${FUNCNAME[0]} $# ${*}"
    else
        log_m "${FUNCNAME[0]} $# ${*}"
        # cd "${TOP_DIR:?}" || exit 1

        python3 -c "import sys; print('\n'.join(sorted(sys.modules.keys())));"
    fi
}

function python_show_system_path() {
    if [ "$#" != "0" ]; then
        log_e "Usage: ${FUNCNAME[0]} <ARGS>"
        log_e "${FUNCNAME[0]} $# ${*}"
    else
        log_m "${FUNCNAME[0]} $# ${*}"
        # cd "${TOP_DIR:?}" || exit 1

        python3 -c "import sys; print('\n'.join(sorted(sys.path)));"
    fi
}

#******************************************************************************
# python3 - virtualenv virtualenvwrapper
# PYTHON_VIRTUALENV_PATH="${HOME}/.virtualenvs"
# USE_SITE_PACKAGES=yes # yes | no
# PYTHON_VERSION= # python2.7 | python3.6 | python3.9
# VIRTUALENV_PROJECT_NAME=

function python_virtualenv_set() {
    if [ "$#" != "0" ] && [ "$#" != "2" ]; then
        log_e "Usage: ${FUNCNAME[0]} <PYTHON_VIRTUALENV_PATH> <VIRTUALENV_PROJECT_NAME>"
        log_e "${FUNCNAME[0]} $# ${*}"
    else
        log_m "${FUNCNAME[0]} $# ${*}"
        # cd "${TOP_DIR:?}" || exit 1

        if [ "$#" == "2" ]; then
            local PYTHON_VIRTUALENV_PATH=${1}
            local VIRTUALENV_PROJECT_NAME=${2}
        fi

        if [ ! -e "${PYTHON_VIRTUALENV_PATH}" ]; then
            mkdir -p "${PYTHON_VIRTUALENV_PATH}"
        fi
        _OLD_PATH="$PATH"
        export PATH="${PYTHON_VIRTUALENV_PATH}/${VIRTUALENV_PROJECT_NAME}/bin:$PATH"
        #export PATH="/usr/local/bin:/usr/local/share/python:$PATH"
    fi
}

function python_virtualenv_list() {
    if [ "$#" != "0" ] && [ "$#" != "1" ]; then
        log_e "Usage: ${FUNCNAME[0]} <PYTHON_VIRTUALENV_PATH>"
        log_e "${FUNCNAME[0]} $# ${*}"
    else
        log_m "${FUNCNAME[0]} $# ${*}"
        # cd "${TOP_DIR:?}" || exit 1

        if [ "$#" == "1" ]; then
            local PYTHON_VIRTUALENV_PATH=${1}
        fi

        log_m "List Virtual Env"
        ls "${PYTHON_VIRTUALENV_PATH}"
    fi
}

function python_virtualenv_create() {
    if [ "$#" != "0" ] && [ "$#" != "4" ]; then
        log_e "Usage: ${FUNCNAME[0]} <PYTHON_VIRTUALENV_PATH> <VIRTUALENV_PROJECT_NAME> <PYTHON_VERSION> <USE_SITE_PACKAGES>"
        log_e "${FUNCNAME[0]} $# ${*}"
    else
        log_m "${FUNCNAME[0]} $# ${*}"
        # cd "${TOP_DIR:?}" || exit 1

        if [ "$#" == "2" ]; then
            local PYTHON_VIRTUALENV_PATH=${1}
            local VIRTUALENV_PROJECT_NAME=${2}
            local PYTHON_VERSION=${3}
            local USE_SITE_PACKAGES=${4}
        fi

        cd "${PYTHON_VIRTUALENV_PATH}"

        if [ "${USE_SITE_PACKAGES}" == "no" ]; then
            # create completely separated environment
            # virtualenv "${VIRTUALENV_PROJECT_NAME}" --no-site-packages --python=${PYTHON_VERSION} --clear
            virtualenv "${VIRTUALENV_PROJECT_NAME}" --python=${PYTHON_VERSION} --clear
        else
            # create a virtualenv to include system-level packages
            virtualenv "${VIRTUALENV_PROJECT_NAME}" --system-site-packages --python=${PYTHON_VERSION} --clear
        fi
    fi
}

function python_virtualenv_delete() {
    if [ "$#" != "0" ] && [ "$#" != "2" ]; then
        log_e "Usage: ${FUNCNAME[0]} <PYTHON_VIRTUALENV_PATH> <VIRTUALENV_PROJECT_NAME>"
        log_e "${FUNCNAME[0]} $# ${*}"
    else
        log_m "${FUNCNAME[0]} $# ${*}"
        # cd "${TOP_DIR:?}" || exit 1

        if [ "$#" == "2" ]; then
            local PYTHON_VIRTUALENV_PATH=${1}
            local VIRTUALENV_PROJECT_NAME=${2}
        fi

        rm -rf "${PYTHON_VIRTUALENV_PATH}/${VIRTUALENV_PROJECT_NAME}"

        #ls -alh /usr/bin/py*
        ls -alh /usr/local/bin/
        #ls -alh /System/Library/Frameworks/Python.framework/Versions/Current/bin/
        #ls -alh /System/Library/Frameworks/Python.framework/Versions
    fi
}

#http://nipy.org/devel/tools/virtualenv-tutor.html
function python_virtualenv_activate() {
    if [ "$#" != "0" ] && [ "$#" != "2" ]; then
        log_e "Usage: ${FUNCNAME[0]} <PYTHON_VIRTUALENV_PATH> <VIRTUALENV_PROJECT_NAME>"
        log_e "${FUNCNAME[0]} $# ${*}"
    else
        log_m "${FUNCNAME[0]} $# ${*}"
        # cd "${TOP_DIR:?}" || exit 1

        if [ "$#" == "2" ]; then
            local PYTHON_VIRTUALENV_PATH=${1}
            local VIRTUALENV_PROJECT_NAME=${2}
        fi

        cd "${PYTHON_VIRTUALENV_PATH}/${VIRTUALENV_PROJECT_NAME}"
        source ${PYTHON_VIRTUALENV_PATH}/${VIRTUALENV_PROJECT_NAME}/bin/activate
        which python
        python -c "import sys,pprint; pprint.pprint(sys.path)"
    fi
}

function python_virtualenv_deactivate() {
    if [ "$#" != "0" ] && [ "$#" != "2" ]; then
        log_e "Usage: ${FUNCNAME[0]} <PYTHON_VIRTUALENV_PATH> <VIRTUALENV_PROJECT_NAME>"
        log_e "${FUNCNAME[0]} $# ${*}"
    else
        log_m "${FUNCNAME[0]} $# ${*}"
        # cd "${TOP_DIR:?}" || exit 1

        if [ "$#" == "2" ]; then
            local PYTHON_VIRTUALENV_PATH=${1}
            local VIRTUALENV_PROJECT_NAME=${2}
        fi

        cd "${PYTHON_VIRTUALENV_PATH}/${VIRTUALENV_PROJECT_NAME}"
        deactivate
    fi
}

function python_virtualenv_export_requirement() {
    if [ "$#" != "0" ] && [ "$#" != "2" ]; then
        log_e "Usage: ${FUNCNAME[0]} <PYTHON_VIRTUALENV_PATH> <VIRTUALENV_PROJECT_NAME>"
        log_e "${FUNCNAME[0]} $# ${*}"
    else
        log_m "${FUNCNAME[0]} $# ${*}"
        # cd "${TOP_DIR:?}" || exit 1

        if [ "$#" == "2" ]; then
            local PYTHON_VIRTUALENV_PATH=${1}
            local VIRTUALENV_PROJECT_NAME=${2}
        fi

        pip3 freeze >"${PYTHON_VIRTUALENV_PATH}/${VIRTUALENV_PROJECT_NAME}/requirements.txt"
    fi
}

function python_virtualenv_export_requirement() {
    if [ "$#" != "0" ] && [ "$#" != "2" ]; then
        log_e "Usage: ${FUNCNAME[0]} <PYTHON_VIRTUALENV_PATH> <VIRTUALENV_PROJECT_NAME>"
        log_e "${FUNCNAME[0]} $# ${*}"
    else
        log_m "${FUNCNAME[0]} $# ${*}"
        # cd "${TOP_DIR:?}" || exit 1

        if [ "$#" == "2" ]; then
            local PYTHON_VIRTUALENV_PATH=${1}
            local VIRTUALENV_PROJECT_NAME=${2}
        fi

        pip3 install -r "${PYTHON_VIRTUALENV_PATH}/${VIRTUALENV_PROJECT_NAME}/requirements.txt"
    fi
}

function python_virtualenv_delete_all() {
    if [ "$#" != "0" ] && [ "$#" != "1" ]; then
        log_e "Usage: ${FUNCNAME[0]} <PYTHON_VIRTUALENV_PATH>"
        log_e "${FUNCNAME[0]} $# ${*}"
    else
        log_m "${FUNCNAME[0]} $# ${*}"
        # cd "${TOP_DIR:?}" || exit 1

        sudo rm -rf "${PYTHON_VIRTUALENV_PATH}"

        if [ "$#" == "1" ]; then
            local PYTHON_VIRTUALENV_PATH=${1}
        fi

        #ls -alh /usr/bin/py*
        ls -alh /usr/local/bin/
        #ls -alh /System/Library/Frameworks/Python.framework/Versions/Current/bin/
        #ls -alh /System/Library/Frameworks/Python.framework/Versions

        rm -rf ~/.ipython
        rm -rf ~/.matplotlib
        rm -rf ~/.pip
        rm -rf ~/.cookiecutters
    fi
}

#******************************************************************************
# python3 - pyenv pyenv-virtualenvwrapper

#******************************************************************************
# ISO & IMAGE

function download_netboot_bin() {
    if [ "$#" != "0" ] && [ "$#" != "5" ]; then
        log_e "Usage: ${FUNCNAME[0]} <ISO_IMAGE_PATH> <INITRD_URL> <VMLINUZ_URL> <SQUASHFS_URL> <KERNEL_URL>"
        log_e "${FUNCNAME[0]} $# ${*}"
    else
        # log_m "${FUNCNAME[0]} $# ${*}"
        # cd "${TOP_DIR:?}" || exit 1

        if [ "$#" == "5" ]; then
            local ISO_IMAGE_PATH=${1}
            local INITRD_URL=${2}
            local VMLINUZ_URL=${3}
            local SQUASHFS_URL=${4}
            local KERNEL_URL=${5}
        fi

        mkdir -p "${ISO_IMAGE_PATH}"
        if [ "${INITRD_URL}" != "" ]; then
            if [ "${INITRD}" == "" ]; then
                local INITRD=$(basename "${INITRD_URL}")
            fi
            curl -SLk "${INITRD_URL}" -o "${ISO_IMAGE_PATH}/${INITRD}"
        fi
        if [ "${VMLINUZ_URL}" != "" ]; then
            if [ "${VMLINUZ}" == "" ]; then
                local VMLINUZ=$(basename "${VMLINUZ_URL}")
            fi
            curl -SLk "${VMLINUZ_URL}" -o "${ISO_IMAGE_PATH}/${VMLINUZ}"
        fi
        if [ "${SQUASHFS_URL}" != "" ]; then
            if [ "${SQUASHFS}" == "" ]; then
                local SQUASHFS=$(basename "${SQUASHFS_URL}")
            fi
            curl -SLk "${SQUASHFS_URL}" -o "${ISO_IMAGE_PATH}/${SQUASHFS}"
        fi
        if [ "${KERNEL_URL}" != "" ]; then
            if [ "${KERNEL}" == "" ]; then
                local KERNEL=$(basename "${KERNEL_URL}")
            fi
            curl -SLk "${KERNEL_URL}" -o "${ISO_IMAGE_PATH}/${KERNEL}"
        fi
        ls -alh "${ISO_IMAGE_PATH}"
    fi
}

function download_iso() {
    if [ "$#" != "0" ] && [ "$#" != "2" ]; then
        log_e "Usage: ${FUNCNAME[0]} <ISO_IMAGE_PATH> <ISO_URL>"
        log_e "${FUNCNAME[0]} $# ${*}"
    else
        # log_m "${FUNCNAME[0]} $# ${*}"
        # cd "${TOP_DIR:?}" || exit 1

        if [ "$#" == "2" ]; then
            local ISO_IMAGE_PATH=${1}
            local ISO_URL=${2}
        fi
        if [ "${ISO}" == "" ]; then
            local ISO=$(basename "${ISO_URL}")
        fi

        mkdir -p "${ISO_IMAGE_PATH}"
        curl -SLk "${ISO_URL}" -o "${ISO_IMAGE_PATH}/${ISO}"
        ls -alh "${ISO_IMAGE_PATH}"
    fi
}

function download_cloud_image() {
    if [ "$#" != "0" ] && [ "$#" != "2" ]; then
        log_e "Usage: ${FUNCNAME[0]} <QEMU_IMAGE_PATH> <IMAGE_URL>"
        log_e "${FUNCNAME[0]} $# ${*}"
    else
        # log_m "${FUNCNAME[0]} $# ${*}"
        # cd "${TOP_DIR:?}" || exit 1

        if [ "$#" == "2" ]; then
            local QEMU_IMAGE_PATH=${1}
            local IMAGE_URL=${2}
        fi
        if [ "${IMAGE}" == "" ]; then
            local IMAGE=$(basename "${IMAGE_URL}")
        fi

        mkdir -p "${QEMU_IMAGE_PATH}"
        curl -SLk "${IMAGE_URL}" -o "${QEMU_IMAGE_PATH}/${IMAGE}"
        if [ ${IMAGE:-4} == ".bz2" ]; then
            cd "${QEMU_IMAGE_PATH}" || exit 1
            bzip2 -d "${IMAGE}"
        elif [ ${IMAGE:-3} == ".xz" ]; then
            cd "${QEMU_IMAGE_PATH}" || exit 1
            tar Jxvf "${IMAGE}"
        fi
        ls -alh "${QEMU_IMAGE_PATH}"
    fi
}

function build_kubevirt_image() {
    if [ "$#" != "0" ] && [ "$#" != "4" ]; then
        log_e "Usage: ${FUNCNAME[0]} <QEMU_IMAGE_PATH> <IMAGE_URL> <DOCKER_USER> <PLATFORM_DISTRO>"
        log_e "${FUNCNAME[0]} $# ${*}"
    else
        # log_m "${FUNCNAME[0]} $# ${*}"
        # cd "${TOP_DIR:?}" || exit 1

        if [ "$#" == "4" ]; then
            local QEMU_IMAGE_PATH=${1}
            local IMAGE_URL=${2}
            local DOCKER_USER=${3}
            local PLATFORM_DISTRO=${4}
        fi

        mkdir -p "${QEMU_IMAGE_PATH}"
        cd "${QEMU_IMAGE_PATH}" || exit 1

        if [ -e "${QEMU_IMAGE_PATH}/$(basename ${IMAGE_URL})" ]; then
            download_cloud_image ${QEMU_IMAGE_PATH} ${IMAGE_URL}
        fi
        if [ "${IMAGE}" == "" ]; then
            local IMAGE=$(basename "${IMAGE_URL}")
        fi

        cat <<*EOF* >${QEMU_IMAGE_PATH}/Dockerfile
FROM scratch
# ADD ${IMAGE_URL} /disk/
ADD ${IMAGE} /disk/
*EOF*
        ls -alh "${QEMU_IMAGE_PATH}"

        docker build -t ${DOCKER_USER}/${PLATFORM_DISTRO}:latest .
        docker images
        # docker push ${DOCKER_USER}/${PLATFORM_DISTRO}:latest
    fi
}

function convert_iso_to_img() {
    if [ "$#" != "0" ] && [ "$#" != "3" ]; then
        log_e "Usage: ${FUNCNAME[0]} <ISO_IMAGE_PATH> <ISO_URL> <QEMU_IMAGE_PATH>"
        log_e "${FUNCNAME[0]} $# ${*}"
    else
        # log_m "${FUNCNAME[0]} $# ${*}"
        # cd "${TOP_DIR:?}" || exit 1

        if [ "$#" == "3" ]; then
            local ISO_IMAGE_PATH=${1}
            local ISO_URL=${2}
            local QEMU_IMAGE_PATH=${3}
        fi
        if [ "${ISO}" == "" ]; then
            local ISO=$(basename "${ISO_URL}")
        fi

        if [ "${ISO_IMAGE_PATH}/$(basename ${ISO_URL})" == "" ]; then
            download_iso "${ISO_IMAGE_PATH}" "${ISO_URL}"
        fi

        cd "${ISO_IMAGE_PATH}" || exit 1
        mkdir -p "${QEMU_IMAGE_PATH}"
        # dd if="${ISO_IMAGE_PATH}/${ISO%.*}.iso" of="${QEMU_IMAGE_PATH}/${ISO%.*}.img"
        # cp "${ISO_IMAGE_PATH}/${ISO%.*}.iso" "${QEMU_IMAGE_PATH}/${ISO%.*}.img"
        qemu-img convert -f raw -O qcow2 "${ISO_IMAGE_PATH}/${ISO%.*}.iso" "${QEMU_IMAGE_PATH}/${ISO%.*}.qcow2"
        ls -alh "${QEMU_IMAGE_PATH}"
    fi
}

function convert_qcow2_to_img() {
    if [ "$#" != "0" ] && [ "$#" != "2" ]; then
        log_e "Usage: ${FUNCNAME[0]} <QEMU_IMAGE_PATH> <IMAGE_URL>"
        log_e "${FUNCNAME[0]} $# ${*}"
    else
        # log_m "${FUNCNAME[0]} $# ${*}"
        # cd "${TOP_DIR:?}" || exit 1

        if [ "$#" == "2" ]; then
            local QEMU_IMAGE_PATH=${1}
            local IMAGE_URL=${2}
        fi
        if [ "${IMAGE}" == "" ]; then
            local IMAGE=$(basename "${IMAGE_URL}")
        fi

        mkdir -p "${QEMU_IMAGE_PATH}"
        cd "${QEMU_IMAGE_PATH}" || exit 1
        qemu-img convert -f qcow2 -O raw "${QEMU_IMAGE_PATH}/${IMAGE%.*}.qcow2" "${QEMU_IMAGE_PATH}/${IMAGE%.*}.img"
        ls -alh "${QEMU_IMAGE_PATH}"
    fi
}

function get_input_extension_by_format() {
    if [ "$#" != "0" ]; then
        log_e "Usage: ${FUNCNAME[0]} <IN_EXTENSION> <IN_FORMAT> <OUT_EXTENSION> <OUT_FORMAT>"
        log_e "${FUNCNAME[0]} $# ${*}"
    else
        # log_m "${FUNCNAME[0]} $# ${*}"
        # cd "${TOP_DIR:?}" || exit 1

        case ${IN_FORMAT} in
            raw)
                IN_EXTENSION=""
                ;;
            qcow2)
                IN_EXTENSION="qcow2"
                ;;
            vdi)
                IN_EXTENSION="vdi"
                ;;
            vmdk)
                IN_EXTENSION="vmdk"
                ;;
            vhd)
                IN_EXTENSION="vpc"
                ;;
            *)
                usage
                exit 1
                ;;
        esac
    fi
    return ${IN_EXTENSION}
}

function get_output_extension_by_format() {
    if [ "$#" != "1" ]; then
        log_e "Usage: ${FUNCNAME[0]} <OUT_FORMAT>"
        log_e "${FUNCNAME[0]} $# ${*}"
    else
        # log_m "${FUNCNAME[0]} $# ${*}"
        # cd "${TOP_DIR:?}" || exit 1

        case ${OUT_FORMAT} in
            raw)
                OUT_EXTENSION="img"
                ;;
            qcow2)
                OUT_EXTENSION="qcow2"
                ;;
            vdi)
                OUT_EXTENSION="vdi"
                ;;
            vmdk)
                OUT_EXTENSION="vmdk"
                ;;
            vhd)
                OUT_EXTENSION="vpc"
                ;;
            *)
                usage
                exit 1
                ;;
        esac
    fi
    return ${OUT_EXTENSION}
}

# # FORMAT    EXTENSION
# # raw       img
# # qcow2     qcow2
# # vdi       vdi
# # vmdk      vmdk
# # vhd       vpc
# function convert_virtual_machine_image_format() {
#     if [ "$#" != "0" ] && [ "$#" != "7" ]; then
#         log_e "Usage: ${FUNCNAME[0]} <QEMU_IMAGE_PATH> <IN_VIRTUAL_MACHINE> <IN_EXTENSION> <IN_FORMAT> <OUT_VIRTUAL_MACHINE> <OUT_EXTENSION> <OUT_FORMAT>"
#     else
#         # log_m "${FUNCNAME[0]} $# ${*}"
#         # cd "${TOP_DIR:?}" || exit 1

#         if [ "$#" == "7" ]; then
#             local QEMU_IMAGE_PATH=${1}
#             local IN_VIRTUAL_MACHINE=${2}
#             local IN_EXTENSION=${2}
#             local IN_FORMAT=${2}
#             local OUT_VIRTUAL_MACHINE=${2}
#             local OUT_EXTENSION=${2}
#             local OUT_FORMAT=${2}
#         fi

#         if [ -e "${VM_IMAGE_PATH}/${IN_VIRTUAL_MACHINE}.${IN_EXTENSION}" ]; then
#             qemu-img info "${VM_IMAGE_PATH}/${IN_VIRTUAL_MACHINE}.${IN_EXTENSION}"

#             qemu-img convert \
#                 -f "${IN_FORMAT}" \
#                 "${VM_IMAGE_PATH}/${IN_VIRTUAL_MACHINE}.${IN_EXTENSION}" \
#                 -O "${OUT_FORMAT}" \
#                 "${VM_IMAGE_PATH}/${OUT_VIRTUAL_MACHINE}.${OUT_EXTENSION}"

#             qemu-img info "${VM_IMAGE_PATH}/${OUT_VIRTUAL_MACHINE}.${OUT_EXTENSION}"
#             ls -alh "${VM_IMAGE_PATH}"
#         fi
#     fi
# }

#******************************************************************************

function mount_iso() {
    if [ "$#" != "0" ] && [ "$#" != "2" ]; then
        log_e "Usage: ${FUNCNAME[0]} <ISO_IMAGE_PATH> <ISO_URL>"
        log_e "${FUNCNAME[0]} $# ${*}"
    else
        log_m "${FUNCNAME[0]} $# ${*}"
        # cd "${TOP_DIR:?}" || exit 1

        if [ "$#" == "2" ]; then
            local ISO_IMAGE_PATH=${1}
            local ISO_URL=${2}
        fi
        if [ "${ISO}" == "" ]; then
            local ISO=$(basename "${ISO_URL}")
            local MOUNT_NAME="${ISO%.*}"
        fi
        sudo mkdir -p /mnt/${MOUNT_NAME}
        # sudo mount -o ro,loop -t iso9660 ${ISO_IMAGE_PATH}/${ISO} /mnt/${MOUNT_NAME}
        sudo mount -o loop ${ISO_IMAGE_PATH}/${ISO} /mnt/${MOUNT_NAME}
        ls -al /mnt/${MOUNT_NAME}
    fi
}

function unmount_iso() {
    if [ "$#" != "0" ] && [ "$#" != "2" ]; then
        log_e "Usage: ${FUNCNAME[0]} <ISO_IMAGE_PATH> <ISO_URL>"
        log_e "${FUNCNAME[0]} $# ${*}"
    else
        log_m "${FUNCNAME[0]} $# ${*}"
        # cd "${TOP_DIR:?}" || exit 1

        if [ "$#" == "2" ]; then
            local ISO_IMAGE_PATH=${1}
            local ISO_URL=${2}
        fi
        if [ "${ISO}" == "" ]; then
            local ISO=$(basename "${ISO_URL}")
            local MOUNT_NAME="${ISO%.*}"
        fi
        sudo umount /mnt/${MOUNT_NAME}
        sudo rm -rf /mnt/${MOUNT_NAME}
        ls /mnt
    fi
}

function mount_img() {
    if [ "$#" != "0" ] && [ "$#" != "2" ]; then
        log_e "Usage: ${FUNCNAME[0]} <QEMU_IMAGE_PATH> <IMAGE_URL>"
        log_e "${FUNCNAME[0]} $# ${*}"
    else
        log_m "${FUNCNAME[0]} $# ${*}"
        # cd "${TOP_DIR:?}" || exit 1

        if [ "$#" == "2" ]; then
            local QEMU_IMAGE_PATH=${1}
            local IMAGE_URL=${2}
        fi
        if [ "${IMAGE}" == "" ]; then
            local IMAGE=$(basename "${IMAGE_URL}")
            local MOUNT_NAME="${IMAGE%.*}"
        fi
        sudo mkdir -p /mnt/${MOUNT_NAME}
        guestmount -a ${QEMU_IMAGE_PATH}/${IMAGE} -i --ro /mnt/${MOUNT_NAME}
        ls -al /mnt/${MOUNT_NAME}
    fi
}

function unmount_img() {
    if [ "$#" != "0" ] && [ "$#" != "2" ]; then
        log_e "Usage: ${FUNCNAME[0]} <QEMU_IMAGE_PATH> <IMAGE_URL>"
        log_e "${FUNCNAME[0]} $# ${*}"
    else
        log_m "${FUNCNAME[0]} $# ${*}"
        # cd "${TOP_DIR:?}" || exit 1

        if [ "$#" == "2" ]; then
            local QEMU_IMAGE_PATH=${1}
            local IMAGE_URL=${2}
        fi
        if [ "${IMAGE}" == "" ]; then
            local IMAGE=$(basename "${IMAGE_URL}")
            local MOUNT_NAME="${IMAGE%.*}"
        fi
        guestunmount /mnt/${MOUNT_NAME}
        sudo rm -rf /mnt/${MOUNT_NAME}
        ls /mnt
    fi
}

#******************************************************************************
# libvirt

function start_libvirt_runtime() {
    if [ "$#" != "0" ]; then
        log_e "Usage: ${FUNCNAME[0]} <ARGS>"
        log_e "${FUNCNAME[0]} $# ${*}"
    else
        # log_m "${FUNCNAME[0]} $# ${*}"
        # cd "${TOP_DIR:?}" || exit 1

        if [ ! -e "/var/run/libvirt/libvirt-sock" ]; then
            echo -e "\n>>> Start Libvirtd...\n"
            systemd_start libvirtd
            sudo virsh net-define /usr/share/libvirt/networks/default.xml 2>/dev/null
            sudo virsh net-start default 2>/dev/null
            sudo virsh net-list --all
        fi
    fi
}

function stop_libvirt_runtime() {
    if [ "$#" != "0" ]; then
        log_e "Usage: ${FUNCNAME[0]} <ARGS>"
        log_e "${FUNCNAME[0]} $# ${*}"
    else
        # log_m "${FUNCNAME[0]} $# ${*}"
        # cd "${TOP_DIR:?}" || exit 1

        if [ -e "/var/run/libvirt/libvirt-sock" ]; then
            echo -e "\n>>> Stop Libvirtd...\n"
            # https://doc.opensuse.org/documentation/leap/archive/42.1/virtualization/html/book.virt/cha.libvirt.networks.html
            sudo virsh net-list --all
            NETWORK=${PLATFORM_DISTRO}-network # centos debian opensuse-leap sles ubuntu
            sudo virsh net-destroy ${NETWORK}
            sudo virsh net-undefine ${NETWORK}
            sudo virsh net-destroy default
            sudo virsh net-undefine default
            systemd_stop libvirtd
        fi
    fi
}

#******************************************************************************
# docker

function start_docker_runtime() {
    if [ "$#" != "0" ]; then
        log_e "Usage: ${FUNCNAME[0]} <ARGS>"
        log_e "${FUNCNAME[0]} $# ${*}"
    else
        # log_m "${FUNCNAME[0]} $# ${*}"
        # cd "${TOP_DIR:?}" || exit 1

        if [ ! -e "/var/run/docker/docker-sock" ]; then
            echo -e "\n>>> Start docker...\n"
            systemd_start docker
        fi
    fi
}

function stop_docker_runtime() {
    if [ "$#" != "0" ]; then
        log_e "Usage: ${FUNCNAME[0]} <ARGS>"
        log_e "${FUNCNAME[0]} $# ${*}"
    else
        # log_m "${FUNCNAME[0]} $# ${*}"
        # cd "${TOP_DIR:?}" || exit 1

        if [ -e "/var/run/docker/docker-sock" ]; then
            echo -e "\n>>> Stop docker...\n"
            systemd_stop docker
        fi
    fi
}

function docker_build() {
    if [ "$#" != "0" ] && [ "$#" != "3" ] && [ "$#" != "4" ]; then
        log_e "Usage: ${FUNCNAME[0]} [<DOCKER_USER>] <DOCKER_PROJECT> <DOCKER_TAG> <DOCKER_FILE>"
        log_e "${FUNCNAME[0]} $# ${*}"
    else
        log_m "${FUNCNAME[0]} $# ${*}"
        cd "${TOP_DIR:?}" || exit 1

        if [ "$#" == "3" ]; then
            local DOCKER_PROJECT=${1} # ${GITHUB_PROJECT}
            local DOCKER_TAG=${2}     # latest | latest-alpine | v0.0.1
            local DOCKER_FILE=${3}
        elif [ "$#" == "4" ]; then
            local DOCKER_USER=${1}    # ${GITHUB_USER}
            local DOCKER_PROJECT=${2} # ${GITHUB_PROJECT}
            local DOCKER_TAG=${3}     # latest | latest-alpine | v0.0.1
            local DOCKER_FILE=${4}
        fi

        if [ "${DOCKER_USER}" == "" ]; then
            # docker build --rm -f $(DOCKER_FILE) -t ${DOCKER_REGISTRY}/${DOCKER_PROJECT}:${DOCKER_TAG} .
            docker build --rm -f $(DOCKER_FILE) -t ${DOCKER_PROJECT}:${DOCKER_TAG} .
        else
            # docker build --rm -f $(DOCKER_FILE) -t ${DOCKER_REGISTRY}/${DOCKER_USER}/${DOCKER_PROJECT}:${DOCKER_TAG} .
            docker build --rm -f $(DOCKER_FILE) -t ${DOCKER_USER}/${DOCKER_PROJECT}:${DOCKER_TAG} .
        fi
        docker rmi $(docker images -f "dangling=true" -q) 2>/dev/null
    fi
}

function docker_build_no_cache() {
    if [ "$#" != "0" ] && [ "$#" != "3" ] && [ "$#" != "4" ]; then
        log_e "Usage: ${FUNCNAME[0]} [<DOCKER_USER>] <DOCKER_PROJECT> <DOCKER_TAG> <DOCKER_FILE>"
        log_e "${FUNCNAME[0]} $# ${*}"
    else
        log_m "${FUNCNAME[0]} $# ${*}"
        cd "${TOP_DIR:?}" || exit 1

        if [ "$#" == "3" ]; then
            local DOCKER_PROJECT=${1} # ${GITHUB_PROJECT}
            local DOCKER_TAG=${2}     # latest | latest-alpine | v0.0.1
            local DOCKER_FILE=${3}
        elif [ "$#" == "4" ]; then
            local DOCKER_USER=${1}    # ${GITHUB_USER}
            local DOCKER_PROJECT=${2} # ${GITHUB_PROJECT}
            local DOCKER_TAG=${3}     # latest | latest-alpine | v0.0.1
            local DOCKER_FILE=${4}
        fi

        if [ "${DOCKER_USER}" == "" ]; then
            # docker build --rm -f $(DOCKER_FILE) -t ${DOCKER_REGISTRY}/${DOCKER_PROJECT}:${DOCKER_TAG} --no-cache .
            docker build --rm -f $(DOCKER_FILE) -t ${DOCKER_PROJECT}:${DOCKER_TAG} --no-cache .
        else
            # docker build --rm -f $(DOCKER_FILE) -t ${DOCKER_REGISTRY}/${DOCKER_USER}/${DOCKER_PROJECT}:${DOCKER_TAG} --no-cache .
            docker build --rm -f $(DOCKER_FILE) -t ${DOCKER_USER}/${DOCKER_PROJECT}:${DOCKER_TAG} --no-cache .
        fi
        docker rmi $(docker images -f "dangling=true" -q) 2>/dev/null
    fi
}

function docker_stats() {
    if [ "$#" != "0" ]; then
        log_e "Usage: ${FUNCNAME[0]} <ARGS>"
        log_e "${FUNCNAME[0]} $# ${*}"
    else
        log_m "${FUNCNAME[0]} $# ${*}"
        cd "${TOP_DIR:?}" || exit 1

        docker stats
    fi
}

function docker_pull() {
    if [ "$#" != "0" ] && [ "$#" != "2" ] && [ "$#" != "3" ]; then
        log_e "Usage: ${FUNCNAME[0]} [<DOCKER_USER>] <DOCKER_PROJECT> <DOCKER_TAG>"
        log_e "${FUNCNAME[0]} $# ${*}"
    else
        log_m "${FUNCNAME[0]} $# ${*}"
        cd "${TOP_DIR:?}" || exit 1

        if [ "$#" == "2" ]; then
            local DOCKER_PROJECT=${1} # ${GITHUB_PROJECT}
            local DOCKER_TAG=${2}     # latest | latest-alpine | v0.0.1
        elif [ "$#" == "3" ]; then
            local DOCKER_USER=${1}    # ${GITHUB_USER}
            local DOCKER_PROJECT=${2} # ${GITHUB_PROJECT}
            local DOCKER_TAG=${3}     # latest | latest-alpine | v0.0.1
        fi

        if [ "${DOCKER_USER}" == "" ]; then
            # docker pull ${DOCKER_REGISTRY}/${DOCKER_PROJECT}:${DOCKER_TAG}
            docker pull ${DOCKER_PROJECT}:${DOCKER_TAG}
        else
            # docker pull ${DOCKER_REGISTRY}/${DOCKER_USER}/${DOCKER_PROJECT}:${DOCKER_TAG}
            docker pull ${DOCKER_USER}/${DOCKER_PROJECT}:${DOCKER_TAG}
        fi
        docker images
    fi
}

function docker_push() {
    if [ "$#" != "0" ] && [ "$#" != "2" ] && [ "$#" != "3" ]; then
        log_e "Usage: ${FUNCNAME[0]} [<DOCKER_USER>] <DOCKER_PROJECT> <DOCKER_TAG>"
        log_e "${FUNCNAME[0]} $# ${*}"
    else
        log_m "${FUNCNAME[0]} $# ${*}"
        cd "${TOP_DIR:?}" || exit 1

        if [ "$#" == "2" ]; then
            local DOCKER_PROJECT=${1} # ${GITHUB_PROJECT}
            local DOCKER_TAG=${2}     # latest | latest-alpine | v0.0.1
        elif [ "$#" == "3" ]; then
            local DOCKER_USER=${1}    # ${GITHUB_USER}
            local DOCKER_PROJECT=${2} # ${GITHUB_PROJECT}
            local DOCKER_TAG=${3}     # latest | latest-alpine | v0.0.1
        fi

        if [ "${DOCKER_USER}" == "" ]; then
            # docker push ${DOCKER_REGISTRY}/${DOCKER_PROJECT}:${DOCKER_TAG}
            docker push ${DOCKER_PROJECT}:${DOCKER_TAG}
        else
            # docker push ${DOCKER_REGISTRY}/${DOCKER_USER}/${DOCKER_PROJECT}:${DOCKER_TAG}
            docker push ${DOCKER_USER}/${DOCKER_PROJECT}:${DOCKER_TAG}
        fi
        docker images
    fi
}

function docker_remove() {
    if [ "$#" != "0" ] && [ "$#" != "2" ] && [ "$#" != "3" ]; then
        log_e "Usage: ${FUNCNAME[0]} [<DOCKER_USER>] <DOCKER_PROJECT> <DOCKER_TAG>"
        log_e "${FUNCNAME[0]} $# ${*}"
    else
        log_m "${FUNCNAME[0]} $# ${*}"
        cd "${TOP_DIR:?}" || exit 1

        if [ "$#" == "2" ]; then
            local DOCKER_PROJECT=${1} # ${GITHUB_PROJECT}
            local DOCKER_TAG=${2}     # latest | latest-alpine | v0.0.1
        elif [ "$#" == "3" ]; then
            local DOCKER_USER=${1}    # ${GITHUB_USER}
            local DOCKER_PROJECT=${2} # ${GITHUB_PROJECT}
            local DOCKER_TAG=${3}     # latest | latest-alpine | v0.0.1
        fi

        if [ "${DOCKER_USER}" == "" ]; then
            # docker rmi ${DOCKER_REGISTRY}/${DOCKER_PROJECT}:${DOCKER_TAG}
            docker rmi ${DOCKER_PROJECT}:${DOCKER_TAG}
        else
            # docker rmi ${DOCKER_REGISTRY}/${DOCKER_USER}/${DOCKER_PROJECT}:${DOCKER_TAG}
            docker rmi ${DOCKER_USER}/${DOCKER_PROJECT}:${DOCKER_TAG}
        fi
    fi
}

function docker_clean() {
    if [ "$#" != "0" ]; then
        log_e "Usage: ${FUNCNAME[0]} [<DOCKER_USER>] [<DOCKER_REGISTRY|0.0.0.0:5000>] <DOCKER_PROJECT> <DOCKER_TAG>"
        log_e "${FUNCNAME[0]} $# ${*}"
    else
        log_m "${FUNCNAME[0]} $# ${*}"
        cd "${TOP_DIR:?}" || exit 1

        docker rm -f ${DOCKER_PROJECT} 2>/dev/null
        docker rmi ${DOCKER_REGISTRY}/${DOCKER_USER}/${DOCKER_PROJECT}:${DOCKER_TAG} 2>/dev/null
        docker rmi ${DOCKER_USER}/${DOCKER_PROJECT}:${DOCKER_TAG} 2>/dev/null
        docker rmi ${DOCKER_PROJECT}:${DOCKER_TAG} 2>/dev/null
        docker rm $(docker ps -a -q) 2>/dev/null
        docker rmi $(docker images -f "dangling=true" -q) 2>/dev/null
        # docker container prune --force  2>/dev/null # --filter "until=24h"
        docker volume prune --force 2>/dev/null
        # docker image prune --all --force # --filter "until=24h"
        docker network prune --force 2>/dev/null # --filter "until=24h"
    fi
}

# https://docs.docker.com/docker-cloud/builds/push-images/
function docker_tag_and_publish() {
    if [ "$#" != "0" ] && [ "$#" != "4" ] && [ "$#" != "6" ]; then
        log_e "Usage: ${FUNCNAME[0]} <DOCKER_USER> <DOCKER_PASSWORD> [<PROTOCOL> <DOCKER_REGISTRY|0.0.0.0:5000>] <DOCKER_PROJECT> <DOCKER_TAG>"
        log_e "${FUNCNAME[0]} $# ${*}"
    else
        log_m "${FUNCNAME[0]} $# ${*}"
        cd "${TOP_DIR:?}" || exit 1

        if [ "$#" == "4" ]; then
            local DOCKER_USER=${1} # ${GITHUB_USER}
            local DOCKER_PASSWORD=${2}
            local DOCKER_PROJECT=${3} # ${GITHUB_PROJECT}
            local DOCKER_TAG=${4}     # latest | latest-alpine | v0.0.1
        elif [ "$#" == "6" ]; then
            local DOCKER_USER=${1} # ${GITHUB_USER}
            local DOCKER_PASSWORD=${2}
            local PROTOCOL=${3}        # http | https
            local DOCKER_REGISTRY=${4} # 0.0.0.0:5000
            local DOCKER_PROJECT=${5}  # ${GITHUB_PROJECT}
            local DOCKER_TAG=${6}      # latest | latest-alpine | v0.0.1
        fi

        if [ "${DOCKER_USER}" != "" ] && [ "${DOCKER_PASSWORD}" != "" ] && [ "${DOCKER_REGISTRY}" != "" ]; then
            # docker login -u ${DOCKER_USER} -p ${DOCKER_PASSWORD}
            docker tag ${DOCKER_PROJECT}:${DOCKER_TAG} ${DOCKER_REGISTRY}/${DOCKER_USER}/$(basename ${DOCKER_PROJECT}):${DOCKER_TAG}
            docker push ${DOCKER_REGISTRY}/${DOCKER_USER}/$(basename ${DOCKER_PROJECT}):${DOCKER_TAG}
            curl -X GET ${PROTOCOL}://${DOCKER_REGISTRY}/v2/_catalog | jq
            # curl -X GET -sk -u ${DOCKER_USER}:${DOCKER_PASSWORD} ${PROTOCOL}://${DOCKER_REGISTRY}/v2/_catalog | jq
            curl -X GET ${PROTOCOL}://${DOCKER_REGISTRY}/v2/${DOCKER_USER}/$(basename ${DOCKER_PROJECT})/tags/list | jq
        elif [ "${DOCKER_USER}" != "" ] && [ "${DOCKER_PASSWORD}" != "" ]; then
            docker login -u ${DOCKER_USER} -p ${DOCKER_PASSWORD}
            docker tag ${DOCKER_PROJECT}:${DOCKER_TAG} ${DOCKER_USER}/$(basename ${DOCKER_PROJECT}):${DOCKER_TAG}
            docker push ${DOCKER_USER}/$(basename ${DOCKER_PROJECT}):${DOCKER_TAG}
        fi
        docker images
        # https://hub.docker.com/?ref=login
        # https://hub.docker.com/repository/docker/${DOCKER_USER}/$(basename ${DOCKER_PROJECT})
    fi
}

function docker_untag_publish() {
    if [ "$#" != "0" ] && [ "$#" != "3" ]; then
        log_e "Usage: ${FUNCNAME[0]} <DOCKER_USER> [<DOCKER_REGISTRY>] <DOCKER_PROJECT> <DOCKER_TAG>"
        log_e "${FUNCNAME[0]} $# ${*}"
    else
        log_m "${FUNCNAME[0]} $# ${*}"
        cd "${TOP_DIR:?}" || exit 1

        if [ "$#" == "3" ]; then
            local DOCKER_USER=${1} # ${GITHUB_USER}
            # local DOCKER_REGISTRY=${2}
            local DOCKER_PROJECT=${2} # ${GITHUB_PROJECT}
            local DOCKER_TAG=${3}     # latest | latest-alpine | v0.0.1
        fi

        if [ "${DOCKER_USER}" != "" ]; then
            # docker rmi ${DOCKER_REGISTRY}/${DOCKER_USER}/$(basename ${DOCKER_PROJECT}):${DOCKER_TAG}
            docker rmi ${DOCKER_USER}/$(basename ${DOCKER_PROJECT}):${DOCKER_TAG}
        fi
        docker images
        # https://hub.docker.com/?ref=login
        # https://hub.docker.com/repository/docker/${DOCKER_USER}/$(basename ${DOCKER_PROJECT})
    fi
}

function docker_hub() {
    if [ "$#" != "0" ] && [ "$#" != "1" ]; then
        log_e "Usage: ${FUNCNAME[0]} <DOCKER_USER>"
        log_e "${FUNCNAME[0]} $# ${*}"
    else
        log_m "${FUNCNAME[0]} $# ${*}"
        cd "${TOP_DIR:?}" || exit 1

        if [ "$#" == "1" ]; then
            local DOCKER_USER=${1} # ${GITHUB_USER}
        fi

        if [ "${DOCKER_USER}" != "" ]; then
            open https://hub.docker.com/u/${DOCKER_USER}/
        fi
    fi
}

#******************************************************************************

function docker_pull_images_using_file_list_to_local() {
    if [ "$#" != "1" ] && [ "$#" != "2" ] && [ "$#" != "4" ]; then
        log_e "Usage: ${FUNCNAME[0]} <IMAGES> [<IMAGES_DIR>] [<PULL_TAG_ONLY> <GREP_PULL_TAG>]"
        log_e "${FUNCNAME[0]} $# ${*}"
    else
        log_m "${FUNCNAME[0]} $# ${*}"
        # cd "${TOP_DIR:?}" || exit 1

        if [ "$#" == "1" ]; then
            local IMAGES_LIST_FILE=${1}
        elif [ "$#" == "2" ]; then
            local IMAGES_LIST_FILE=${1}
            local IMAGES_DIR=${2}
            local PULL_TAG_ONLY=false
            local GREP_PULL_TAG=master # master | master-head
        elif [ "$#" == "4" ]; then
            local IMAGES_LIST_FILE=${1}
            local IMAGES_DIR=${2}
            local PULL_TAG_ONLY=${3}
            local GREP_PULL_TAG=${4}
        fi

        for IMAGE in $(cat ${IMAGES_LIST_FILE}); do
            if [ "${PULL_TAG_ONLY}" != true ] || ([ "${PULL_TAG_ONLY}" == true ] && [ $(echo ${IMAGE} | grep ${GREP_PULL_TAG} | wc -l) == 1 ]); then
                docker pull ${IMAGE}
            fi
        done
        docker images

        if [[ ${IMAGES_DIR} ]]; then
            for IMAGE in $(cat ${IMAGES_LIST_FILE}); do
                if [ "${PULL_TAG_ONLY}" != true ] || ([ "${PULL_TAG_ONLY}" == true ] && [ $(echo ${IMAGE} | grep ${GREP_PULL_TAG} | wc -l) == 1 ]); then
                    # docker save $(cat ${IMAGES_LIST_FILE} | tr '\n' ' ') | gzip -c >"${IMAGES_DIR}/$(basename ${IMAGE}).tar.gz"
                    # docker save $(cat ${IMAGES_LIST_FILE} | tr '\n' ' ') | zstd -c --no-progress -T0 -16 -f --long=25 >"${IMAGES_DIR}/$(basename ${IMAGE}).tar.zst"
                    # docker save $(cat ${IMAGES_LIST_FILE} | tr '\n' ' ') | xz -c >"${IMAGES_DIR}/$(basename ${IMAGE}).xz"
                    docker save ${IMAGE} --output "${IMAGES_DIR}/$(basename ${IMAGE}).tar"
                fi
            done
            ls "${IMAGES_DIR}"
        fi
    fi
}

function docker_load_images_using_file_list_to_local() {
    if [ "$#" != "2" ]; then
        log_e "Usage: ${FUNCNAME[0]} <IMAGES_LIST_FILE> <IMAGES_DIR>"
        log_e "${FUNCNAME[0]} $# ${*}"
    else
        log_m "${FUNCNAME[0]} $# ${*}"
        # cd "${TOP_DIR:?}" || exit 1

        if [ "$#" == "2" ]; then
            local IMAGES_LIST_FILE=${1}
            local IMAGES_DIR=${2}
        fi

        for IMAGE in $(cat ${IMAGES_LIST_FILE}); do
            docker load --input "${IMAGES_DIR}/$(basename ${IMAGE}).tar"
        done
        docker images
    fi
}

function docker_push_images_using_file_list_to_registry() {
    if [ "$#" != "2" ] && [ "$#" != "2" ]; then
        log_e "Usage: ${FUNCNAME[0]} <IMAGES_LIST_FILE> [<DOCKER_REGISTRY | DOCKER_REGISTRY:PORT>]"
        log_e "${FUNCNAME[0]} $# ${*}"
    else
        log_m "${FUNCNAME[0]} $# ${*}"
        # cd "${TOP_DIR:?}" || exit 1

        if [ "$#" == "1" ]; then
            local IMAGES_LIST_FILE=${1}
        elif [ "$#" == "2" ]; then
            local IMAGES_LIST_FILE=${1}
            local DOCKER_REGISTRY="${2}/"
        fi

        for IMAGE in $(cat ${IMAGES_LIST_FILE}); do
            # case ${IMAGE} in
            #     */*/*)
            #         IMAGE_NAME=${DOCKER_REGISTRY}${DOCKER_USER}${IMAGE#*/*/}
            #         ;;
            #     */*)
            #         IMAGE_NAME=${DOCKER_REGISTRY}${DOCKER_USER}${IMAGE#*/}
            #         ;;
            #     *)
            #         IMAGE_NAME=${DOCKER_REGISTRY}${DOCKER_USER}${IMAGE}
            #         ;;
            # esac
            IMAGE_NAME=${DOCKER_REGISTRY}${IMAGE}
            echo -e "\n>>> ${IMAGE} => ${IMAGE_NAME}..."
            docker tag ${IMAGE} ${IMAGE_NAME}
            docker push ${IMAGE_NAME}
            docker rmi ${IMAGE_NAME}
        done
        docker images
    fi
}

function docker_remove_images_using_file_list_from_registry() {
    if [ "$#" != "3" ]; then
        log_e "Usage: ${FUNCNAME[0]} <IMAGES_LIST_FILE> <PROTOCOL> <DOCKER_REGISTRY | DOCKER_REGISTRY:PORT>"
        log_e "${FUNCNAME[0]} $# ${*}"
    else
        log_m "${FUNCNAME[0]} $# ${*}"
        # cd "${TOP_DIR:?}" || exit 1

        if [ "$#" == "3" ]; then
            local IMAGES_LIST_FILE=${1}
            local PROTOCOL=${2} # http | https
            local DOCKER_REGISTRY=${3}
        fi

        for IMAGE in $(cat ${IMAGES_LIST_FILE}); do
            echo -e "\n>>> ${IMAGE}..."
            # case ${IMAGE} in
            #     */*)
            #         # TAG=$(curl -s -X GET ${PROTOCOL}://${DOCKER_REGISTRY}/v2/$(echo ${IMAGE} | cut -d ":" -f 1)/tags/list | jq -r '.tags[0]')
            #         DIGEST=$(curl -s -X GET ${PROTOCOL}://${DOCKER_REGISTRY}/v2/$(echo ${IMAGE} | cut -d ":" -f 1)/manifests/latest -H 'Accept: application/vnd.docker.distribution.manifest.v2+json' | jq -r .config.digest)
            #         curl -X DELETE ${PROTOCOL}://${DOCKER_REGISTRY}/v2/$(echo ${IMAGE} | cut -d ":" -f 1)/manifests/${DIGEST}
            #         ;;
            #     *)
            #         # TAG=$(curl -s -X GET ${PROTOCOL}://${DOCKER_REGISTRY}/v2/$$(echo ${IMAGE} | cut -d ":" -f 1)/tags/list | jq -r '.tags[0]')
            #         DIGEST=$(curl -s -X GET ${PROTOCOL}://${DOCKER_REGISTRY}/v2/$(echo ${IMAGE} | cut -d ":" -f 1)/manifests/latest -H 'Accept: application/vnd.docker.distribution.manifest.v2+json' | jq -r .config.digest)
            #         curl -X DELETE ${PROTOCOL}://${DOCKER_REGISTRY}/v2/$(echo ${IMAGE} | cut -d ":" -f 1)/manifests/${DIGEST}
            #         ;;
            # esac
            TAGS=$(curl -s -X GET ${PROTOCOL}://${DOCKER_REGISTRY}/v2/$(echo ${IMAGE} | cut -d ":" -f 1)/tags/list | jq -r '.tags[]')
            for TAG in ${TAGS[*]}; do
                echo -e "\n>>> ${TAG}..."
                DIGEST=$(curl -s -X GET ${PROTOCOL}://${DOCKER_REGISTRY}/v2/$(echo ${IMAGE} | cut -d ":" -f 1)/manifests/${TAG} -H 'Accept: application/vnd.docker.distribution.manifest.v2+json' | jq -r .config.digest)
                curl -X DELETE ${PROTOCOL}://${DOCKER_REGISTRY}/v2/$(echo ${IMAGE} | cut -d ":" -f 1)/manifests/${DIGEST}
            done
        done
    fi
}

function docker_remove_images_using_file_list_from_local() {
    if [ "$#" != "1" ] && [ "$#" != "2" ]; then
        log_e "Usage: ${FUNCNAME[0]} <IMAGES_LIST_FILE> [<IMAGES_DIR>]"
        log_e "${FUNCNAME[0]} $# ${*}"
    else
        log_m "${FUNCNAME[0]} $# ${*}"
        # cd "${TOP_DIR:?}" || exit 1

        if [ "$#" == "1" ]; then
            local IMAGES_LIST_FILE=${1}
        elif [ "$#" == "2" ]; then
            local IMAGES_LIST_FILE=${1}
            local IMAGES_DIR=${2}
        fi

        for IMAGE in $(cat ${IMAGES_LIST_FILE}); do
            docker rmi ${IMAGE}
        done
        docker images

        if [ -e "${IMAGES_DIR}" ]; then
            # rm -f ${IMAGES_DIR}
            for IMAGE in $(cat ${IMAGES_LIST_FILE}); do
                rm -f "${IMAGES_DIR}/$(basename ${IMAGE}).tar"
            done
            ls "${IMAGES_DIR}"
        fi
    fi
}

#******************************************************************************

function docker_pull_images_to_local() {
    if [ "$#" != "1" ] && [ "$#" != "2" ] && [ "$#" != "4" ]; then
        log_e "Usage: ${FUNCNAME[0]} <IMAGES> [<IMAGES_DIR>] [<PULL_TAG_ONLY> <GREP_PULL_TAG>]"
        log_e "${FUNCNAME[0]} $# ${*}"
    else
        log_m "${FUNCNAME[0]} $# ${*}"
        # cd "${TOP_DIR:?}" || exit 1

        if [ "$#" == "1" ]; then
            local IMAGES=${1}
        elif [ "$#" == "2" ]; then
            local IMAGES=${1}
            local IMAGES_DIR=${2}
            local PULL_TAG_ONLY=false
            local GREP_PULL_TAG=master # master | master-head
        elif [ "$#" == "4" ]; then
            local IMAGES=${1}
            local IMAGES_DIR=${2}
            local PULL_TAG_ONLY=${3}
            local GREP_PULL_TAG=${4}
        fi

        for IMAGE in ${IMAGES[*]}; do
            if [ "${PULL_TAG_ONLY}" != true ] || [ "${PULL_TAG_ONLY}" == true ] && [ $(echo ${IMAGE} | grep ${GREP_PULL_TAG} | wc -l) == 1 ]; then
                docker pull ${IMAGE}
            fi
        done
        docker images

        if [[ ${IMAGES_DIR} ]]; then
            for IMAGE in ${IMAGES[*]}; do
                if [ "${PULL_TAG_ONLY}" != true ] || [ "${PULL_TAG_ONLY}" == true ] && [ $(echo ${IMAGE} | grep ${GREP_PULL_TAG} | wc -l) == 1 ]; then
                    # docker save $(cat ${IMAGES} | tr '\n' ' ') | gzip -c >"${IMAGES_DIR}/$(basename ${IMAGE}).tar.gz"
                    # docker save $(cat ${IMAGES} | tr '\n' ' ') | zstd -c --no-progress -T0 -16 -f --long=25 >"${IMAGES_DIR}/$(basename ${IMAGE}).tar.zst"
                    # docker save $(cat ${IMAGES} | tr '\n' ' ') | xz -c >"${IMAGES_DIR}/$(basename ${IMAGE}).xz"
                    docker save ${IMAGE} --output "${IMAGES_DIR}/$(basename ${IMAGE}).tar"
                fi
            done
            ls "${IMAGES_DIR}"
        fi
    fi
}

function docker_load_images_to_local() {
    if [ "$#" != "2" ]; then
        log_e "Usage: ${FUNCNAME[0]} <IMAGES> <IMAGES_DIR>"
        log_e "${FUNCNAME[0]} $# ${*}"
    else
        log_m "${FUNCNAME[0]} $# ${*}"
        # cd "${TOP_DIR:?}" || exit 1

        if [ "$#" == "2" ]; then
            local IMAGES=${1}
            local IMAGES_DIR=${2}
        fi

        for IMAGE in ${IMAGES[*]}; do
            docker load --input "${IMAGES_DIR}/$(basename ${IMAGE}).tar"
        done
        docker images
    fi
}

function docker_push_images_to_registry() {
    if [ "$#" != "1" ] && [ "$#" != "2" ]; then
        log_e "Usage: ${FUNCNAME[0]} <IMAGES> [<DOCKER_REGISTRY | DOCKER_REGISTRY:PORT>]"
        log_e "${FUNCNAME[0]} $# ${*}"
    else
        log_m "${FUNCNAME[0]} $# ${*}"
        # cd "${TOP_DIR:?}" || exit 1

        if [ "$#" == "1" ]; then
            local IMAGES=${1}
        elif [ "$#" == "2" ]; then
            local IMAGES=${1}
            local DOCKER_REGISTRY="${2}/"
        fi

        for IMAGE in ${IMAGES[*]}; do
            # case ${IMAGE} in
            #     */*/*)
            #         IMAGE_NAME=${DOCKER_REGISTRY}${DOCKER_USER}${IMAGE#*/*/}
            #         ;;
            #     */*)
            #         IMAGE_NAME=${DOCKER_REGISTRY}${DOCKER_USER}${IMAGE#*/}
            #         ;;
            #     *)
            #         IMAGE_NAME=${DOCKER_REGISTRY}${DOCKER_USER}${IMAGE}
            #         ;;
            # esac
            IMAGE_NAME=${DOCKER_REGISTRY}${IMAGE}
            echo -e "\n>>> ${IMAGE} => ${IMAGE_NAME}..."
            docker tag ${IMAGE} ${IMAGE_NAME}
            docker push ${IMAGE_NAME}
            docker rmi ${IMAGE_NAME}
        done
        docker images
    fi
}

# https://gist.github.com/jaytaylor/86d5efaddda926a25fa68c263830dac1
function docker_remove_images_from_registry() {
    if [ "$#" != "3" ]; then
        log_e "Usage: ${FUNCNAME[0]} <IMAGES> <PROTOCOL> <DOCKER_REGISTRY | DOCKER_REGISTRY:PORT>"
        log_e "${FUNCNAME[0]} $# ${*}"
    else
        log_m "${FUNCNAME[0]} $# ${*}"
        # cd "${TOP_DIR:?}" || exit 1

        if [ "$#" == "3" ]; then
            local IMAGES=${1}
            local PROTOCOL=${2} # http | https
            local DOCKER_REGISTRY=${3}
        fi

        for IMAGE in ${IMAGES[*]}; do
            echo -e "\n>>> ${IMAGE}..."
            # case ${IMAGE} in
            #     */*)
            #         # TAG=$(curl -s -X GET ${PROTOCOL}://${DOCKER_REGISTRY}/v2/$(echo ${IMAGE} | cut -d ":" -f 1)/tags/list | jq -r '.tags[0]')
            #         DIGEST=$(curl -s -X GET ${PROTOCOL}://${DOCKER_REGISTRY}/v2/$(echo ${IMAGE} | cut -d ":" -f 1)/manifests/latest -H 'Accept: application/vnd.docker.distribution.manifest.v2+json' | jq -r .config.digest)
            #         curl -X DELETE ${PROTOCOL}://${DOCKER_REGISTRY}/v2/$(echo ${IMAGE} | cut -d ":" -f 1)/manifests/${DIGEST}
            #         ;;
            #     *)
            #         # TAG=$(curl -s -X GET ${PROTOCOL}://${DOCKER_REGISTRY}/v2/$(echo ${IMAGE} | cut -d ":" -f 1)/tags/list | jq -r '.tags[0]')
            #         DIGEST=$(curl -s -X GET ${PROTOCOL}://${DOCKER_REGISTRY}/v2/$(echo ${IMAGE} | cut -d ":" -f 1)/manifests/latest -H 'Accept: application/vnd.docker.distribution.manifest.v2+json' | jq -r .config.digest)
            #         curl -X DELETE ${PROTOCOL}://${DOCKER_REGISTRY}/v2/$(echo ${IMAGE} | cut -d ":" -f 1)/manifests/${DIGEST}
            #         ;;
            # esac
            TAGS=$(curl -s -X GET ${PROTOCOL}://${DOCKER_REGISTRY}/v2/$(echo ${IMAGE} | cut -d ":" -f 1)/tags/list | jq -r '.tags[]')
            for TAG in ${TAGS[*]}; do
                echo -e "\n>>> ${TAG}..."
                DIGEST=$(curl -s -X GET ${PROTOCOL}://${DOCKER_REGISTRY}/v2/$(echo ${IMAGE} | cut -d ":" -f 1)/manifests/${TAG} -H 'Accept: application/vnd.docker.distribution.manifest.v2+json' | jq -r .config.digest)
                curl -X DELETE ${PROTOCOL}://${DOCKER_REGISTRY}/v2/$(echo ${IMAGE} | cut -d ":" -f 1)/manifests/${DIGEST}
            done
        done
    fi
}

function docker_remove_images_from_local() {
    if [ "$#" != "1" ] && [ "$#" != "2" ]; then
        log_e "Usage: ${FUNCNAME[0]} <IMAGES> [<IMAGES_DIR>]"
        log_e "${FUNCNAME[0]} $# ${*}"
    else
        log_m "${FUNCNAME[0]} $# ${*}"
        # cd "${TOP_DIR:?}" || exit 1

        if [ "$#" == "1" ]; then
            local IMAGES=${1}
        elif [ "$#" == "2" ]; then
            local IMAGES=${1}
            local IMAGES_DIR=${2}
        fi

        for IMAGE in ${IMAGES[*]}; do
            docker rmi ${IMAGE}
        done
        docker images

        if [ -e "${IMAGES_DIR}" ]; then
            # rm -f ${IMAGES_DIR}
            for IMAGE in ${IMAGES[*]}; do
                rm -f "${IMAGES_DIR}/$(basename ${IMAGE}).tar"
            done
            ls "${IMAGES_DIR}"
        fi
    fi
}

#******************************************************************************

function docker_list_images_from_registry() {
    if [ "$#" != "2" ] && [ "$#" != "4" ]; then
        log_e "Usage: ${FUNCNAME[0]} <PROTOCOL:http|https> <DOCKER_REGISTRY | DOCKER_REGISTRY:PORT> [<DOCKER_USER> <DOCKER_PASSWORD>]"
        log_e "${FUNCNAME[0]} $# ${*}"
    else
        log_m "${FUNCNAME[0]} $# ${*}"
        # cd "${TOP_DIR:?}" || exit 1

        if [ "$#" == "2" ]; then
            local PROTOCOL=${1} # http | https
            local DOCKER_REGISTRY=${2}
        elif [ "$#" == "4" ]; then
            local PROTOCOL=${1} # http | https
            local DOCKER_REGISTRY=${2}
            local DOCKER_USER=${3}
            local DOCKER_PASSWORD=${4}
        fi

        if [ "$#" == "2" ] && [ "${PROTOCOL}" == "http" ]; then
            # curl -X GET ${PROTOCOL}://${DOCKER_REGISTRY}/v2/_catalog | jq
            reg ls -f ${PROTOCOL}://${DOCKER_REGISTRY}
        elif [ "$#" == "2" ] && [ "${PROTOCOL}" == "https" ]; then
            # curl -X GET ${PROTOCOL}://${DOCKER_REGISTRY}/v2/_catalog | jq
            reg ls ${PROTOCOL}://${DOCKER_REGISTRY}
        elif [ "$#" == "4" ] && [ "${PROTOCOL}" == "http" ]; then
            # curl -X GET -sk -u ${DOCKER_USER}:${DOCKER_PASSWORD} ${PROTOCOL}://${DOCKER_REGISTRY}/v2/_catalog | jq
            reg ls -f -u ${DOCKER_USER} -p ${DOCKER_PASSWORD} ${PROTOCOL}://${DOCKER_REGISTRY}
        elif [ "$#" == "4" ] && [ "${PROTOCOL}" == "https" ]; then
            # curl -X GET -sk -u ${DOCKER_USER}:${DOCKER_PASSWORD} ${PROTOCOL}://${DOCKER_REGISTRY}/v2/_catalog | jq
            reg ls -u ${DOCKER_USER} -p ${DOCKER_PASSWORD} ${PROTOCOL}://${DOCKER_REGISTRY}
        fi
        # ls ${HOME}/Documents/myImages/registry/docker/registry/v2/
    fi
}

function docker_list_tags_of_image() {
    if [ "$#" != "3" ] && [ "$#" != "5" ]; then
        log_e "Usage: ${FUNCNAME[0]} <PROTOCOL:http|https> <DOCKER_REGISTRY | DOCKER_REGISTRY:PORT> <IMAGES> [<DOCKER_USER> <DOCKER_PASSWORD>]"
        log_e "${FUNCNAME[0]} $# ${*}"
    else
        log_m "${FUNCNAME[0]} $# ${*}"
        # cd "${TOP_DIR:?}" || exit 1

        if [ "$#" == "3" ]; then
            local PROTOCOL=${1} # http | https
            local DOCKER_REGISTRY=${2}
            local IMAGES=${3}
            # local IMAGES_LIST_FILE=${4}
        elif [ "$#" == "5" ]; then
            local PROTOCOL=${1} # http | https
            local DOCKER_REGISTRY=${2}
            local IMAGES=${3}
            # local IMAGES_LIST_FILE=${4}
            local DOCKER_USER=${4}
            local DOCKER_PASSWORD=${5}
        fi

        for IMAGE in ${IMAGES[*]}; do
            echo -e "\n>>> ${IMAGE}..."
            # curl -X GET ${PROTOCOL}://${DOCKER_REGISTRY}/v2/${DOCKER_PROJECT}/tags/list | jq
            # curl -X GET ${PROTOCOL}://${DOCKER_REGISTRY}/v2/$(echo ${IMAGE} | cut -d ":" -f 1)/tags/list | jq
            if [ "$#" == "3" ] && [ "${PROTOCOL}" == "http" ]; then
                reg tags -f ${DOCKER_REGISTRY}/$(echo ${IMAGE} | cut -d ":" -f 1)
            elif [ "$#" == "3" ] && [ "${PROTOCOL}" == "https" ]; then
                reg tags ${DOCKER_REGISTRY}/$(echo ${IMAGE} | cut -d ":" -f 1)
            elif [ "$#" == "5" ] && [ "${PROTOCOL}" == "http" ]; then
                reg tags -f -u ${DOCKER_USER} -p ${DOCKER_PASSWORD} ${DOCKER_REGISTRY}/$(echo ${IMAGE} | cut -d ":" -f 1)
            elif [ "$#" == "5" ] && [ "${PROTOCOL}" == "https" ]; then
                reg tags -u ${DOCKER_USER} -p ${DOCKER_PASSWORD} ${DOCKER_REGISTRY}/$(echo ${IMAGE} | cut -d ":" -f 1)
            fi
        done

        # for IMAGE in $(cat ${IMAGES_LIST_FILE}); do
        #     echo -e "\n>>> ${IMAGE}..."
        #     # curl -X GET ${PROTOCOL}://${DOCKER_REGISTRY}/v2/${DOCKER_PROJECT}/tags/list | jq
        #     # curl -X GET ${PROTOCOL}://${DOCKER_REGISTRY}/v2/$(echo ${IMAGE} | cut -d ":" -f 1)/tags/list | jq
        #     if [ "$#" == "3" ] && [ "${PROTOCOL}" == "http" ]; then
        #         reg tags -f ${DOCKER_REGISTRY}/$(echo ${IMAGE} | cut -d ":" -f 1)
        #     elif [ "$#" == "3" ] && [ "${PROTOCOL}" == "https" ]; then
        #         reg tags ${DOCKER_REGISTRY}/$(echo ${IMAGE} | cut -d ":" -f 1)
        #     elif [ "$#" == "5" ] && [ "${PROTOCOL}" == "http" ]; then
        #         reg tags -f -u ${DOCKER_USER} -p ${DOCKER_PASSWORD} ${DOCKER_REGISTRY}/$(echo ${IMAGE} | cut -d ":" -f 1)
        #     elif [ "$#" == "5" ] && [ "${PROTOCOL}" == "https" ]; then
        #         reg tags -u ${DOCKER_USER} -p ${DOCKER_PASSWORD} ${DOCKER_REGISTRY}/$(echo ${IMAGE} | cut -d ":" -f 1)
        #     fi
        # done
    fi
}

#******************************************************************************

function docker_save_local_image_and_load_in_remote_host() {
    if [ "$#" != "4" ]; then
        log_e "Usage: ${FUNCNAME[0]} [<DOCKER_USER>] <DOCKER_PROJECT> <DOCKER_TAG> <SSH_USER> <IPS>"
        log_e "${FUNCNAME[0]} $# ${*}"
    else
        log_m "${FUNCNAME[0]} $# ${*}"
        cd "${TOP_DIR:?}" || exit 1

        if [ "$#" == "4" ]; then
            local DOCKER_PROJECT=${1}
            local DOCKER_TAG=${2}
            local SSH_USER=${3}
            local IPS=${4}
        fi

        # IPS=${4}
        for IP in ${IPS[*]}; do
            echo -e "\n>>> ${IP}...\n"
            case ${KUBERNETES_DISTRO} in
                k3s)
                    ssh_cmd "${SSH_USER}" "${IP}" "sudo /usr/local/bin/crictl images"
                    ;;
                rke2)
                    ssh_cmd "${SSH_USER}" "${IP}" "sudo /var/lib/rancher/rke2/bin/crictl --config /var/lib/rancher/rke2/agent/etc/crictl.yaml images"
                    ;;
                rke)
                    # docker save ${DOCKER_PROJECT}:${DOCKER_TAG} | bzip2 | pv | ssh ${SSH_USER}@${IP} -o StrictHostKeyChecking=no 'bunzip2 | sudo docker load'
                    docker save ${DOCKER_PROJECT}:${DOCKER_TAG} | ssh ${SSH_USER}@${IP} -o StrictHostKeyChecking=no 'sudo docker load'
                    ssh_cmd "${SSH_USER}" "${IP}" "sudo docker images"
                    ;;
                *) ;;
            esac
        done
    fi
}

function docker_save_remote_image_and_load_in_local_host() {
    if [ "$#" != "4" ]; then
        log_e "Usage: ${FUNCNAME[0]} [<DOCKER_USER>] <DOCKER_PROJECT> <DOCKER_TAG> <SSH_USER> <IP>"
        log_e "${FUNCNAME[0]} $# ${*}"
    else
        log_m "${FUNCNAME[0]} $# ${*}"
        cd "${TOP_DIR:?}" || exit 1

        if [ "$#" == "4" ]; then
            local DOCKER_PROJECT=${1}
            local DOCKER_TAG=${2}
            local SSH_USER=${3}
            local IP=${4}
        fi

        case ${KUBERNETES_DISTRO} in
            k3s)
                docker images
                ;;
            rke2)
                docker images
                ;;
            rke)
                # ssh ${SSH_USER}@${IP} -o StrictHostKeyChecking=no "sudo docker save ${DOCKER_PROJECT}:${DOCKER_TAG} | bzip2" | pv | bunzip2 | docker load
                ssh ${SSH_USER}@${IP} -o StrictHostKeyChecking=no "sudo docker save ${DOCKER_PROJECT}:${DOCKER_TAG}" | docker load
                docker images
                ;;
            *) ;;
        esac
    fi
}

function docker_remove_images_in_remote_host() {
    if [ "$#" != "4" ]; then
        log_e "Usage: ${FUNCNAME[0]} [<DOCKER_USER>] <DOCKER_PROJECT> <DOCKER_TAG> <SSH_USER> <IPS>"
        log_e "${FUNCNAME[0]} $# ${*}"
    else
        log_m "${FUNCNAME[0]} $# ${*}"
        cd "${TOP_DIR:?}" || exit 1

        if [ "$#" == "4" ]; then
            local DOCKER_PROJECT=${1}
            local DOCKER_TAG=${2}
            local SSH_USER=${3}
            local IPS=${4}
        fi

        # IPS=${4}
        for IP in ${IPS[*]}; do
            echo -e "\n>>> ${IP}...\n"
            ssh_cmd "${SSH_USER}" "${IP}" "sudo docker rmi ${DOCKER_PROJECT}:${DOCKER_TAG}"
            ssh_cmd "${SSH_USER}" "${IP}" "sudo docker images"
        done
    fi
}

#******************************************************************************
# docker-compose

function docker_compose_up() {
    if [ "$#" != "0" ] && [ "$#" != "1" ]; then
        log_e "Usage: ${FUNCNAME[0]} <DOCKER_COMPOSE_FILE>"
        log_e "${FUNCNAME[0]} $# ${*}"
    else
        log_m "${FUNCNAME[0]} $# ${*}"
        cd "${TOP_DIR:?}" || exit 1

        if [ "$#" == "1" ]; then
            local DOCKER_COMPOSE_FILE=${1}
        fi

        docker-compose -f ${DOCKER_COMPOSE_FILE} up # --detach
    fi
}

function docker_compose_down() {
    if [ "$#" != "0" ] && [ "$#" != "1" ]; then
        log_e "Usage: ${FUNCNAME[0]} <DOCKER_COMPOSE_FILE>"
        log_e "${FUNCNAME[0]} $# ${*}"
    else
        log_m "${FUNCNAME[0]} $# ${*}"
        cd "${TOP_DIR:?}" || exit 1

        if [ "$#" == "1" ]; then
            local DOCKER_COMPOSE_FILE=${1}
        fi

        docker-compose -f ${DOCKER_COMPOSE_FILE} down
    fi
}

function docker_compose_start() {
    if [ "$#" != "0" ] && [ "$#" != "1" ]; then
        log_e "Usage: ${FUNCNAME[0]} <DOCKER_COMPOSE_FILE>"
        log_e "${FUNCNAME[0]} $# ${*}"
    else
        log_m "${FUNCNAME[0]} $# ${*}"
        cd "${TOP_DIR:?}" || exit 1

        if [ "$#" == "1" ]; then
            local DOCKER_COMPOSE_FILE=${1}
        fi

        docker-compose -f ${DOCKER_COMPOSE_FILE} start
    fi
}

function docker_compose_stop() {
    if [ "$#" != "0" ] && [ "$#" != "1" ]; then
        log_e "Usage: ${FUNCNAME[0]} <DOCKER_COMPOSE_FILE>"
        log_e "${FUNCNAME[0]} $# ${*}"
    else
        log_m "${FUNCNAME[0]} $# ${*}"
        cd "${TOP_DIR:?}" || exit 1

        if [ "$#" == "1" ]; then
            local DOCKER_COMPOSE_FILE=${1}
        fi

        docker-compose -f ${DOCKER_COMPOSE_FILE} stop
    fi
}

function docker_compose_lists() {
    if [ "$#" != "0" ] && [ "$#" != "1" ]; then
        log_e "Usage: ${FUNCNAME[0]} <DOCKER_COMPOSE_FILE>"
        log_e "${FUNCNAME[0]} $# ${*}"
    else
        log_m "${FUNCNAME[0]} $# ${*}"
        cd "${TOP_DIR:?}" || exit 1

        if [ "$#" == "1" ]; then
            local DOCKER_COMPOSE_FILE=${1}
        fi

        echo -e "\n>>> Show Docker Services...\n"
        docker-compose -f ${DOCKER_COMPOSE_FILE} ps
        # echo -e "\n>>> Show Docker Volumes...\n"
        # docker-compose -f ${DOCKER_COMPOSE_FILE} volume ls
        # echo -e "\n>>> Show Docker Networks...\n"
        # docker-compose -f ${DOCKER_COMPOSE_FILE} network ls
        echo -e "\n>>> Show Docker Ports...\n"
        docker-compose -f ${DOCKER_COMPOSE_FILE} port
        echo -e "\n>>> Show Docker Images...\n"
        docker-compose -f ${DOCKER_COMPOSE_FILE} images
    fi
}

function docker_compose_top() {
    if [ "$#" != "0" ] && [ "$#" != "1" ]; then
        log_e "Usage: ${FUNCNAME[0]} <DOCKER_COMPOSE_FILE>"
        log_e "${FUNCNAME[0]} $# ${*}"
    else
        log_m "${FUNCNAME[0]} $# ${*}"
        cd "${TOP_DIR:?}" || exit 1

        if [ "$#" == "1" ]; then
            local DOCKER_COMPOSE_FILE=${1}
        fi

        echo -e "\n>>> Show Docker Services...\n"
        docker-compose -f ${DOCKER_COMPOSE_FILE} top
    fi
}

#******************************************************************************
# podman

function podman_pull() {
    if [ "$#" != "0" ] && [ "$#" != "2" ] && [ "$#" != "3" ]; then
        log_e "Usage: ${FUNCNAME[0]} [<PODMAN_USER>] <PODMAN_PROJECT> <PODMAN_TAG>"
        log_e "${FUNCNAME[0]} $# ${*}"
    else
        log_m "${FUNCNAME[0]} $# ${*}"
        cd "${TOP_DIR:?}" || exit 1

        if [ "$#" == "2" ]; then
            local PODMAN_PROJECT=${1} # ${GITHUB_PROJECT}
            local PODMAN_TAG=${2}     # latest | latest-alpine | v0.0.1
        elif [ "$#" == "3" ]; then
            local PODMAN_USER=${1}    # ${GITHUB_USER}
            local PODMAN_PROJECT=${2} # ${GITHUB_PROJECT}
            local PODMAN_TAG=${3}     # latest | latest-alpine | v0.0.1
        fi

        if [ "${PODMAN_USER}" == "" ]; then
            # podman pull ${PODMAN_REGISTRY}/${PODMAN_PROJECT}:${PODMAN_TAG}
            podman pull ${PODMAN_PROJECT}:${PODMAN_TAG}
        else
            # podman pull ${PODMAN_REGISTRY}/${PODMAN_USER}/${PODMAN_PROJECT}:${PODMAN_TAG}
            podman pull ${PODMAN_USER}/${PODMAN_PROJECT}:${PODMAN_TAG}
        fi
        sudo podman images
    fi
}

function podman_push() {
    if [ "$#" != "0" ] && [ "$#" != "2" ] && [ "$#" != "3" ]; then
        log_e "Usage: ${FUNCNAME[0]} [<PODMAN_USER>] <PODMAN_PROJECT> <PODMAN_TAG>"
        log_e "${FUNCNAME[0]} $# ${*}"
    else
        log_m "${FUNCNAME[0]} $# ${*}"
        cd "${TOP_DIR:?}" || exit 1

        if [ "$#" == "2" ]; then
            local PODMAN_PROJECT=${1} # ${GITHUB_PROJECT}
            local PODMAN_TAG=${2}     # latest | latest-alpine | v0.0.1
        elif [ "$#" == "3" ]; then
            local PODMAN_USER=${1}    # ${GITHUB_USER}
            local PODMAN_PROJECT=${2} # ${GITHUB_PROJECT}
            local PODMAN_TAG=${3}     # latest | latest-alpine | v0.0.1
        fi

        if [ "${PODMAN_USER}" == "" ]; then
            # podman push ${PODMAN_REGISTRY}/${PODMAN_PROJECT}:${PODMAN_TAG}
            podman push ${PODMAN_PROJECT}:${PODMAN_TAG}
        else
            # podman push ${PODMAN_REGISTRY}/${PODMAN_USER}/${PODMAN_PROJECT}:${PODMAN_TAG}
            podman push ${PODMAN_USER}/${PODMAN_PROJECT}:${PODMAN_TAG}
        fi
        sudo podman images
    fi
}

function podman_remove() {
    if [ "$#" != "0" ] && [ "$#" != "2" ] && [ "$#" != "3" ]; then
        log_e "Usage: ${FUNCNAME[0]} [<PODMAN_USER>] <PODMAN_PROJECT> <PODMAN_TAG>"
        log_e "${FUNCNAME[0]} $# ${*}"
    else
        log_m "${FUNCNAME[0]} $# ${*}"
        cd "${TOP_DIR:?}" || exit 1

        if [ "$#" == "2" ]; then
            local PODMAN_PROJECT=${1} # ${GITHUB_PROJECT}
            local PODMAN_TAG=${2}     # latest | latest-alpine | v0.0.1
        elif [ "$#" == "3" ]; then
            local PODMAN_USER=${1}    # ${GITHUB_USER}
            local PODMAN_PROJECT=${2} # ${GITHUB_PROJECT}
            local PODMAN_TAG=${3}     # latest | latest-alpine | v0.0.1
        fi

        if [ "${PODMAN_USER}" == "" ]; then
            # podman rmi ${PODMAN_REGISTRY}/${PODMAN_PROJECT}:${PODMAN_TAG}
            podman rmi ${PODMAN_PROJECT}:${PODMAN_TAG}
        else
            # podman rmi ${PODMAN_REGISTRY}/${PODMAN_USER}/${PODMAN_PROJECT}:${PODMAN_TAG}
            podman rmi ${PODMAN_USER}/${PODMAN_PROJECT}:${PODMAN_TAG}
        fi
    fi
}

function podman_clean() {
    if [ "$#" != "0" ] && [ "$#" != "2" ] && [ "$#" != "3" ]; then
        log_e "Usage: ${FUNCNAME[0]} [<PODMAN_USER>] <PODMAN_PROJECT> <PODMAN_TAG>"
        log_e "${FUNCNAME[0]} $# ${*}"
    else
        log_m "${FUNCNAME[0]} $# ${*}"
        cd "${TOP_DIR:?}" || exit 1

        podman rm -f ${PODMAN_PROJECT} 2>/dev/null
        podman rmi ${PODMAN_USER}/${PODMAN_PROJECT} 2>/dev/null
        podman rmi $(REPO):$(TAG) 2>/dev/null
        podman rm $(podman ps -a -q) 2>/dev/null
        podman rmi $(podman images -f "dangling=true" -q) 2>/dev/null
        podman volume prune -f 2>/dev/null
    fi
}

#******************************************************************************
# ctr/crictl
# https://blog.scottlowe.org/2020/01/25/manually-loading-container-images-with-containerd/

function ctr_save_local_image_and_load_in_remote_host() {
    if [ "$#" != "4" ]; then
        log_e "Usage: ${FUNCNAME[0]} [<DOCKER_USER>] <DOCKER_PROJECT> <DOCKER_TAG> <SSH_USER> <IPS>"
        log_e "${FUNCNAME[0]} $# ${*}"
    else
        log_m "${FUNCNAME[0]} $# ${*}"
        cd "${TOP_DIR:?}" || exit 1

        if [ "$#" == "4" ]; then
            local DOCKER_PROJECT=${1}
            local DOCKER_TAG=${2}
            local SSH_USER=${3}
            local IPS=${4}
        fi

        docker save --output /tmp/docker_image.tar ${DOCKER_PROJECT}:${DOCKER_TAG}
        # IPS=${4}
        for IP in ${IPS[*]}; do
            echo -e "\n>>> ${IP}...\n"
            # sudo ctr image export ${DOCKER_PROJECT}:${DOCKER_TAG} | bzip2 | pv | ssh ${SSH_USER}@${IP} -o StrictHostKeyChecking=no 'bunzip2 | sudo ctr image import'
            # sudo ctr image export ${DOCKER_PROJECT}:${DOCKER_TAG} | ssh ${SSH_USER}@${IP} -o StrictHostKeyChecking=no 'sudo ctr image import'
            scp_to "/tmp/docker_image.tar" "${SSH_USER}@${IP}:/tmp/docker_image.tar"
            case ${KUBERNETES_DISTRO} in
                k3s)
                    ssh ${SSH_USER}@${IP} -o StrictHostKeyChecking=no "sudo /usr/local/bin/ctr image import --base-name ${DOCKER_PROJECT}:${DOCKER_TAG} /tmp/docker_image.tar"
                    ssh_cmd "${SSH_USER}" "${IP}" "sudo /usr/local/bin/crictl images"
                    ;;
                rke2)
                    ssh ${SSH_USER}@${IP} -o StrictHostKeyChecking=no "sudo /var/lib/rancher/rke2/bin/ctr --address /run/k3s/containerd/containerd.sock --namespace k8s.io image import --base-name ${DOCKER_PROJECT}:${DOCKER_TAG} /tmp/docker_image.tar"
                    ssh_cmd "${SSH_USER}" "${IP}" "sudo /var/lib/rancher/rke2/bin/crictl --config /var/lib/rancher/rke2/agent/etc/crictl.yaml images"
                    ;;
                rke)
                    ssh ${SSH_USER}@${IP} -o StrictHostKeyChecking=no "docker load --input /tmp/docker_image.tar"
                    ssh_cmd "${SSH_USER}" "${IP}" "docker images"
                    ;;
                *) ;;
            esac
        done
        rm -f /tmp/docker_image.tar
    fi
}

function ctr_save_remote_image_and_load_in_local_host() {
    if [ "$#" != "4" ]; then
        log_e "Usage: ${FUNCNAME[0]} [<DOCKER_USER>] <DOCKER_PROJECT> <DOCKER_TAG> <SSH_USER> <IP>"
        log_e "${FUNCNAME[0]} $# ${*}"
    else
        log_m "${FUNCNAME[0]} $# ${*}"
        cd "${TOP_DIR:?}" || exit 1

        if [ "$#" == "4" ]; then
            local DOCKER_PROJECT=${1}
            local DOCKER_TAG=${2}
            local SSH_USER=${3}
            local IP=${4}
        fi

        case ${KUBERNETES_DISTRO} in
            k3s)
                # ssh ${SSH_USER}@${IP} -o StrictHostKeyChecking=no "sudo ctr image export ${DOCKER_PROJECT}:${DOCKER_TAG} | bzip2" | pv | bunzip2 | sudo ctr image import
                # ssh ${SSH_USER}@${IP} -o StrictHostKeyChecking=no "sudo ctr image export ${DOCKER_PROJECT}:${DOCKER_TAG}" | sudo ctr image import
                # sudo crictl images
                ssh ${SSH_USER}@${IP} -o StrictHostKeyChecking=no "sudo ctr image export ${DOCKER_PROJECT}:${DOCKER_TAG}" | docker load
                docker images
                ;;
            rke2)
                # ssh ${SSH_USER}@${IP} -o StrictHostKeyChecking=no "sudo ctr image export ${DOCKER_PROJECT}:${DOCKER_TAG} | bzip2" | pv | bunzip2 | sudo ctr image import
                # ssh ${SSH_USER}@${IP} -o StrictHostKeyChecking=no "sudo ctr image export ${DOCKER_PROJECT}:${DOCKER_TAG}" | sudo ctr image import
                # sudo crictl images
                ssh ${SSH_USER}@${IP} -o StrictHostKeyChecking=no "sudo ctr image export ${DOCKER_PROJECT}:${DOCKER_TAG}" | docker load
                docker images
                ;;
            rke)
                docker images
                ;;
            *) ;;
        esac
    fi
}

function crictl_remove_images_in_remote_host() {
    if [ "$#" != "4" ]; then
        log_e "Usage: ${FUNCNAME[0]} [<DOCKER_USER>] <DOCKER_PROJECT> <DOCKER_TAG> <SSH_USER> <IPS>"
        log_e "${FUNCNAME[0]} $# ${*}"
    else
        log_m "${FUNCNAME[0]} $# ${*}"
        cd "${TOP_DIR:?}" || exit 1

        if [ "$#" == "4" ]; then
            local DOCKER_PROJECT=${1}
            local DOCKER_TAG=${2}
            local SSH_USER=${3}
            local IPS=${4}
        fi

        # IPS=${4}
        for IP in ${IPS[*]}; do
            echo -e "\n>>> ${IP}...\n"
            ssh_cmd "${SSH_USER}" "${IP}" "sudo /usr/local/bin/crictl rmi ${DOCKER_PROJECT}:${DOCKER_TAG}"
            ssh_cmd "${SSH_USER}" "${IP}" "sudo /usr/local/bin/crictl images"
        done
    fi
}

#******************************************************************************
# kubernetes - krew

function kubectl_krew_install() {
    if [ "$#" != "0" ]; then
        log_e "Usage: ${FUNCNAME[0]} [<PLUGIN_REPO> <PLUGIN_REPO_URL>]<PLUGIN>"
        log_e "${FUNCNAME[0]} $# ${*}"
    else
        log_m "${FUNCNAME[0]} $# ${*}"
        # cd "${TOP_DIR:?}" || exit 1

        if [ "$#" == "1" ]; then
            local PLUGIN="${1}"
        elif [ "$#" == "3" ]; then
            local PLUGIN_REPO=${1}
            local PLUGIN_REPO_URL=${2}
            local PLUGIN=${3}
        fi

        if [ "$#" == "1" ]; then
            kubectl krew install $${PLUGIN}
        elif [ "$#" == "3" ]; then
            kubectl krew index add ${PLUGIN_REPO} ${PLUGIN_REPO_URL}
            kubectl krew install ${PLUGIN_REPO}/${PLUGIN}
        fi
    fi
}

function kubectl_krew_uninstall() {
    if [ "$#" != "1" ]; then
        log_e "Usage: ${FUNCNAME[0]} <PLUGIN>"
        log_e "${FUNCNAME[0]} $# ${*}"
    else
        log_m "${FUNCNAME[0]} $# ${*}"
        # cd "${TOP_DIR:?}" || exit 1

        if [ "$#" == "1" ]; then
            local PLUGIN="${1}"
        fi

        kubectl krew uninstall ${PLUGIN}
    fi
}

function kubectl_krew_upgrade() {
    if [ "$#" != "1" ]; then
        log_e "Usage: ${FUNCNAME[0]} <PLUGIN>"
        log_e "${FUNCNAME[0]} $# ${*}"
    else
        log_m "${FUNCNAME[0]} $# ${*}"
        # cd "${TOP_DIR:?}" || exit 1

        if [ "$#" == "1" ]; then
            local PLUGIN="${1}"
        fi

        kubectl krew upgrade ${PLUGIN}
    fi
}

#******************************************************************************
# kubernetes - node

function kubectl_delete_crd() {
    if [ "$#" != "0" ]; then
        log_e "Usage: ${FUNCNAME[0]} <ARGS>"
        log_e "${FUNCNAME[0]} $# ${*}"
    else
        log_m "${FUNCNAME[0]} $# ${*}"
        # cd "${TOP_DIR:?}" || exit 1

        LABEL="longhorn.rancher.io"
        for CRD in $(kubectl get crd -o jsonpath={.items[*].metadata.name} | tr ' ' '\n' | grep ${LABEL}); do
            kubectl -n ${NAMESPACE} get ${CRD} -o yaml | sed "s/\- ${LABEL}//g" | kubectl apply -f -
            kubectl -n ${NAMESPACE} delete ${CRD} --all
            kubectl delete crd/${CRD}
        done
    fi
}

# https://kubernetes.io/docs/tasks/configure-pod-container/assign-pods-nodes/
function kubectl_label() {
    if [ "$#" != "0" ] && [ "$#" != "2" ]; then
        log_e "Usage: ${FUNCNAME[0]} <LABELS: key=value:NoSchedule> <NODE_NAMES>"
        log_e "${FUNCNAME[0]} $# ${*}"
    else
        # log_m "${FUNCNAME[0]} $# ${*}"
        # cd "${TOP_DIR:?}" || exit 1

        if [ "$#" == "2" ]; then
            local LABELS="${1}"
            local NODE_NAMES="${2}"
        else
            local LABELS="node-role.kubernetes.io/control-plane=true node-role.kubernetes.io/etcd=true"
            local NODE_NAMES=$(kubectl get nodes -l "${LABEL}" -o jsonpath='{.items[*].metadata.name}')
        fi

        for LABEL in ${LABELS[*]}; do
            for NODE in ${NODE_NAMES[*]}; do
                echo ${NODE} ${LABEL}
                kubectl label nodes ${NODE} ${LABEL}
            done
        done
    fi
}

function kubectl_unlabel() {
    if [ "$#" != "0" ] && [ "$#" != "2" ]; then
        log_e "Usage: ${FUNCNAME[0]} <LABELS: key=value:NoSchedule> <NODE_NAMES>"
        log_e "${FUNCNAME[0]} $# ${*}"
    else
        # log_m "${FUNCNAME[0]} $# ${*}"
        # cd "${TOP_DIR:?}" || exit 1

        if [ "$#" == "2" ]; then
            local LABELS="${1}"
            local NODE_NAMES=${2}""
        else
            local LABELS="node-role.kubernetes.io/control-plane=true node-role.kubernetes.io/etcd=true"
            local NODE_NAMES=$(kubectl get nodes -l "${LABEL}" -o jsonpath='{.items[*].metadata.name}')
        fi

        for LABEL in ${LABELS[*]}; do
            for NODE in ${NODE_NAMES[*]}; do
                # kubectl patch -p '{"metadata":{"labels":  {"xxx":null}}}' node ${NODE}
                echo ${NODE} $(echo ${LABEL} | cut -d '=' -f 1)
                kubectl label nodes ${NODE} $(echo ${LABEL} | cut -d '=' -f 1)-
            done
        done
    fi
}

function kubectl_annotate() {
    if [ "$#" != "0" ] && [ "$#" != "2" ]; then
        log_e "Usage: ${FUNCNAME[0]} <LABELS: key=value:NoSchedule> <NODE_NAMES>"
        log_e "${FUNCNAME[0]} $# ${*}"
    else
        # log_m "${FUNCNAME[0]} $# ${*}"
        # cd "${TOP_DIR:?}" || exit 1

        if [ "$#" == "2" ]; then
            local LABELS="${1}"
            local NODE_NAMES="${2}"
        else
            local LABELS="node-role.kubernetes.io/control-plane=true node-role.kubernetes.io/etcd=true"
            local NODE_NAMES=$(kubectl get nodes -l "${LABEL}" -o jsonpath='{.items[*].metadata.name}')
        fi

        for LABEL in ${LABELS[*]}; do
            for NODE in ${NODE_NAMES[*]}; do
                echo ${NODE} ${LABEL}
                kubectl annotate nodes ${NODE} ${LABEL}
            done
        done
    fi
}

function kubectl_unannotate() {
    if [ "$#" != "0" ] && [ "$#" != "2" ]; then
        log_e "Usage: ${FUNCNAME[0]} <LABELS: key=value:NoSchedule> <NODE_NAMES>"
        log_e "${FUNCNAME[0]} $# ${*}"
    else
        # log_m "${FUNCNAME[0]} $# ${*}"
        # cd "${TOP_DIR:?}" || exit 1

        if [ "$#" == "2" ]; then
            local LABELS="${1}"
            local NODE_NAMES=${2}""
        else
            local LABELS="node-role.kubernetes.io/control-plane=true node-role.kubernetes.io/etcd=true"
            local NODE_NAMES=$(kubectl get nodes -l "${LABEL}" -o jsonpath='{.items[*].metadata.name}')
        fi

        for LABEL in ${LABELS[*]}; do
            for NODE in ${NODE_NAMES[*]}; do
                # kubectl patch -p '{"metadata":{"annotations": {"xxx":null}}}' node ${NODE}
                echo ${NODE} $(echo ${LABEL} | cut -d '=' -f 1)
                kubectl annotate nodes ${NODE} $(echo ${LABEL} | cut -d '=' -f 1)-
            done
        done
    fi
}

# https://kubernetes.io/docs/concepts/scheduling-eviction/taint-and-toleration/
function kubectl_taint() {
    if [ "$#" != "0" ] && [ "$#" != "2" ]; then
        log_e "Usage: ${FUNCNAME[0]} <LABELS: key=value:NoSchedule> <NODE_NAMES>"
        log_e "${FUNCNAME[0]} $# ${*}"
    else
        # log_m "${FUNCNAME[0]} $# ${*}"
        # cd "${TOP_DIR:?}" || exit 1

        if [ "$#" == "2" ]; then
            local LABELS="${1}"
            local NODE_NAMES="${2}"
        else
            local LABELS="node-role.kubernetes.io/control-plane=true node-role.kubernetes.io/etcd=true"
            local NODE_NAMES=$(kubectl get nodes -l "${LABEL}" -o jsonpath='{.items[*].metadata.name}')
        fi

        for LABEL in ${LABELS[*]}; do
            for NODE in ${NODE_NAMES[*]}; do
                # echo ${NODE} $(echo ${LABEL} | cut -d '=' -f 1)
                # kubectl taint nodes ${NODE} $(echo ${LABEL} | cut -d '=' -f 1)
                echo ${NODE} ${LABEL}
                kubectl taint nodes ${NODE} ${LABEL}
            done
        done
    fi
}

function kubectl_untaint() {
    if [ "$#" != "0" ] && [ "$#" != "2" ]; then
        log_e "Usage: ${FUNCNAME[0]} <LABELS: key=value:NoSchedule> <NODE_NAMES>"
        log_e "${FUNCNAME[0]} $# ${*}"
    else
        # log_m "${FUNCNAME[0]} $# ${*}"
        # cd "${TOP_DIR:?}" || exit 1

        if [ "$#" == "2" ]; then
            local LABELS="${1}"
            local NODE_NAMES=${2}""
        else
            local LABELS="node-role.kubernetes.io/control-plane=true node-role.kubernetes.io/etcd=true"
            local NODE_NAMES=$(kubectl get nodes -l "${LABEL}" -o jsonpath='{.items[*].metadata.name}')
        fi

        for LABEL in ${LABELS[*]}; do
            for NODE in ${NODE_NAMES[*]}; do
                # kubectl patch -p '{"spec":{"taints": null}}' node ${NODE}
                # echo ${NODE} $(echo ${LABEL} | cut -d '=' -f 1)
                # kubectl taint nodes ${NODE} $(echo ${LABEL} | cut -d '=' -f 1)-
                echo ${NODE} ${LABEL}
                kubectl taint nodes "${NODE}" "${LABEL}-"
            done
        done
    fi
}

# function kubectl_tolerations() {
#     if [ "$#" != "0" ] && [ "$#" != "2" ]; then
#         log_e "Usage: ${FUNCNAME[0]} <LABELS: key=value:NoSchedule> <NODE_NAMES>"
#     else
#         # log_m "${FUNCNAME[0]} $# ${*}"
#         # cd "${TOP_DIR:?}" || exit 1

#         if [ "$#" == "2" ]; then
#             local LABELS="${1}"
#             local NODE_NAMES="${2}"
#         else
#             local LABELS="node-role.kubernetes.io/control-plane=true node-role.kubernetes.io/etcd=true"
#             local NODE_NAMES=$(kubectl get nodes -l "${LABEL}" -o jsonpath='{.items[*].metadata.name}')
#         fi

#         for LABEL in ${LABELS[*]}; do
#             for NODE in ${NODE_NAMES[*]}; do
#                 # kubectl patch -p '{"spec":{"tolerations": null}}' node ${NODE}
#                 # echo ${NODE} $(echo ${LABEL} | cut -d '=' -f 1)
#                 # kubectl tolerations nodes ${NODE} $(echo ${LABEL} | cut -d '=' -f 1)
#                 echo ${NODE} ${LABEL}
#                 kubectl tolerations nodes ${NODE} ${LABEL}
#             done
#         done
#     fi
# }

# function kubectl_untolerations() {
#     if [ "$#" != "0" ] && [ "$#" != "2" ]; then
#         log_e "Usage: ${FUNCNAME[0]} <LABELS: key=value:NoSchedule> <NODE_NAMES>"
#     else
#         # log_m "${FUNCNAME[0]} $# ${*}"
#         # cd "${TOP_DIR:?}" || exit 1

#         if [ "$#" == "2" ]; then
#             local LABELS="${1}"
#             local NODE_NAMES=${2}""
#         else
#             local LABELS="node-role.kubernetes.io/control-plane=true node-role.kubernetes.io/etcd=true"
#             local NODE_NAMES=$(kubectl get nodes -l "${LABEL}" -o jsonpath='{.items[*].metadata.name}')
#         fi

#         for LABEL in ${LABELS[*]}; do
#             for NODE in ${NODE_NAMES[*]}; do
#                 # kubectl patch -p '{"spec":{"tolerations": null}}' node ${NODE}
#                 # echo ${NODE} $(echo ${LABEL} | cut -d '=' -f 1)
#                 # kubectl tolerations nodes ${NODE} $(echo ${LABEL} | cut -d '=' -f 1)-
#                 echo ${NODE} ${LABEL}
#                 kubectl tolerations nodes "${NODE}" "${LABEL}-"
#             done
#         done
#     fi
# }

function kubectl_undeploy_nodes() {
    if [ "$#" != "0" ] && [ "$#" != "1" ]; then
        log_e "Usage: ${FUNCNAME[0]} <NODES>"
        log_e "${FUNCNAME[0]} $# ${*}"
    else
        # log_m "${FUNCNAME[0]} $# ${*}"
        # cd "${TOP_DIR:?}" || exit 1

        if [ "$#" == "1" ]; then
            local NODES="${1}"
        else
            NODES="centos-worker-0 centos-worker-1 centos-worker-2"
            # NODES="ubuntu-worker-0 ubuntu-worker-1 ubuntu-worker-2"
        fi

        for NODE in ${NODES[*]}; do
            echo -e "\n>>> Undeploying ${NODE}..."
            if [ "$(kubectl get nodes ${NODE} -o jsonpath='{.status.conditions[?(@.type=="Ready")].status}')" == "True" ]; then
                # if ready, it will drain and cordon to taint 'node.kubernetes.io/unschedulable:NoSchedule'
                kubectl cordon ${NODE}
                kubectl drain --force --ignore-daemonsets --delete-emptydir-data --grace-period=10 ${NODE}
                # kubectl drain --force --ignore-daemonsets --delete-local-data --delete-emptydir-data --grace-period=10 ${NODE}
            else
                # if not ready, just cordon
                kubectl cordon ${NODE} # after restart: `kubectl uncordon ${NODE}`, to untaint 'node.kubernetes.io/unschedulable:NoSchedule'
            fi
            kubectl delete node ${NODE}
        done
        kubectl get nodes
    fi
}
# kubectl_undeploy_nodes "centos-master-1 centos-master-2"
# kubectl_undeploy_nodes "centos-worker-0"
# kubectl_undeploy_nodes "centos-worker-1"
# kubectl_undeploy_nodes "centos-worker-2"
# kubectl_undeploy_nodes "centos-worker-0 centos-worker-1"
# kubectl_undeploy_nodes "centos-worker-0 centos-worker-2"
# kubectl_undeploy_nodes "centos-worker-1 centos-worker-2"

function wait_for_control_plane_to_be_ready() {
    if [ "$#" != "0" ]; then
        log_e "Usage: ${FUNCNAME[0]} <NODES>"
    else
        while [ "$(kubectl get nodes --selector=node-role.kubernetes.io/control-plane=true -o jsonpath='{.items[*].status.conditions[?(.type=="Ready")].status}')" != "True" ]; do
            sleep 1
        done
        echo -e "\n>>> $(kubectl get nodes --selector=node-role.kubernetes.io/control-plane=true -o jsonpath'={.items[*].metadata.name}') is ready...\n"
    fi
}
# wait_for_control_plane_to_be_ready

function wait_for_worker_to_be_ready() {
    if [ "$#" != "0" ]; then
        log_e "Usage: ${FUNCNAME[0]} <NODES>"
    else
        while [ "$(kubectl get nodes --selector=node-role.kubernetes.io/control-plane!=true -o jsonpath='{.items[*].status.conditions[?(.type=="Ready")].status}' | wc -w)" != "$(kubectl get nodes --selector=node-role.kubernetes.io/control-plane!=true -o jsonpath='{.items[*].metadata.name}' | wc -w)" ]; do
            sleep 1
        done
        echo -e "\n>>> $(kubectl get nodes --selector=node-role.kubernetes.io/control-plane!=true -o jsonpath='{.items[*].metadata.name}') is ready...\n"
    fi
}
# wait_for_worker_to_be_ready

#******************************************************************************
# kubernetes - manifests
# https://longhorn.io/docs/1.1.1/references/examples

function kubectl_create_storage_class() {
    if [ "$#" != "0" ] && [ "$#" != "3" ]; then
        log_e "Usage: ${FUNCNAME[0]} <NAMESPACE> <STORAGE_CLASS_NAME> <PROVISIONER>"
        log_e "${FUNCNAME[0]} $# ${*}"
    else
        # log_m "${FUNCNAME[0]} $# ${*}"
        # cd "${TOP_DIR:?}" || exit 1

        if [ "$#" == "3" ]; then
            local NAMESPACE="${1}"           # default
            local STORAGE_CLASS_NAME=$"{2}"  # manual | standard
            local PROVISIONER="${3}"         # kubernetes.io/host-path | rancher.io/local-path | driver.longhorn.io
            local VOLUME_BINDING_MODE="${4}" # WaitForFirstConsumer | Immediate
        else
            local NAMESPACE=default
            local STORAGE_CLASS_NAME=standard
            local PROVISIONER="kubernetes.io/host-path"
            local VOLUME_BINDING_MODE=WaitForFirstConsumer
        fi

        echo -e "\n>>> Create SC in ${NAMESPACE}...\n"
        kubectl create -f - <<EOF
---
# host-path based default storage class
apiVersion: storage.k8s.io/v1
kind: StorageClass
metadata:
  name: ${STORAGE_CLASS_NAME}
  annotations:
    storageclass.kubernetes.io/is-default-class: "true"
provisioner: ${PROVISIONER}
# reclaimPolicy: Delete
# volumeBindingMode: ${VOLUME_BINDING_MODE}
EOF
        kubectl get sc
    fi
}

function kubectl_delete_storage_class() {
    if [ "$#" != "0" ] && [ "$#" != "3" ]; then
        log_e "Usage: ${FUNCNAME[0]} <NAMESPACE> <STORAGE_CLASS_NAME> <PROVISIONER>"
        log_e "${FUNCNAME[0]} $# ${*}"
    else
        # log_m "${FUNCNAME[0]} $# ${*}"
        # cd "${TOP_DIR:?}" || exit 1

        if [ "$#" == "3" ]; then
            local NAMESPACE="${1}"           # default
            local STORAGE_CLASS_NAME=$"{2}"  # manual | standard
            local PROVISIONER="${3}"         # kubernetes.io/host-path | rancher.io/local-path | driver.longhorn.io
            local VOLUME_BINDING_MODE="${4}" # WaitForFirstConsumer | Immediate
        else
            local NAMESPACE=default
            local STORAGE_CLASS_NAME=standard
            local PROVISIONER="kubernetes.io/host-path"
            local VOLUME_BINDING_MODE=WaitForFirstConsumer
        fi

        echo -e "\n>>> Delete SC in ${NAMESPACE}...\n"
        kubectl delete -f - <<EOF
---
# host-path based default storage class
apiVersion: storage.k8s.io/v1
kind: StorageClass
metadata:
  name: ${STORAGE_CLASS_NAME}
  annotations:
    storageclass.kubernetes.io/is-default-class: "true"
provisioner: ${PROVISIONER}
# reclaimPolicy: Delete
# volumeBindingMode: ${VOLUME_BINDING_MODE}
EOF
        kubectl get sc
    fi
}

function kubectl_create_persistent_volume() {
    if [ "$#" != "0" ] && [ "$#" != "5" ]; then
        log_e "Usage: ${FUNCNAME[0]} <NAMESPACE> <STORAGE_CLASS_NAME> <STORAGE_CAPACITY> <PERSISTENT_VOLUME_NAME> <MOUNT_PATH>"
        log_e "${FUNCNAME[0]} $# ${*}"
    else
        # log_m "${FUNCNAME[0]} $# ${*}"
        # cd "${TOP_DIR:?}" || exit 1

        if [ "$#" == "5" ]; then
            local NAMESPACE=${1}                # default
            local STORAGE_CLASS_NAME=${2}       # manual | standard
            local STORAGE_CAPACITY=${3}         # 12Gi
            local PERSISTENT_VOLUME_NAME="${4}" # persistent-volume-1
            local MOUNT_PATH="${5}"             # /mnt/pv-1 | /data
        else
            local NAMESPACE=default
            local STORAGE_CLASS_NAME=standard
            local STORAGE_CAPACITY=12Gi
            local PERSISTENT_VOLUME_NAME="persistent-volume-1"
            local MOUNT_PATH="/mnt/pv-1"
        fi

        echo -e "\n>>> Create PVC in ${NAMESPACE}...\n"
        kubectl create -f - <<EOF
---
kind: PersistentVolume
apiVersion: v1
metadata:
  name: ${PERSISTENT_VOLUME_NAME}
  labels:
    type: storage-volume
spec:
  storageClassName: ${STORAGE_CLASS_NAME}
  capacity:
    storage: ${STORAGE_CAPACITY}
  accessModes:
    - ReadWriteOnce
  hostPath:
    path: "${MOUNT_PATH}"
EOF
        ls -alh $(dirname ${MOUNT_PATH})
        kubectl get pv
    fi
}

function kubectl_delete_persistent_volume() {
    if [ "$#" != "0" ] && [ "$#" != "5" ]; then
        log_e "Usage: ${FUNCNAME[0]} <NAMESPACE> <STORAGE_CLASS_NAME> <STORAGE_CAPACITY> <PERSISTENT_VOLUME_NAME> <MOUNT_PATH>"
        log_e "${FUNCNAME[0]} $# ${*}"
    else
        # log_m "${FUNCNAME[0]} $# ${*}"
        # cd "${TOP_DIR:?}" || exit 1

        if [ "$#" == "5" ]; then
            local NAMESPACE=${1}                # default
            local STORAGE_CLASS_NAME=${2}       # manual | standard
            local STORAGE_CAPACITY=${3}         # 12Gi
            local PERSISTENT_VOLUME_NAME="${4}" # persistent-volume-1
            local MOUNT_PATH="${5}"             # /mnt/pv-1 | /data
        else
            local NAMESPACE=default
            local STORAGE_CLASS_NAME=standard
            local STORAGE_CAPACITY=12Gi
            local PERSISTENT_VOLUME_NAME="persistent-volume-1"
            local MOUNT_PATH="/mnt/pv-1"
        fi

        echo -e "\n>>> Delete PVC in ${NAMESPACE}...\n"
        kubectl delete -f - <<EOF
---
kind: PersistentVolume
apiVersion: v1
metadata:
  name: ${PERSISTENT_VOLUME_NAME}
  labels:
    type: storage-volume
spec:
  storageClassName: ${STORAGE_CLASS_NAME}
  capacity:
    storage: ${STORAGE_CAPACITY}
  accessModes:
    - ReadWriteOnce
  hostPath:
    path: "${MOUNT_PATH}"
EOF
        ls -alh $(dirname ${MOUNT_PATH})
        kubectl get pv
    fi
}

function kubectl_create_persistent_volume_claim() {
    if [ "$#" != "0" ] && [ "$#" != "4" ]; then
        log_e "Usage: ${FUNCNAME[0]} <NAMESPACE> <STORAGE_CLASS_NAME> <PERSISTENT_VOLUME_CLAIM_NAME> <STORAGE_SIZE>"
        log_e "${FUNCNAME[0]} $# ${*}"
    else
        # log_m "${FUNCNAME[0]} $# ${*}"
        # cd "${TOP_DIR:?}" || exit 1

        if [ "$#" == "4" ]; then
            local NAMESPACE=${1}                    # default
            local STORAGE_CLASS_NAME=${2}           # manual | standard
            local PERSISTENT_VOLUME_CLAIM_NAME=${3} # persistent-volume-claim-1
            local STORAGE_SIZE=${4}                 # 10Gi
        else
            local NAMESPACE=default
            local STORAGE_CLASS_NAME=standard
            local PERSISTENT_VOLUME_CLAIM_NAME=persistent-volume-claim-1
            local STORAGE_SIZE=10Gi
        fi

        echo -e "\n>>> Deploy the ${NAMESPACE} namespace...\n"
        kubectl create namespace ${NAMESPACE}

        echo -e "\n>>> Create PVC in ${NAMESPACE}...\n"
        kubectl create --namespace=${NAMESPACE} -f - <<EOF
---
apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: ${PERSISTENT_VOLUME_CLAIM_NAME}
  labels:
    app: storage-claim
spec:
  storageClassName: ${STORAGE_CLASS_NAME}
  accessModes:
    - ReadWriteOnce
  resources:
    requests:
      storage: ${STORAGE_SIZE}
EOF
        ls -alh $(dirname ${MOUNT_PATH})
        kubectl get pvc
    fi
}

function kubectl_delete_persistent_volume_claim() {
    if [ "$#" != "0" ] && [ "$#" != "4" ]; then
        log_e "Usage: ${FUNCNAME[0]} <NAMESPACE> <STORAGE_CLASS_NAME> <PERSISTENT_VOLUME_CLAIM_NAME> <STORAGE_SIZE>"
        log_e "${FUNCNAME[0]} $# ${*}"
    else
        # log_m "${FUNCNAME[0]} $# ${*}"
        # cd "${TOP_DIR:?}" || exit 1

        if [ "$#" == "4" ]; then
            local NAMESPACE=${1}                    # default
            local STORAGE_CLASS_NAME=${2}           # manual | standard
            local PERSISTENT_VOLUME_CLAIM_NAME=${3} # persistent-volume-claim-1
            local STORAGE_SIZE=${4}                 # 10Gi
        else
            local NAMESPACE=default
            local STORAGE_CLASS_NAME=standard
            local PERSISTENT_VOLUME_CLAIM_NAME=persistent-volume-claim-1
            local STORAGE_SIZE=10Gi
        fi

        echo -e "\n>>> Delete PVC in ${NAMESPACE}...\n"
        kubectl delete --namespace=${NAMESPACE} -f - <<EOF
---
apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: ${PERSISTENT_VOLUME_CLAIM_NAME}
  labels:
    app: storage-claim
spec:
  storageClassName: ${STORAGE_CLASS_NAME}
  accessModes:
    - ReadWriteOnce
  resources:
    requests:
      storage: ${STORAGE_SIZE}
EOF
        ls -alh $(dirname ${MOUNT_PATH})
        kubectl get pvc
    fi
}

function kubectl_deploy_demo_app() {
    if [ "$#" != "1" ] && [ "$#" != "6" ]; then
        log_e "Usage: ${FUNCNAME[0]} <NAMESPACE> <POD_NAME> <IMAGE> <PERSISTENT_VOLUME_NAME> <MOUNT_PATH> <PERSISTENT_VOLUME_CLAIM_NAME>"
        log_e "${FUNCNAME[0]} $# ${*}"
    else
        # log_m "${FUNCNAME[0]} $# ${*}"
        # cd "${TOP_DIR:?}" || exit 1

        if [ "$#" == "6" ]; then
            local NAMESPACE=${1}                      # default
            local POD_NAME=${2}                       # demo-pod
            local IMAGE="${3}"                        # nginx:stable-alpine
            local PERSISTENT_VOLUME_NAME="${4}"       # persistent-volume-1
            local MOUNT_PATH="${5}"                   # /mnt/pv-1 | /data
            local PERSISTENT_VOLUME_CLAIM_NAME="${6}" # persistent-volume-claim-1
        else
            local NAMESPACE=default
            local POD_NAME=demo-pod
            local IMAGE="nginx:stable-alpine"
            local PERSISTENT_VOLUME_NAME="persistent-volume-1"
            local MOUNT_PATH="/mnt/pv-1"
            local PERSISTENT_VOLUME_CLAIM_NAME="persistent-volume-claim-1"
        fi

        echo -e "\n>>> Create Pod in ${1}...\n"
        kubectl get namespace --namespace ${1}
        kubectl get resourcequota --namespace ${1}
        kubectl get limitrange --namespace ${1}
        kubectl create --namespace ${1} -f - <<EOF
---
apiVersion: v1
kind: Pod
metadata:
  name: ${POD_NAME}
  labels:
    app: demo-app
spec:
  restartPolicy: Always
  containers:
  - name: ${POD_NAME}-container
    image: ${IMAGE}
    imagePullPolicy: IfNotPresent
    resources:
      requests:
        memory: "64Mi"
        cpu: "250m"
      limits:
        memory: "128Mi"
        cpu: "500m"
    ports:
    - containerPort: 80
#     livenessProbe:
#     exec:
#         command:
#         - ls
#         - ${MOUNT_PATH}/lost+found
#     initialDelaySeconds: 3
#     periodSeconds: 5
#     volumeMounts:
#     - name: ${PERSISTENT_VOLUME_NAME}
#         mountPath: ${MOUNT_PATH}
#   volumes:
#     - name: ${PERSISTENT_VOLUME_NAME}
#       persistentVolumeClaim:
#         claimName: ${PERSISTENT_VOLUME_CLAIM_NAME}
EOF
        kubectl get pod --namespace ${1}
    fi
}

function kubectl_undeploy_demo_app() {
    if [ "$#" != "1" ] && [ "$#" != "6" ]; then
        log_e "Usage: ${FUNCNAME[0]} <NAMESPACE> <POD_NAME> <IMAGE> <PERSISTENT_VOLUME_NAME> <MOUNT_PATH> <PERSISTENT_VOLUME_CLAIM_NAME>"
        log_e "${FUNCNAME[0]} $# ${*}"
    else
        # log_m "${FUNCNAME[0]} $# ${*}"
        # cd "${TOP_DIR:?}" || exit 1

        if [ "$#" == "6" ]; then
            local NAMESPACE=${1}                      # default
            local POD_NAME=${2}                       # demo-pod
            local IMAGE="${3}"                        # nginx:stable-alpine
            local PERSISTENT_VOLUME_NAME="${4}"       # persistent-volume-1
            local MOUNT_PATH="${5}"                   # /mnt/pv-1 | /data
            local PERSISTENT_VOLUME_CLAIM_NAME="${6}" # persistent-volume-claim-1
        else
            local NAMESPACE=default
            local POD_NAME=demo-pod
            local IMAGE="nginx:stable-alpine"
            local PERSISTENT_VOLUME_NAME="persistent-volume-1"
            local MOUNT_PATH="/mnt/pv-1"
            local PERSISTENT_VOLUME_CLAIM_NAME="persistent-volume-claim-1"
        fi

        echo -e "\n>>> Create Pod in ${1}...\n"
        kubectl get namespace --namespace ${1}
        kubectl get resourcequota --namespace ${1}
        kubectl get limitrange --namespace ${1}
        kubectl delete --namespace ${1} -f - <<EOF
---
apiVersion: v1
kind: Pod
metadata:
  name: ${POD_NAME}
  labels:
    app: demo-app
spec:
  restartPolicy: Always
  containers:
  - name: ${POD_NAME}-container
    image: ${IMAGE}
    imagePullPolicy: IfNotPresent
    resources:
      requests:
        memory: "64Mi"
        cpu: "250m"
      limits:
        memory: "128Mi"
        cpu: "500m"
    ports:
    - containerPort: 80
#     livenessProbe:
#     exec:
#         command:
#         - ls
#         - ${MOUNT_PATH}/lost+found
#     initialDelaySeconds: 3
#     periodSeconds: 5
#     volumeMounts:
#     - name: ${PERSISTENT_VOLUME_NAME}
#         mountPath: ${MOUNT_PATH}
#   volumes:
#     - name: ${PERSISTENT_VOLUME_NAME}
#       persistentVolumeClaim:
#         claimName: ${PERSISTENT_VOLUME_CLAIM_NAME}
EOF
        kubectl get pod --namespace ${1}
    fi
}

#******************************************************************************
# kubernetes - helm

#******************************************************************************
# Terraform

function get_terraform_ips() {
    if [ "$#" != "0" ] && [ "$#" != "2" ]; then
        log_e "Usage: ${FUNCNAME[0]} [<DEPLOYMENT_PLATFORM_DISTRO_TOP_DIR> <INFRASTRUCTURE_DEPLOYMENT_PROJECT>]"
        log_e "${FUNCNAME[0]} $# ${*}"
    else
        log_m "${FUNCNAME[0]} $# ${*}"
        # cd "${TOP_DIR:?}" || exit 1

        if [ "$#" == "2" ]; then
            local DEPLOYMENT_PLATFORM_DISTRO_TOP_DIR=${1}
            local INFRASTRUCTURE_DEPLOYMENT_PROJECT=${2}
        fi
        cd ${DEPLOYMENT_PLATFORM_DISTRO_TOP_DIR} || exit 1

        case ${INFRASTRUCTURE_DEPLOYMENT_PROJECT} in
            terraform_env)
                get_terraform_env_ips ${DEPLOYMENT_PLATFORM_DISTRO_TOP_DIR}
                ;;
            terraform_mos)
                get_terraform_mos_ips ${DEPLOYMENT_PLATFORM_DISTRO_TOP_DIR}
                ;;
            terraform_rancher)
                get_terraform_rancher_ips ${DEPLOYMENT_PLATFORM_DISTRO_TOP_DIR}
                ;;
            *) ;;
        esac
    fi
}

function get_terraform_env_ips() {
    if [ "$#" != "0" ] && [ "$#" != "1" ]; then
        log_e "Usage: ${FUNCNAME[0]} [<DEPLOYMENT_PLATFORM_DISTRO_TOP_DIR>]"
        log_e "${FUNCNAME[0]} $# ${*}"
    else
        log_m "${FUNCNAME[0]} $# ${*}"
        # cd "${TOP_DIR:?}" || exit 1

        if [ "$#" == "1" ]; then
            local DEPLOYMENT_PLATFORM_DISTRO_TOP_DIR=${1}
        fi
        cd ${DEPLOYMENT_PLATFORM_DISTRO_TOP_DIR} || exit 1

        IP_ETCDS=$(terraform output ip_etcds | cut -d "=" -f 2 | sed 's/^[ \t]*//' | sed 's/[ \t]*$//' | sed ':a;N;$!ba;s/\n/ /g' | tr -d '{' | tr -d '}' | sed 's/^[ \t]*//' | sed 's/[ \t]*$//' | tr -d '"')
        IP_STORAGES=$(terraform output ip_storages | cut -d "=" -f 2 | sed 's/^[ \t]*//' | sed 's/[ \t]*$//' | sed ':a;N;$!ba;s/\n/ /g' | tr -d '{' | tr -d '}' | sed 's/^[ \t]*//' | sed 's/[ \t]*$//' | tr -d '"')
        IP_MASTERS=$(terraform output ip_masters | cut -d "=" -f 2 | sed 's/^[ \t]*//' | sed 's/[ \t]*$//' | sed ':a;N;$!ba;s/\n/ /g' | tr -d '{' | tr -d '}' | sed 's/^[ \t]*//' | sed 's/[ \t]*$//' | tr -d '"')
        IP_WORKERS=$(terraform output ip_workers | cut -d "=" -f 2 | sed 's/^[ \t]*//' | sed 's/[ \t]*$//' | sed ':a;N;$!ba;s/\n/ /g' | tr -d '{' | tr -d '}' | sed 's/^[ \t]*//' | sed 's/[ \t]*$//' | tr -d '"')
        IPS="${IP_ETCDS[*]} ${IP_STORAGES[*]} ${IP_MASTERS[*]} ${IP_WORKERS[*]}"
        echo ">>> IPS: ${#IPS[*]} ${IPS}"
    fi
}

function get_terraform_mos_ips() {
    if [ "$#" != "0" ] && [ "$#" != "1" ]; then
        log_e "Usage: ${FUNCNAME[0]} [<DEPLOYMENT_PLATFORM_DISTRO_TOP_DIR>]"
        log_e "${FUNCNAME[0]} $# ${*}"
    else
        log_m "${FUNCNAME[0]} $# ${*}"
        # cd "${TOP_DIR:?}" || exit 1

        if [ "$#" == "1" ]; then
            local DEPLOYMENT_PLATFORM_DISTRO_TOP_DIR=${1}
        fi
        cd ${DEPLOYMENT_PLATFORM_DISTRO_TOP_DIR} || exit 1

        IP_ALPINES=$(terraform output ip_alpines | cut -d "=" -f 2 | sed 's/^[ \t]*//' | sed 's/[ \t]*$//' | sed ':a;N;$!ba;s/\n/ /g' | tr -d '{' | tr -d '}' | sed 's/^[ \t]*//' | sed 's/[ \t]*$//' | tr -d '"')
        IP_CENTOSS=$(terraform output ip_centoss | cut -d "=" -f 2 | sed 's/^[ \t]*//' | sed 's/[ \t]*$//' | sed ':a;N;$!ba;s/\n/ /g' | tr -d '{' | tr -d '}' | sed 's/^[ \t]*//' | sed 's/[ \t]*$//' | tr -d '"')
        IP_CIRROSS=$(terraform output ip_cirross | cut -d "=" -f 2 | sed 's/^[ \t]*//' | sed 's/[ \t]*$//' | sed ':a;N;$!ba;s/\n/ /g' | tr -d '{' | tr -d '}' | sed 's/^[ \t]*//' | sed 's/[ \t]*$//' | tr -d '"')
        IP_DEBIANS=$(terraform output ip_debians | cut -d "=" -f 2 | sed 's/^[ \t]*//' | sed 's/[ \t]*$//' | sed ':a;N;$!ba;s/\n/ /g' | tr -d '{' | tr -d '}' | sed 's/^[ \t]*//' | sed 's/[ \t]*$//' | tr -d '"')
        IP_FEDORAS=$(terraform output ip_fedoras | cut -d "=" -f 2 | sed 's/^[ \t]*//' | sed 's/[ \t]*$//' | sed ':a;N;$!ba;s/\n/ /g' | tr -d '{' | tr -d '}' | sed 's/^[ \t]*//' | sed 's/[ \t]*$//' | tr -d '"')
        IP_OPENSUSE_LEAPS=$(terraform output ip_opensuse_leaps | cut -d "=" -f 2 | sed 's/^[ \t]*//' | sed 's/[ \t]*$//' | sed ':a;N;$!ba;s/\n/ /g' | tr -d '{' | tr -d '}' | sed 's/^[ \t]*//' | sed 's/[ \t]*$//' | tr -d '"')
        IP_OPENSUSE_TUMBLEWEEDS=$(terraform output ip_opensuse_tumbleweeds | cut -d "=" -f 2 | sed 's/^[ \t]*//' | sed 's/[ \t]*$//' | sed ':a;N;$!ba;s/\n/ /g' | tr -d '{' | tr -d '}' | sed 's/^[ \t]*//' | sed 's/[ \t]*$//' | tr -d '"')
        IP_ORACLE_LINUXES=$(terraform output ip_oracle_linuxes | cut -d "=" -f 2 | sed 's/^[ \t]*//' | sed 's/[ \t]*$//' | sed ':a;N;$!ba;s/\n/ /g' | tr -d '{' | tr -d '}' | sed 's/^[ \t]*//' | sed 's/[ \t]*$//' | tr -d '"')
        IP_RANCHER_HARVESTERS=$(terraform output ip_rancher_harvesters | cut -d "=" -f 2 | sed 's/^[ \t]*//' | sed 's/[ \t]*$//' | sed ':a;N;$!ba;s/\n/ /g' | tr -d '{' | tr -d '}' | sed 's/^[ \t]*//' | sed 's/[ \t]*$//' | tr -d '"')
        IP_RANCHER_K3OSS=$(terraform output ip_rancher_k3oss | cut -d "=" -f 2 | sed 's/^[ \t]*//' | sed 's/[ \t]*$//' | sed ':a;N;$!ba;s/\n/ /g' | tr -d '{' | tr -d '}' | sed 's/^[ \t]*//' | sed 's/[ \t]*$//' | tr -d '"')
        IP_RANCHER_OSS=$(terraform output ip_rancher_oss | cut -d "=" -f 2 | sed 's/^[ \t]*//' | sed 's/[ \t]*$//' | sed ':a;N;$!ba;s/\n/ /g' | tr -d '{' | tr -d '}' | sed 's/^[ \t]*//' | sed 's/[ \t]*$//' | tr -d '"')
        IP_RASPIOS=$(terraform output ip_raspioss | cut -d "=" -f 2 | sed 's/^[ \t]*//' | sed 's/[ \t]*$//' | sed ':a;N;$!ba;s/\n/ /g' | tr -d '{' | tr -d '}' | sed 's/^[ \t]*//' | sed 's/[ \t]*$//' | tr -d '"')
        IP_SLESS=$(terraform output ip_sless | cut -d "=" -f 2 | sed 's/^[ \t]*//' | sed 's/[ \t]*$//' | sed ':a;N;$!ba;s/\n/ /g' | tr -d '{' | tr -d '}' | sed 's/^[ \t]*//' | sed 's/[ \t]*$//' | tr -d '"')
        IP_UBUNTUS=$(terraform output ip_ubuntus | cut -d "=" -f 2 | sed 's/^[ \t]*//' | sed 's/[ \t]*$//' | sed ':a;N;$!ba;s/\n/ /g' | tr -d '{' | tr -d '}' | sed 's/^[ \t]*//' | sed 's/[ \t]*$//' | tr -d '"')
        IPS="${IP_ALPINES} ${IP_CENTOSS[*]} ${IP_CIRROSS[*]} ${IP_DEBIANS[*]} ${IP_FEDORAS[*]} ${IP_OPENSUSE_LEAPS[*]} ${IP_OPENSUSE_TUMBLEWEEDS[*]} ${IP_RANCHER_HARVESTERS[*]} ${IP_RANCHER_K3OSS[*]} ${IP_RANCHER_OSS[*]} ${IP_RASPIOSS[*]} ${IP_SLESS[*]} ${IP_UBUNTUS[*]}"
        echo ">>> IPS: ${#IPS[*]} ${IPS}"
    fi
}

function get_terraform_rancher_ips() {
    if [ "$#" != "0" ] && [ "$#" != "1" ]; then
        log_e "Usage: ${FUNCNAME[0]} [<DEPLOYMENT_PLATFORM_DISTRO_TOP_DIR>]"
        log_e "${FUNCNAME[0]} $# ${*}"
    else
        log_m "${FUNCNAME[0]} $# ${*}"
        # cd "${TOP_DIR:?}" || exit 1

        if [ "$#" == "1" ]; then
            local DEPLOYMENT_PLATFORM_DISTRO_TOP_DIR=${1}
        fi
        cd ${DEPLOYMENT_PLATFORM_DISTRO_TOP_DIR} || exit 1

        IP_MASTERS=$(terraform output ip_masters | cut -d "=" -f 2 | sed 's/^[ \t]*//' | sed 's/[ \t]*$//' | sed ':a;N;$!ba;s/\n/ /g' | tr -d '{' | tr -d '}' | sed 's/^[ \t]*//' | sed 's/[ \t]*$//' | tr -d '"')
        IP_WORKERS=$(terraform output ip_workers | cut -d "=" -f 2 | sed 's/^[ \t]*//' | sed 's/[ \t]*$//' | sed ':a;N;$!ba;s/\n/ /g' | tr -d '{' | tr -d '}' | sed 's/^[ \t]*//' | sed 's/[ \t]*$//' | tr -d '"')
        IPS="${IP_MASTERS[*]} ${IP_WORKERS[*]}"
        echo ">>> IPS: ${#IPS[*]} ${IPS}"
    fi
}

#******************************************************************************
# Vagrant

function vagrant_start() {
    if [ "$#" != "0" ] && [ "$#" != "1" ]; then
        log_e "Usage: ${FUNCNAME[0]} <VAGRANT_FILE>"
        log_e "${FUNCNAME[0]} $# ${*}"
    else
        log_m "${FUNCNAME[0]} $# ${*}"
        cd "${TOP_DIR:?}" || exit 1

        # if [ "$#" == "1" ]; then
        #     local VAGRANT_FILE=${1}
        # fi

        vagrant validate
        vagrant up --provider libvirt
        vagrant global-status
    fi
}

function vagrant_stop() {
    if [ "$#" != "0" ] && [ "$#" != "1" ]; then
        log_e "Usage: ${FUNCNAME[0]} <VAGRANT_FILE>"
        log_e "${FUNCNAME[0]} $# ${*}"
    else
        log_m "${FUNCNAME[0]} $# ${*}"
        cd "${TOP_DIR:?}" || exit 1

        # if [ "$#" == "1" ]; then
        #     local VAGRANT_FILE=${1}
        # fi

        vagrant validate
        vagrant destroy -f #${VAGRANT_FILE}
        vagrant global-status
    fi
}

#******************************************************************************
# Packer

function packer_lint() {
    if [ "$#" != "1" ]; then
        log_e "Usage: ${FUNCNAME[0]} <SRC_DIR> [<PROJECT_BIN>]"
        log_e "${FUNCNAME[0]} $# ${*}"
    else
        log_m "${FUNCNAME[0]} $# ${*}"
        # cd "${TOP_DIR:?}" || exit 1

        if [ "$#" == "1" ]; then
            local PROJECT_BIN=packer
            local SRC_DIR=${1}
        fi

        cd "${SRC_DIR:?}" || exit 1

        ${PROJECT_BIN} validate .
        ${PROJECT_BIN} fmt .
    fi
}

function packer_build() {
    if [ "$#" != "1" ] && [ "$#" == "4" ]; then
        log_e "Usage: ${FUNCNAME[0]} <SRC_DIR> [<PROJECT_BIN>] [<BUILD_TYPE> <VAR_FILE> <SRC_FILE> <ARTIFACT_DIR>]"
        log_e "${FUNCNAME[0]} $# ${*}"
    else
        log_m "${FUNCNAME[0]} $# ${*}"
        # cd "${TOP_DIR:?}" || exit 1

        if [ "$#" == "2" ]; then
            local PROJECT_BIN=packer
            local SRC_DIR=${1}
            local ARTIFACT_DIR=${2}
        elif [ "$#" == "5" ]; then
            local PROJECT_BIN=packer
            local SRC_DIR=${1}
            local BUILD_TYPE=${2}
            local VAR_FILE=${3}
            local SRC_FILE=${4}
            local ARTIFACT_DIR=${5}
        fi

        cd "${SRC_DIR:?}" || exit 1

        rm -rf ${ARTIFACT_DIR}

        if [ "$#" == "1" ]; then
            ${PROJECT_BIN} build .
        elif [ "$#" == "4" ]; then
            ${PROJECT_BIN} build -only=${BUILD_TYPE} -var-file=${VAR_FILE} ${SRC_FILE}
        fi
    fi
}

#******************************************************************************
# Ansible

# https://code-maven.com/getting-started-with-ansible-centos
function remote_module_action() {
    if [ "$#" != "5" ] && [ "$#" != "6" ]; then
        log_e "Usage: ${FUNCNAME[0]} <PLATFORM> <SSH_USER> <SSH_GROUP> <SSH_PASSWORD> <MODULE> [<ACTION>]"
        log_e "${FUNCNAME[0]} $# ${*}"
    else
        log_m "${FUNCNAME[0]} $# ${*}"
        # cd "${TOP_DIR:?}" || exit 1

        # if [ "$#" == "5" ]; then
        #     local PLATFORM=${1}
        #     local SSH_USER=${2}
        #     local SSH_GROUP=${3}
        #     local SSH_PASSWORD=${4}
        #     local MODULE=${5}
        #     local ACTION=${6}
        # fi

        cd "${CONFIGURATION_MANAGEMENT_TOP_DIR}" || exit 1
        rm -f "${HOME}/.ssh/known_hosts"

        if [ "$#" == "5" ]; then
            ansible --inventory "inventories/${1}/hosts" --user "${2}" "${3}" --module-name "${5}" --extra-vars '{ ansible_python_interpreter: "/usr/bin/python3" }' # -vvv
            # ansible --inventory "inventories/${1}/hosts" --user "${2}" "${3}" --module-name "${5}" # --extra-vars "ansible_user=${2} ansible_password=${4}"
            # ansible --inventory "inventories/${1}/hosts" --user "${2}" "${3}" --module-name "${5}" # --ssh-common-args "-o UserKnownHostsFile=/dev/null -o StrictHostKeyChecking=no"
        else
            ansible --inventory "inventories/${1}/hosts" --user "${2}" -b "${3}" --module-name "${5}" --args "${6}" --extra-vars '{ ansible_python_interpreter: "/usr/bin/python3" }' # -vvv
            # ansible --inventory "inventories/${1}/hosts" --user "${2}" "${3}" --module-name "${5}" --args "${6}" --extra-vars '{ ansible_python_interpreter: "/usr/bin/python3" }' # -vvv
        fi
    fi
}
# remote_module_action "${PLATFORM}" "${SSH_USER}" "${SSH_GROUP}" "${SSH_PASSWORD}" "${MODULE}"

# https://code-maven.com/getting-started-with-ansible-centos
function remote_action() {
    if [ "$#" != "5" ]; then
        log_e "Usage: ${FUNCNAME[0]} <PLATFORM> <SSH_USER> <SSH_GROUP> <SSH_PASSWORD> <REMOTE_ACTION>"
        log_e "${FUNCNAME[0]} $# ${*}"
    else
        log_m "${FUNCNAME[0]} $# ${*}"
        # cd "${TOP_DIR:?}" || exit 1

        # if [ "$#" == "5" ]; then
        #     local PLATFORM=${1}
        #     local SSH_USER=${2}
        #     local SSH_GROUP=${3}
        #     local SSH_PASSWORD=${4}
        #     local REMOTE_ACTION=${5}
        # fi

        cd "${CONFIGURATION_MANAGEMENT_TOP_DIR}" || exit 1
        rm -f "${HOME}/.ssh/known_hosts"

        ansible --inventory "inventories/${1}/hosts" --user "${2}" "${3}" --args "${5}" --extra-vars '{ ansible_python_interpreter: "/usr/bin/python3" }' # -vvv
        # ansible --inventory "inventories/${1}/hosts" --user "${2}" "${3}" --args "${5}" # --extra-vars "ansible_user=${2} ansible_password=${4}"
        # ansible --inventory "inventories/${1}/hosts" --user "${2}" "${3}" --args "${5}" # --ssh-common-args "-o UserKnownHostsFile=/dev/null -o StrictHostKeyChecking=no"
    fi
}
# remote_action "${PLATFORM}" "${SSH_USER}" "${SSH_GROUP}" "${SSH_PASSWORD}" "${REMOTE_ACTION}"

function playbook() {
    if [ "$#" != "5" ] && [ "$#" != "6" ]; then
        log_e "Usage: ${FUNCNAME[0]} <PLATFORM> <SSH_USER> <SSH_GROUP> <SSH_PASSWORD> <PLAYBOOK> [ARGS]"
        log_e "${FUNCNAME[0]} $# ${*}"
    else
        log_m "${FUNCNAME[0]} $# ${*}"
        # cd "${TOP_DIR:?}" || exit 1

        # if [ "$#" == "5" ]; then
        #     local PLATFORM=${1}
        #     local SSH_USER=${2}
        #     local SSH_GROUP=${3}
        #     local SSH_PASSWORD=${4}
        #     local PLAYBOOK=${5}
        #     local ARGS=${6}
        # fi

        cd "${CONFIGURATION_MANAGEMENT_TOP_DIR}" || exit 1
        rm -f "${HOME}/.ssh/known_hosts"
        # sshpass -p "${4}" ssh-copy-id -i ${HOME}/.ssh/id_rsa.pub -o StrictHostKeyChecking=no ${4}"@"${IP} -p 22
        # sshpass -p "${4}" ssh-copy-id -i ${HOME}/.ssh/id_rsa.pub -o StrictHostKeyChecking=no localhost

        if [ "$#" == "5" ]; then
            ansible-playbook --inventory "inventories/${1}/hosts" --user "${2}" playbooks/${5}.yml # -vvv
        else
            ansible-playbook --inventory "inventories/${1}/hosts" --user "${2}" playbooks/${5}.yml --extra-vars "${6}" # -vvv
        fi
    fi
}
# playbook "${PLATFORM}" "${SSH_USER}" "${SSH_GROUP}" "${SSH_PASSWORD}" "${PLAYBOOK}" '{ "hosts": ["remotes"] }'

#******************************************************************************
# iscsi

function mount_iscsi() {
    if [ "$#" != "5" ]; then
        log_e "Usage: ${FUNCNAME[0]} <TARGETNAME> <IP> <PORT> <UUID> <MOUNT_DIR>"
        log_e "${FUNCNAME[0]} $# ${*}"
    else
        log_m "${FUNCNAME[0]} $# ${*}"
        # cd "${TOP_DIR:?}" || exit 1

        if [ "$#" == "5" ]; then
            local TARGETNAME=${1}
            local IP=${2}
            local PORT=${3}
            local UUID=${4}
            local MOUNT_DIR=${5}
        fi

        # echo "Restarting iSCSI"
        systemctl status iscsid
        # systemctl restart iscsid

        echo "Discovering and mounting"
        iscsiadm -m discovery -t st -p $I{PORT}
        iscsiadm -m node --targetname "${TARGETNAME}" --portal "${IP}:${PORT}" --login
        sleep 1
        mount --uuid $UUID ${MOUNT_DIR}
        mount -l | grep iscsi
    fi
}

function umount_iscsi() {
    if [ "$#" != "4" ]; then
        log_e "Usage: ${FUNCNAME[0]} <TARGETNAME> <IP> <PORT> <MOUNT_DIR>"
        log_e "${FUNCNAME[0]} $# ${*}"
    else
        log_m "${FUNCNAME[0]} $# ${*}"
        # cd "${TOP_DIR:?}" || exit 1

        if [ "$#" == "4" ]; then
            local TARGETNAME=${1}
            local IP=${2}
            local PORT=${3}
            local MOUNT_DIR=${4}
        fi

        umount ${MOUNT_DIR}
        iscsiadm -m node --targetname "${TARGETNAME}" --portal "${IP}:${PORT}" --logout
        mount -l | grep iscsi

        # echo "Restarting iSCSI"
        # systemctl restart iscsid
    fi
}

#******************************************************************************
# nfs

function nfs_mount() {
    if [ "$#" != "2" ]; then
        log_e "Usage: ${FUNCNAME[0]} <IP> <MOUNT_DIR>"
        log_e "${FUNCNAME[0]} $# ${*}"
    else
        log_m "${FUNCNAME[0]} $# ${*}"
        # cd "${TOP_DIR:?}" || exit 1

        if [ "$#" == "2" ]; then
            local IP=${1}
            local MOUNT_DIR=${2} # /mnt/nfs | /mnt/backupstore
        fi

        # echo "Restarting nfs-server"
        systemctl status rpcbind.service
        # systemctl start rpcbind.service
        systemctl status nfs-server.service
        # systemctl start nfs-server.service

        sudo mkdir -p ${MOUNT_DIR}
        sudo mount -t nfs4 ${NFS_IPADDR}:/ ${MOUNT_DIR}
        # sudo mount -t nfs -o nfsvers=4 ${1}:/ ${MOUNT_DIR}
        mount -l | grep nfs
    fi
}

function nfs_unmount() {
    if [ "$#" != "1" ]; then
        log_e "Usage: ${FUNCNAME[0]} <MOUNT_DIR>"
        log_e "${FUNCNAME[0]} $# ${*}"
    else
        log_m "${FUNCNAME[0]} $# ${*}"
        # cd "${TOP_DIR:?}" || exit 1

        if [ "$#" == "1" ]; then
            local MOUNT_DIR=${1} # /mnt/nfs | /mnt/backupstore
        fi

        sudo umount ${MOUNT_DIR}
        sudo rm -rf ${MOUNT_DIR}
        mount -l | grep nfs
    fi
}
